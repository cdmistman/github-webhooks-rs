#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstance {
	/// Identifies the configuration under which the analysis was executed. For
	/// example, in GitHub Actions this includes the workflow filename and job
	/// name.
	pub analysis_key:    String,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub classifications: Vec<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub commit_sha:      Option<String>,
	/// Identifies the variable values associated with the environment in which
	/// the analysis that generated this alert instance was performed, such as
	/// the language that was analyzed.
	pub environment:     String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub location:        Option<AlertInstanceLocation>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub message:         Option<AlertInstanceMessage>,
	/// The full Git reference, formatted as `refs/heads/<branch name>`.
	#[serde(rename = "ref")]
	pub ref_:            String,
	/// State of a code scanning alert.
	pub state:           AlertInstanceState,
}
impl From<&AlertInstance> for AlertInstance {
	fn from(value: &AlertInstance) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceLocation {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub end_column:   Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub end_line:     Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub path:         Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub start_column: Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub start_line:   Option<i64>,
}
impl From<&AlertInstanceLocation> for AlertInstanceLocation {
	fn from(value: &AlertInstanceLocation) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AlertInstanceMessage {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub text: Option<String>,
}
impl From<&AlertInstanceMessage> for AlertInstanceMessage {
	fn from(value: &AlertInstanceMessage) -> Self {
		value.clone()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlertInstanceState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "dismissed")]
	Dismissed,
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&AlertInstanceState> for AlertInstanceState {
	fn from(value: &AlertInstanceState) -> Self {
		value.clone()
	}
}
impl ToString for AlertInstanceState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Dismissed => "dismissed".to_string(),
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for AlertInstanceState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"dismissed" => Ok(Self::Dismissed),
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AlertInstanceState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AlertInstanceState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AlertInstanceState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// GitHub apps are a new way to extend GitHub. They can be installed directly
/// on organizations and user accounts and granted access to specific
/// repositories. They come with granular permissions and built-in webhooks.
/// GitHub apps are first class actors within GitHub.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct App {
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	pub description:  Option<String>,
	/// The list of events for the GitHub app
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub events:       Vec<AppEventsItem>,
	pub external_url: String,
	pub html_url:     String,
	/// Unique identifier of the GitHub app
	pub id:           i64,
	/// The name of the GitHub app
	pub name:         String,
	pub node_id:      String,
	pub owner:        User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub permissions:  Option<AppPermissions>,
	/// The slug name of the GitHub app
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub slug:         Option<String>,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&App> for App {
	fn from(value: &App) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppEventsItem {
	#[serde(rename = "branch_protection_rule")]
	BranchProtectionRule,
	#[serde(rename = "check_run")]
	CheckRun,
	#[serde(rename = "check_suite")]
	CheckSuite,
	#[serde(rename = "code_scanning_alert")]
	CodeScanningAlert,
	#[serde(rename = "commit_comment")]
	CommitComment,
	#[serde(rename = "content_reference")]
	ContentReference,
	#[serde(rename = "create")]
	Create,
	#[serde(rename = "delete")]
	Delete,
	#[serde(rename = "deployment")]
	Deployment,
	#[serde(rename = "deployment_review")]
	DeploymentReview,
	#[serde(rename = "deployment_status")]
	DeploymentStatus,
	#[serde(rename = "deploy_key")]
	DeployKey,
	#[serde(rename = "discussion")]
	Discussion,
	#[serde(rename = "discussion_comment")]
	DiscussionComment,
	#[serde(rename = "fork")]
	Fork,
	#[serde(rename = "gollum")]
	Gollum,
	#[serde(rename = "issues")]
	Issues,
	#[serde(rename = "issue_comment")]
	IssueComment,
	#[serde(rename = "label")]
	Label,
	#[serde(rename = "member")]
	Member,
	#[serde(rename = "membership")]
	Membership,
	#[serde(rename = "merge_group")]
	MergeGroup,
	#[serde(rename = "merge_queue_entry")]
	MergeQueueEntry,
	#[serde(rename = "milestone")]
	Milestone,
	#[serde(rename = "organization")]
	Organization,
	#[serde(rename = "org_block")]
	OrgBlock,
	#[serde(rename = "page_build")]
	PageBuild,
	#[serde(rename = "project")]
	Project,
	#[serde(rename = "projects_v2_item")]
	ProjectsV2Item,
	#[serde(rename = "project_card")]
	ProjectCard,
	#[serde(rename = "project_column")]
	ProjectColumn,
	#[serde(rename = "public")]
	Public,
	#[serde(rename = "pull_request")]
	PullRequest,
	#[serde(rename = "pull_request_review")]
	PullRequestReview,
	#[serde(rename = "pull_request_review_comment")]
	PullRequestReviewComment,
	#[serde(rename = "pull_request_review_thread")]
	PullRequestReviewThread,
	#[serde(rename = "push")]
	Push,
	#[serde(rename = "registry_package")]
	RegistryPackage,
	#[serde(rename = "release")]
	Release,
	#[serde(rename = "repository")]
	Repository,
	#[serde(rename = "repository_dispatch")]
	RepositoryDispatch,
	#[serde(rename = "secret_scanning_alert")]
	SecretScanningAlert,
	#[serde(rename = "secret_scanning_alert_location")]
	SecretScanningAlertLocation,
	#[serde(rename = "security_and_analysis")]
	SecurityAndAnalysis,
	#[serde(rename = "star")]
	Star,
	#[serde(rename = "status")]
	Status,
	#[serde(rename = "team")]
	Team,
	#[serde(rename = "team_add")]
	TeamAdd,
	#[serde(rename = "watch")]
	Watch,
	#[serde(rename = "workflow_dispatch")]
	WorkflowDispatch,
	#[serde(rename = "workflow_run")]
	WorkflowRun,
	#[serde(rename = "workflow_job")]
	WorkflowJob,
}
impl From<&AppEventsItem> for AppEventsItem {
	fn from(value: &AppEventsItem) -> Self {
		value.clone()
	}
}
impl ToString for AppEventsItem {
	fn to_string(&self) -> String {
		match *self {
			Self::BranchProtectionRule => "branch_protection_rule".to_string(),
			Self::CheckRun => "check_run".to_string(),
			Self::CheckSuite => "check_suite".to_string(),
			Self::CodeScanningAlert => "code_scanning_alert".to_string(),
			Self::CommitComment => "commit_comment".to_string(),
			Self::ContentReference => "content_reference".to_string(),
			Self::Create => "create".to_string(),
			Self::Delete => "delete".to_string(),
			Self::Deployment => "deployment".to_string(),
			Self::DeploymentReview => "deployment_review".to_string(),
			Self::DeploymentStatus => "deployment_status".to_string(),
			Self::DeployKey => "deploy_key".to_string(),
			Self::Discussion => "discussion".to_string(),
			Self::DiscussionComment => "discussion_comment".to_string(),
			Self::Fork => "fork".to_string(),
			Self::Gollum => "gollum".to_string(),
			Self::Issues => "issues".to_string(),
			Self::IssueComment => "issue_comment".to_string(),
			Self::Label => "label".to_string(),
			Self::Member => "member".to_string(),
			Self::Membership => "membership".to_string(),
			Self::MergeGroup => "merge_group".to_string(),
			Self::MergeQueueEntry => "merge_queue_entry".to_string(),
			Self::Milestone => "milestone".to_string(),
			Self::Organization => "organization".to_string(),
			Self::OrgBlock => "org_block".to_string(),
			Self::PageBuild => "page_build".to_string(),
			Self::Project => "project".to_string(),
			Self::ProjectsV2Item => "projects_v2_item".to_string(),
			Self::ProjectCard => "project_card".to_string(),
			Self::ProjectColumn => "project_column".to_string(),
			Self::Public => "public".to_string(),
			Self::PullRequest => "pull_request".to_string(),
			Self::PullRequestReview => "pull_request_review".to_string(),
			Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
			Self::PullRequestReviewThread => "pull_request_review_thread".to_string(),
			Self::Push => "push".to_string(),
			Self::RegistryPackage => "registry_package".to_string(),
			Self::Release => "release".to_string(),
			Self::Repository => "repository".to_string(),
			Self::RepositoryDispatch => "repository_dispatch".to_string(),
			Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
			Self::SecretScanningAlertLocation => "secret_scanning_alert_location".to_string(),
			Self::SecurityAndAnalysis => "security_and_analysis".to_string(),
			Self::Star => "star".to_string(),
			Self::Status => "status".to_string(),
			Self::Team => "team".to_string(),
			Self::TeamAdd => "team_add".to_string(),
			Self::Watch => "watch".to_string(),
			Self::WorkflowDispatch => "workflow_dispatch".to_string(),
			Self::WorkflowRun => "workflow_run".to_string(),
			Self::WorkflowJob => "workflow_job".to_string(),
		}
	}
}
impl std::str::FromStr for AppEventsItem {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"branch_protection_rule" => Ok(Self::BranchProtectionRule),
			"check_run" => Ok(Self::CheckRun),
			"check_suite" => Ok(Self::CheckSuite),
			"code_scanning_alert" => Ok(Self::CodeScanningAlert),
			"commit_comment" => Ok(Self::CommitComment),
			"content_reference" => Ok(Self::ContentReference),
			"create" => Ok(Self::Create),
			"delete" => Ok(Self::Delete),
			"deployment" => Ok(Self::Deployment),
			"deployment_review" => Ok(Self::DeploymentReview),
			"deployment_status" => Ok(Self::DeploymentStatus),
			"deploy_key" => Ok(Self::DeployKey),
			"discussion" => Ok(Self::Discussion),
			"discussion_comment" => Ok(Self::DiscussionComment),
			"fork" => Ok(Self::Fork),
			"gollum" => Ok(Self::Gollum),
			"issues" => Ok(Self::Issues),
			"issue_comment" => Ok(Self::IssueComment),
			"label" => Ok(Self::Label),
			"member" => Ok(Self::Member),
			"membership" => Ok(Self::Membership),
			"merge_group" => Ok(Self::MergeGroup),
			"merge_queue_entry" => Ok(Self::MergeQueueEntry),
			"milestone" => Ok(Self::Milestone),
			"organization" => Ok(Self::Organization),
			"org_block" => Ok(Self::OrgBlock),
			"page_build" => Ok(Self::PageBuild),
			"project" => Ok(Self::Project),
			"projects_v2_item" => Ok(Self::ProjectsV2Item),
			"project_card" => Ok(Self::ProjectCard),
			"project_column" => Ok(Self::ProjectColumn),
			"public" => Ok(Self::Public),
			"pull_request" => Ok(Self::PullRequest),
			"pull_request_review" => Ok(Self::PullRequestReview),
			"pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
			"pull_request_review_thread" => Ok(Self::PullRequestReviewThread),
			"push" => Ok(Self::Push),
			"registry_package" => Ok(Self::RegistryPackage),
			"release" => Ok(Self::Release),
			"repository" => Ok(Self::Repository),
			"repository_dispatch" => Ok(Self::RepositoryDispatch),
			"secret_scanning_alert" => Ok(Self::SecretScanningAlert),
			"secret_scanning_alert_location" => Ok(Self::SecretScanningAlertLocation),
			"security_and_analysis" => Ok(Self::SecurityAndAnalysis),
			"star" => Ok(Self::Star),
			"status" => Ok(Self::Status),
			"team" => Ok(Self::Team),
			"team_add" => Ok(Self::TeamAdd),
			"watch" => Ok(Self::Watch),
			"workflow_dispatch" => Ok(Self::WorkflowDispatch),
			"workflow_run" => Ok(Self::WorkflowRun),
			"workflow_job" => Ok(Self::WorkflowJob),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppEventsItem {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppEventsItem {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppEventsItem {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The set of permissions for the GitHub app
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AppPermissions {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub actions: Option<AppPermissionsActions>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub administration: Option<AppPermissionsAdministration>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub blocking: Option<AppPermissionsBlocking>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub checks: Option<AppPermissionsChecks>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub content_references: Option<AppPermissionsContentReferences>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub contents: Option<AppPermissionsContents>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployments: Option<AppPermissionsDeployments>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub discussions: Option<AppPermissionsDiscussions>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub emails: Option<AppPermissionsEmails>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub environments: Option<AppPermissionsEnvironments>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub followers: Option<AppPermissionsFollowers>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub gpg_keys: Option<AppPermissionsGpgKeys>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub interaction_limits: Option<AppPermissionsInteractionLimits>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub issues: Option<AppPermissionsIssues>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub keys: Option<AppPermissionsKeys>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub members: Option<AppPermissionsMembers>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub merge_queues: Option<AppPermissionsMergeQueues>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub metadata: Option<AppPermissionsMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_administration: Option<AppPermissionsOrganizationAdministration>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_hooks: Option<AppPermissionsOrganizationHooks>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_packages: Option<AppPermissionsOrganizationPackages>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_plan: Option<AppPermissionsOrganizationPlan>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_projects: Option<AppPermissionsOrganizationProjects>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_secrets: Option<AppPermissionsOrganizationSecrets>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_self_hosted_runners: Option<AppPermissionsOrganizationSelfHostedRunners>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_user_blocking: Option<AppPermissionsOrganizationUserBlocking>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub packages: Option<AppPermissionsPackages>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pages: Option<AppPermissionsPages>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub plan: Option<AppPermissionsPlan>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pull_requests: Option<AppPermissionsPullRequests>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository_hooks: Option<AppPermissionsRepositoryHooks>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository_projects: Option<AppPermissionsRepositoryProjects>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secret_scanning_alerts: Option<AppPermissionsSecretScanningAlerts>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secrets: Option<AppPermissionsSecrets>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub security_events: Option<AppPermissionsSecurityEvents>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub security_scanning_alert: Option<AppPermissionsSecurityScanningAlert>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub single_file: Option<AppPermissionsSingleFile>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub starring: Option<AppPermissionsStarring>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub statuses: Option<AppPermissionsStatuses>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub team_discussions: Option<AppPermissionsTeamDiscussions>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub vulnerability_alerts: Option<AppPermissionsVulnerabilityAlerts>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub watching: Option<AppPermissionsWatching>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub workflows: Option<AppPermissionsWorkflows>,
}
impl From<&AppPermissions> for AppPermissions {
	fn from(value: &AppPermissions) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsActions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsActions> for AppPermissionsActions {
	fn from(value: &AppPermissionsActions) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsActions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsActions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsActions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsActions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsActions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsAdministration {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsAdministration> for AppPermissionsAdministration {
	fn from(value: &AppPermissionsAdministration) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsAdministration {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsAdministration {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsBlocking {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsBlocking> for AppPermissionsBlocking {
	fn from(value: &AppPermissionsBlocking) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsBlocking {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsBlocking {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsChecks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsChecks> for AppPermissionsChecks {
	fn from(value: &AppPermissionsChecks) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsChecks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsChecks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContentReferences {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsContentReferences> for AppPermissionsContentReferences {
	fn from(value: &AppPermissionsContentReferences) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsContentReferences {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsContentReferences {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsContents {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsContents> for AppPermissionsContents {
	fn from(value: &AppPermissionsContents) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsContents {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsContents {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsContents {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsContents {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsContents {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDeployments {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsDeployments> for AppPermissionsDeployments {
	fn from(value: &AppPermissionsDeployments) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsDeployments {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsDeployments {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsDiscussions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsDiscussions> for AppPermissionsDiscussions {
	fn from(value: &AppPermissionsDiscussions) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsDiscussions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsDiscussions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEmails {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsEmails> for AppPermissionsEmails {
	fn from(value: &AppPermissionsEmails) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsEmails {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsEmails {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsEnvironments {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsEnvironments> for AppPermissionsEnvironments {
	fn from(value: &AppPermissionsEnvironments) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsEnvironments {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsEnvironments {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsFollowers {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsFollowers> for AppPermissionsFollowers {
	fn from(value: &AppPermissionsFollowers) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsFollowers {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsFollowers {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsFollowers {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsFollowers {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsFollowers {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsGpgKeys {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsGpgKeys> for AppPermissionsGpgKeys {
	fn from(value: &AppPermissionsGpgKeys) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsGpgKeys {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsGpgKeys {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsGpgKeys {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsGpgKeys {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsGpgKeys {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsInteractionLimits {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsInteractionLimits> for AppPermissionsInteractionLimits {
	fn from(value: &AppPermissionsInteractionLimits) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsInteractionLimits {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsInteractionLimits {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsInteractionLimits {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsInteractionLimits {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsInteractionLimits {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsIssues {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsIssues> for AppPermissionsIssues {
	fn from(value: &AppPermissionsIssues) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsIssues {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsIssues {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsKeys {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsKeys> for AppPermissionsKeys {
	fn from(value: &AppPermissionsKeys) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsKeys {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsKeys {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsKeys {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsKeys {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsKeys {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMembers {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsMembers> for AppPermissionsMembers {
	fn from(value: &AppPermissionsMembers) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsMembers {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsMembers {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMergeQueues {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsMergeQueues> for AppPermissionsMergeQueues {
	fn from(value: &AppPermissionsMergeQueues) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsMergeQueues {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsMergeQueues {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsMetadata {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsMetadata> for AppPermissionsMetadata {
	fn from(value: &AppPermissionsMetadata) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsMetadata {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsMetadata {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationAdministration {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationAdministration> for AppPermissionsOrganizationAdministration {
	fn from(value: &AppPermissionsOrganizationAdministration) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationAdministration {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationAdministration {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationHooks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationHooks> for AppPermissionsOrganizationHooks {
	fn from(value: &AppPermissionsOrganizationHooks) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationHooks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationHooks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPackages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationPackages> for AppPermissionsOrganizationPackages {
	fn from(value: &AppPermissionsOrganizationPackages) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationPackages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationPackages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationPlan {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationPlan> for AppPermissionsOrganizationPlan {
	fn from(value: &AppPermissionsOrganizationPlan) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationPlan {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationPlan {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationProjects {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationProjects> for AppPermissionsOrganizationProjects {
	fn from(value: &AppPermissionsOrganizationProjects) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationProjects {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationProjects {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSecrets {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationSecrets> for AppPermissionsOrganizationSecrets {
	fn from(value: &AppPermissionsOrganizationSecrets) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationSecrets {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationSecrets {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationSelfHostedRunners {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationSelfHostedRunners>
	for AppPermissionsOrganizationSelfHostedRunners
{
	fn from(value: &AppPermissionsOrganizationSelfHostedRunners) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationSelfHostedRunners {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationSelfHostedRunners {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsOrganizationUserBlocking {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsOrganizationUserBlocking> for AppPermissionsOrganizationUserBlocking {
	fn from(value: &AppPermissionsOrganizationUserBlocking) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsOrganizationUserBlocking {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsOrganizationUserBlocking {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPackages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsPackages> for AppPermissionsPackages {
	fn from(value: &AppPermissionsPackages) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsPackages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsPackages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsPages> for AppPermissionsPages {
	fn from(value: &AppPermissionsPages) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsPages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsPages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsPages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsPages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsPages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPlan {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsPlan> for AppPermissionsPlan {
	fn from(value: &AppPermissionsPlan) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsPlan {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsPlan {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsPlan {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsPlan {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsPlan {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsPullRequests {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsPullRequests> for AppPermissionsPullRequests {
	fn from(value: &AppPermissionsPullRequests) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsPullRequests {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsPullRequests {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryHooks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsRepositoryHooks> for AppPermissionsRepositoryHooks {
	fn from(value: &AppPermissionsRepositoryHooks) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsRepositoryHooks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsRepositoryHooks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsRepositoryProjects {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsRepositoryProjects> for AppPermissionsRepositoryProjects {
	fn from(value: &AppPermissionsRepositoryProjects) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsRepositoryProjects {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsRepositoryProjects {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecretScanningAlerts {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsSecretScanningAlerts> for AppPermissionsSecretScanningAlerts {
	fn from(value: &AppPermissionsSecretScanningAlerts) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsSecretScanningAlerts {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsSecretScanningAlerts {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecrets {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsSecrets> for AppPermissionsSecrets {
	fn from(value: &AppPermissionsSecrets) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsSecrets {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsSecrets {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityEvents {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsSecurityEvents> for AppPermissionsSecurityEvents {
	fn from(value: &AppPermissionsSecurityEvents) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsSecurityEvents {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsSecurityEvents {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSecurityScanningAlert {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsSecurityScanningAlert> for AppPermissionsSecurityScanningAlert {
	fn from(value: &AppPermissionsSecurityScanningAlert) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsSecurityScanningAlert {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsSecurityScanningAlert {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsSingleFile {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsSingleFile> for AppPermissionsSingleFile {
	fn from(value: &AppPermissionsSingleFile) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsSingleFile {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsSingleFile {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsStarring {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsStarring> for AppPermissionsStarring {
	fn from(value: &AppPermissionsStarring) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsStarring {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsStarring {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsStarring {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsStarring {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsStarring {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsStatuses {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsStatuses> for AppPermissionsStatuses {
	fn from(value: &AppPermissionsStatuses) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsStatuses {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsStatuses {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsTeamDiscussions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsTeamDiscussions> for AppPermissionsTeamDiscussions {
	fn from(value: &AppPermissionsTeamDiscussions) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsTeamDiscussions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsTeamDiscussions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsVulnerabilityAlerts {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsVulnerabilityAlerts> for AppPermissionsVulnerabilityAlerts {
	fn from(value: &AppPermissionsVulnerabilityAlerts) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsVulnerabilityAlerts {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsVulnerabilityAlerts {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsWatching {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsWatching> for AppPermissionsWatching {
	fn from(value: &AppPermissionsWatching) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsWatching {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsWatching {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsWatching {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsWatching {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsWatching {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AppPermissionsWorkflows {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&AppPermissionsWorkflows> for AppPermissionsWorkflows {
	fn from(value: &AppPermissionsWorkflows) -> Self {
		value.clone()
	}
}
impl ToString for AppPermissionsWorkflows {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for AppPermissionsWorkflows {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AppPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AppPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AppPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// How the author is associated with the repository.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AuthorAssociation {
	#[serde(rename = "COLLABORATOR")]
	Collaborator,
	#[serde(rename = "CONTRIBUTOR")]
	Contributor,
	#[serde(rename = "FIRST_TIMER")]
	FirstTimer,
	#[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
	FirstTimeContributor,
	#[serde(rename = "MANNEQUIN")]
	Mannequin,
	#[serde(rename = "MEMBER")]
	Member,
	#[serde(rename = "NONE")]
	None,
	#[serde(rename = "OWNER")]
	Owner,
}
impl From<&AuthorAssociation> for AuthorAssociation {
	fn from(value: &AuthorAssociation) -> Self {
		value.clone()
	}
}
impl ToString for AuthorAssociation {
	fn to_string(&self) -> String {
		match *self {
			Self::Collaborator => "COLLABORATOR".to_string(),
			Self::Contributor => "CONTRIBUTOR".to_string(),
			Self::FirstTimer => "FIRST_TIMER".to_string(),
			Self::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR".to_string(),
			Self::Mannequin => "MANNEQUIN".to_string(),
			Self::Member => "MEMBER".to_string(),
			Self::None => "NONE".to_string(),
			Self::Owner => "OWNER".to_string(),
		}
	}
}
impl std::str::FromStr for AuthorAssociation {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"COLLABORATOR" => Ok(Self::Collaborator),
			"CONTRIBUTOR" => Ok(Self::Contributor),
			"FIRST_TIMER" => Ok(Self::FirstTimer),
			"FIRST_TIME_CONTRIBUTOR" => Ok(Self::FirstTimeContributor),
			"MANNEQUIN" => Ok(Self::Mannequin),
			"MEMBER" => Ok(Self::Member),
			"NONE" => Ok(Self::None),
			"OWNER" => Ok(Self::Owner),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AuthorAssociation {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AuthorAssociation {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AuthorAssociation {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The status of auto merging a pull request.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AutoMerge {
	/// Commit message for the merge commit.
	pub commit_message: String,
	/// Title for the merge commit message.
	pub commit_title:   String,
	pub enabled_by:     User,
	/// The merge method to use.
	pub merge_method:   AutoMergeMergeMethod,
}
impl From<&AutoMerge> for AutoMerge {
	fn from(value: &AutoMerge) -> Self {
		value.clone()
	}
}
/// The merge method to use.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutoMergeMergeMethod {
	#[serde(rename = "merge")]
	Merge,
	#[serde(rename = "squash")]
	Squash,
	#[serde(rename = "rebase")]
	Rebase,
}
impl From<&AutoMergeMergeMethod> for AutoMergeMergeMethod {
	fn from(value: &AutoMergeMergeMethod) -> Self {
		value.clone()
	}
}
impl ToString for AutoMergeMergeMethod {
	fn to_string(&self) -> String {
		match *self {
			Self::Merge => "merge".to_string(),
			Self::Squash => "squash".to_string(),
			Self::Rebase => "rebase".to_string(),
		}
	}
}
impl std::str::FromStr for AutoMergeMergeMethod {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"merge" => Ok(Self::Merge),
			"squash" => Ok(Self::Squash),
			"rebase" => Ok(Self::Rebase),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for AutoMergeMergeMethod {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for AutoMergeMergeMethod {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for AutoMergeMergeMethod {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRule {
	pub admin_enforced: BranchProtectionRuleBoolean,
	pub allow_deletions_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub allow_force_pushes_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub authorized_actor_names: BranchProtectionRuleArray,
	pub authorized_actors_only: BranchProtectionRuleBoolean,
	pub authorized_dismissal_actors_only: BranchProtectionRuleBoolean,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub create_protected: Option<BranchProtectionRuleBoolean>,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub dismiss_stale_reviews_on_push: BranchProtectionRuleBoolean,
	pub id: i64,
	pub ignore_approvals_from_contributors: BranchProtectionRuleBoolean,
	pub linear_history_requirement_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub merge_queue_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub name: String,
	pub pull_request_reviews_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub repository_id: i64,
	pub require_code_owner_review: BranchProtectionRuleBoolean,
	pub required_approving_review_count: BranchProtectionRuleNumber,
	pub required_conversation_resolution_level: BranchProtectionRuleEnforcementLevel,
	pub required_deployments_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub required_status_checks: BranchProtectionRuleArray,
	pub required_status_checks_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub signature_requirement_enforcement_level: BranchProtectionRuleEnforcementLevel,
	pub strict_required_status_checks_policy: BranchProtectionRuleBoolean,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&BranchProtectionRule> for BranchProtectionRule {
	fn from(value: &BranchProtectionRule) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BranchProtectionRuleArray(pub Vec<String>);
impl std::ops::Deref for BranchProtectionRuleArray {
	type Target = Vec<String>;

	fn deref(&self) -> &Vec<String> {
		&self.0
	}
}
impl From<BranchProtectionRuleArray> for Vec<String> {
	fn from(value: BranchProtectionRuleArray) -> Self {
		value.0
	}
}
impl From<&BranchProtectionRuleArray> for BranchProtectionRuleArray {
	fn from(value: &BranchProtectionRuleArray) -> Self {
		value.clone()
	}
}
impl From<Vec<String>> for BranchProtectionRuleArray {
	fn from(value: Vec<String>) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BranchProtectionRuleBoolean(pub bool);
impl std::ops::Deref for BranchProtectionRuleBoolean {
	type Target = bool;

	fn deref(&self) -> &bool {
		&self.0
	}
}
impl From<BranchProtectionRuleBoolean> for bool {
	fn from(value: BranchProtectionRuleBoolean) -> Self {
		value.0
	}
}
impl From<&BranchProtectionRuleBoolean> for BranchProtectionRuleBoolean {
	fn from(value: &BranchProtectionRuleBoolean) -> Self {
		value.clone()
	}
}
impl From<bool> for BranchProtectionRuleBoolean {
	fn from(value: bool) -> Self {
		Self(value)
	}
}
impl std::str::FromStr for BranchProtectionRuleBoolean {
	type Err = <bool as std::str::FromStr>::Err;

	fn from_str(value: &str) -> Result<Self, Self::Err> {
		Ok(Self(value.parse()?))
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleBoolean {
	type Error = <bool as std::str::FromStr>::Err;

	fn try_from(value: &str) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleBoolean {
	type Error = <bool as std::str::FromStr>::Err;

	fn try_from(value: &String) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleBoolean {
	type Error = <bool as std::str::FromStr>::Err;

	fn try_from(value: String) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl ToString for BranchProtectionRuleBoolean {
	fn to_string(&self) -> String {
		self.0.to_string()
	}
}
/// Activity related to a branch protection rule. For more information, see "[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules)."
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleCreated {
	pub action:       BranchProtectionRuleCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub rule:         BranchProtectionRule,
	pub sender:       User,
}
impl From<&BranchProtectionRuleCreated> for BranchProtectionRuleCreated {
	fn from(value: &BranchProtectionRuleCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&BranchProtectionRuleCreatedAction> for BranchProtectionRuleCreatedAction {
	fn from(value: &BranchProtectionRuleCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for BranchProtectionRuleCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for BranchProtectionRuleCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Activity related to a branch protection rule. For more information, see "[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules)."
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleDeleted {
	pub action:       BranchProtectionRuleDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub rule:         BranchProtectionRule,
	pub sender:       User,
}
impl From<&BranchProtectionRuleDeleted> for BranchProtectionRuleDeleted {
	fn from(value: &BranchProtectionRuleDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&BranchProtectionRuleDeletedAction> for BranchProtectionRuleDeletedAction {
	fn from(value: &BranchProtectionRuleDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for BranchProtectionRuleDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for BranchProtectionRuleDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Activity related to a branch protection rule. For more information, see "[About branch protection rules](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-rules)."
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEdited {
	pub action:       BranchProtectionRuleEditedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<BranchProtectionRuleEditedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub rule:         BranchProtectionRule,
	pub sender:       User,
}
impl From<&BranchProtectionRuleEdited> for BranchProtectionRuleEdited {
	fn from(value: &BranchProtectionRuleEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&BranchProtectionRuleEditedAction> for BranchProtectionRuleEditedAction {
	fn from(value: &BranchProtectionRuleEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for BranchProtectionRuleEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for BranchProtectionRuleEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// If the action was `edited`, the changes to the rule.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub admin_enforced: Option<BranchProtectionRuleEditedChangesAdminEnforced>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub allow_deletions_enforcement_level:
		Option<BranchProtectionRuleEditedChangesAllowDeletionsEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub allow_force_pushes_enforcement_level:
		Option<BranchProtectionRuleEditedChangesAllowForcePushesEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub authorized_actor_names: Option<BranchProtectionRuleEditedChangesAuthorizedActorNames>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub authorized_actors_only: Option<BranchProtectionRuleEditedChangesAuthorizedActorsOnly>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub authorized_dismissal_actors_only:
		Option<BranchProtectionRuleEditedChangesAuthorizedDismissalActorsOnly>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub dismiss_stale_reviews_on_push:
		Option<BranchProtectionRuleEditedChangesDismissStaleReviewsOnPush>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub linear_history_requirement_enforcement_level:
		Option<BranchProtectionRuleEditedChangesLinearHistoryRequirementEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pull_request_reviews_enforcement_level:
		Option<BranchProtectionRuleEditedChangesPullRequestReviewsEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub require_code_owner_review: Option<BranchProtectionRuleEditedChangesRequireCodeOwnerReview>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub required_approving_review_count:
		Option<BranchProtectionRuleEditedChangesRequiredApprovingReviewCount>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub required_conversation_resolution_level:
		Option<BranchProtectionRuleEditedChangesRequiredConversationResolutionLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub required_deployments_enforcement_level:
		Option<BranchProtectionRuleEditedChangesRequiredDeploymentsEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub required_status_checks: Option<BranchProtectionRuleEditedChangesRequiredStatusChecks>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub required_status_checks_enforcement_level:
		Option<BranchProtectionRuleEditedChangesRequiredStatusChecksEnforcementLevel>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub signature_requirement_enforcement_level:
		Option<BranchProtectionRuleEditedChangesSignatureRequirementEnforcementLevel>,
}
impl From<&BranchProtectionRuleEditedChanges> for BranchProtectionRuleEditedChanges {
	fn from(value: &BranchProtectionRuleEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAdminEnforced {
	pub from: BranchProtectionRuleBoolean,
}
impl From<&BranchProtectionRuleEditedChangesAdminEnforced>
	for BranchProtectionRuleEditedChangesAdminEnforced
{
	fn from(value: &BranchProtectionRuleEditedChangesAdminEnforced) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAllowDeletionsEnforcementLevel {
	pub from: Option<BranchProtectionRuleEnforcementLevel>,
}
impl From<&BranchProtectionRuleEditedChangesAllowDeletionsEnforcementLevel>
	for BranchProtectionRuleEditedChangesAllowDeletionsEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesAllowDeletionsEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAllowForcePushesEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesAllowForcePushesEnforcementLevel>
	for BranchProtectionRuleEditedChangesAllowForcePushesEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesAllowForcePushesEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorNames {
	pub from: BranchProtectionRuleArray,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorNames>
	for BranchProtectionRuleEditedChangesAuthorizedActorNames
{
	fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorNames) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedActorsOnly {
	pub from: BranchProtectionRuleBoolean,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedActorsOnly>
	for BranchProtectionRuleEditedChangesAuthorizedActorsOnly
{
	fn from(value: &BranchProtectionRuleEditedChangesAuthorizedActorsOnly) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesAuthorizedDismissalActorsOnly {
	pub from: Option<BranchProtectionRuleBoolean>,
}
impl From<&BranchProtectionRuleEditedChangesAuthorizedDismissalActorsOnly>
	for BranchProtectionRuleEditedChangesAuthorizedDismissalActorsOnly
{
	fn from(value: &BranchProtectionRuleEditedChangesAuthorizedDismissalActorsOnly) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesDismissStaleReviewsOnPush {
	pub from: BranchProtectionRuleBoolean,
}
impl From<&BranchProtectionRuleEditedChangesDismissStaleReviewsOnPush>
	for BranchProtectionRuleEditedChangesDismissStaleReviewsOnPush
{
	fn from(value: &BranchProtectionRuleEditedChangesDismissStaleReviewsOnPush) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesLinearHistoryRequirementEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesLinearHistoryRequirementEnforcementLevel>
	for BranchProtectionRuleEditedChangesLinearHistoryRequirementEnforcementLevel
{
	fn from(
		value: &BranchProtectionRuleEditedChangesLinearHistoryRequirementEnforcementLevel,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesPullRequestReviewsEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesPullRequestReviewsEnforcementLevel>
	for BranchProtectionRuleEditedChangesPullRequestReviewsEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesPullRequestReviewsEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequireCodeOwnerReview {
	pub from: BranchProtectionRuleBoolean,
}
impl From<&BranchProtectionRuleEditedChangesRequireCodeOwnerReview>
	for BranchProtectionRuleEditedChangesRequireCodeOwnerReview
{
	fn from(value: &BranchProtectionRuleEditedChangesRequireCodeOwnerReview) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequiredApprovingReviewCount {
	pub from: BranchProtectionRuleNumber,
}
impl From<&BranchProtectionRuleEditedChangesRequiredApprovingReviewCount>
	for BranchProtectionRuleEditedChangesRequiredApprovingReviewCount
{
	fn from(value: &BranchProtectionRuleEditedChangesRequiredApprovingReviewCount) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequiredConversationResolutionLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesRequiredConversationResolutionLevel>
	for BranchProtectionRuleEditedChangesRequiredConversationResolutionLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesRequiredConversationResolutionLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequiredDeploymentsEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesRequiredDeploymentsEnforcementLevel>
	for BranchProtectionRuleEditedChangesRequiredDeploymentsEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesRequiredDeploymentsEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequiredStatusChecks {
	pub from: BranchProtectionRuleArray,
}
impl From<&BranchProtectionRuleEditedChangesRequiredStatusChecks>
	for BranchProtectionRuleEditedChangesRequiredStatusChecks
{
	fn from(value: &BranchProtectionRuleEditedChangesRequiredStatusChecks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesRequiredStatusChecksEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesRequiredStatusChecksEnforcementLevel>
	for BranchProtectionRuleEditedChangesRequiredStatusChecksEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesRequiredStatusChecksEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BranchProtectionRuleEditedChangesSignatureRequirementEnforcementLevel {
	pub from: BranchProtectionRuleEnforcementLevel,
}
impl From<&BranchProtectionRuleEditedChangesSignatureRequirementEnforcementLevel>
	for BranchProtectionRuleEditedChangesSignatureRequirementEnforcementLevel
{
	fn from(value: &BranchProtectionRuleEditedChangesSignatureRequirementEnforcementLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BranchProtectionRuleEnforcementLevel {
	#[serde(rename = "off")]
	Off,
	#[serde(rename = "non_admins")]
	NonAdmins,
	#[serde(rename = "everyone")]
	Everyone,
}
impl From<&BranchProtectionRuleEnforcementLevel> for BranchProtectionRuleEnforcementLevel {
	fn from(value: &BranchProtectionRuleEnforcementLevel) -> Self {
		value.clone()
	}
}
impl ToString for BranchProtectionRuleEnforcementLevel {
	fn to_string(&self) -> String {
		match *self {
			Self::Off => "off".to_string(),
			Self::NonAdmins => "non_admins".to_string(),
			Self::Everyone => "everyone".to_string(),
		}
	}
}
impl std::str::FromStr for BranchProtectionRuleEnforcementLevel {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"off" => Ok(Self::Off),
			"non_admins" => Ok(Self::NonAdmins),
			"everyone" => Ok(Self::Everyone),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleEnforcementLevel {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleEnforcementLevel {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleEnforcementLevel {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BranchProtectionRuleEvent {
	Created(BranchProtectionRuleCreated),
	Deleted(BranchProtectionRuleDeleted),
	Edited(BranchProtectionRuleEdited),
}
impl From<&BranchProtectionRuleEvent> for BranchProtectionRuleEvent {
	fn from(value: &BranchProtectionRuleEvent) -> Self {
		value.clone()
	}
}
impl From<BranchProtectionRuleCreated> for BranchProtectionRuleEvent {
	fn from(value: BranchProtectionRuleCreated) -> Self {
		Self::Created(value)
	}
}
impl From<BranchProtectionRuleDeleted> for BranchProtectionRuleEvent {
	fn from(value: BranchProtectionRuleDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<BranchProtectionRuleEdited> for BranchProtectionRuleEvent {
	fn from(value: BranchProtectionRuleEdited) -> Self {
		Self::Edited(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BranchProtectionRuleNumber(pub i64);
impl std::ops::Deref for BranchProtectionRuleNumber {
	type Target = i64;

	fn deref(&self) -> &i64 {
		&self.0
	}
}
impl From<BranchProtectionRuleNumber> for i64 {
	fn from(value: BranchProtectionRuleNumber) -> Self {
		value.0
	}
}
impl From<&BranchProtectionRuleNumber> for BranchProtectionRuleNumber {
	fn from(value: &BranchProtectionRuleNumber) -> Self {
		value.clone()
	}
}
impl From<i64> for BranchProtectionRuleNumber {
	fn from(value: i64) -> Self {
		Self(value)
	}
}
impl std::str::FromStr for BranchProtectionRuleNumber {
	type Err = <i64 as std::str::FromStr>::Err;

	fn from_str(value: &str) -> Result<Self, Self::Err> {
		Ok(Self(value.parse()?))
	}
}
impl std::convert::TryFrom<&str> for BranchProtectionRuleNumber {
	type Error = <i64 as std::str::FromStr>::Err;

	fn try_from(value: &str) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for BranchProtectionRuleNumber {
	type Error = <i64 as std::str::FromStr>::Err;

	fn try_from(value: &String) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for BranchProtectionRuleNumber {
	type Error = <i64 as std::str::FromStr>::Err;

	fn try_from(value: String) -> Result<Self, Self::Error> {
		value.parse()
	}
}
impl ToString for BranchProtectionRuleNumber {
	fn to_string(&self) -> String {
		self.0.to_string()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompleted {
	pub action:           CheckRunCompletedAction,
	pub check_run:        CheckRunCompletedCheckRun,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub repository:       Repository,
	/// The action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub requested_action: Option<CheckRunCompletedRequestedAction>,
	pub sender:           User,
}
impl From<&CheckRunCompleted> for CheckRunCompleted {
	fn from(value: &CheckRunCompleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedAction {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunCompletedAction> for CheckRunCompletedAction {
	fn from(value: &CheckRunCompletedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCompletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCompletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRun {
	pub app:           App,
	pub check_suite:   CheckRunCompletedCheckRunCheckSuite,
	/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub completed_at:  chrono::DateTime<chrono::offset::Utc>,
	/// The result of the completed check run. Can be one of `success`,
	/// `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or
	/// `stale`. This value will be `null` until the check run has completed.
	pub conclusion:    Option<CheckRunCompletedCheckRunConclusion>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub details_url:   Option<String>,
	pub external_id:   String,
	/// The SHA of the commit that is being checked.
	pub head_sha:      String,
	pub html_url:      String,
	/// The id of the check.
	pub id:            i64,
	/// The name of the check run.
	pub name:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	pub output:        CheckRunCompletedCheckRunOutput,
	pub pull_requests: Vec<CheckRunPullRequest>,
	/// The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub started_at:    chrono::DateTime<chrono::offset::Utc>,
	/// The current status of the check run. Can be `queued`, `in_progress`, or
	/// `completed`.
	pub status:        CheckRunCompletedCheckRunStatus,
	pub url:           String,
}
impl From<&CheckRunCompletedCheckRun> for CheckRunCompletedCheckRun {
	fn from(value: &CheckRunCompletedCheckRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunCheckSuite {
	pub after:         Option<String>,
	pub app:           App,
	pub before:        Option<String>,
	pub conclusion:    Option<CheckRunCompletedCheckRunCheckSuiteConclusion>,
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	pub head_branch:   Option<String>,
	/// The SHA of the head commit that is being checked.
	pub head_sha:      String,
	/// The id of the check suite that this check run is part of.
	pub id:            i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_branch`.  
	/// **Note:**
	///
	/// * The `head_sha` of the check suite can differ from the `sha` of the
	///   pull request if subsequent pushes are made into the PR.
	/// * When the check suite's `head_branch` is in a forked repository it will
	///   be `null` and the `pull_requests` array will be empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	pub status:        CheckRunCompletedCheckRunCheckSuiteStatus,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
	pub url:           String,
}
impl From<&CheckRunCompletedCheckRunCheckSuite> for CheckRunCompletedCheckRunCheckSuite {
	fn from(value: &CheckRunCompletedCheckRunCheckSuite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteConclusion>
	for CheckRunCompletedCheckRunCheckSuiteConclusion
{
	fn from(value: &CheckRunCompletedCheckRunCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunCheckSuiteStatus {
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
}
impl From<&CheckRunCompletedCheckRunCheckSuiteStatus>
	for CheckRunCompletedCheckRunCheckSuiteStatus
{
	fn from(value: &CheckRunCompletedCheckRunCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCompletedCheckRunCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCompletedCheckRunCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The result of the completed check run. Can be one of `success`, `failure`,
/// `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This
/// value will be `null` until the check run has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&CheckRunCompletedCheckRunConclusion> for CheckRunCompletedCheckRunConclusion {
	fn from(value: &CheckRunCompletedCheckRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCompletedCheckRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCompletedCheckRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedCheckRunOutput {
	pub annotations_count: i64,
	pub annotations_url:   String,
	pub summary:           Option<String>,
	pub text:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title:             Option<String>,
}
impl From<&CheckRunCompletedCheckRunOutput> for CheckRunCompletedCheckRunOutput {
	fn from(value: &CheckRunCompletedCheckRunOutput) -> Self {
		value.clone()
	}
}
/// The current status of the check run. Can be `queued`, `in_progress`, or
/// `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCompletedCheckRunStatus {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunCompletedCheckRunStatus> for CheckRunCompletedCheckRunStatus {
	fn from(value: &CheckRunCompletedCheckRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCompletedCheckRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCompletedCheckRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCompletedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCompletedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCompletedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The action requested by the user.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCompletedRequestedAction {
	/// The integrator reference of the action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub identifier: Option<String>,
}
impl From<&CheckRunCompletedRequestedAction> for CheckRunCompletedRequestedAction {
	fn from(value: &CheckRunCompletedRequestedAction) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreated {
	pub action:           CheckRunCreatedAction,
	pub check_run:        CheckRunCreatedCheckRun,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub repository:       Repository,
	/// The action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub requested_action: Option<CheckRunCreatedRequestedAction>,
	pub sender:           User,
}
impl From<&CheckRunCreated> for CheckRunCreated {
	fn from(value: &CheckRunCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&CheckRunCreatedAction> for CheckRunCreatedAction {
	fn from(value: &CheckRunCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRun {
	pub app:           App,
	pub check_suite:   CheckRunCreatedCheckRunCheckSuite,
	/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub completed_at:  Option<chrono::DateTime<chrono::offset::Utc>>,
	/// The result of the completed check run. Can be one of `success`,
	/// `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or
	/// `stale`. This value will be `null` until the check run has completed.
	pub conclusion:    Option<CheckRunCreatedCheckRunConclusion>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub details_url:   Option<String>,
	pub external_id:   String,
	/// The SHA of the commit that is being checked.
	pub head_sha:      String,
	pub html_url:      String,
	/// The id of the check.
	pub id:            i64,
	/// The name of the check run.
	pub name:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	pub output:        CheckRunCreatedCheckRunOutput,
	pub pull_requests: Vec<CheckRunPullRequest>,
	/// The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub started_at:    chrono::DateTime<chrono::offset::Utc>,
	/// The current status of the check run. Can be `queued`, `in_progress`, or
	/// `completed`.
	pub status:        CheckRunCreatedCheckRunStatus,
	pub url:           String,
}
impl From<&CheckRunCreatedCheckRun> for CheckRunCreatedCheckRun {
	fn from(value: &CheckRunCreatedCheckRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunCheckSuite {
	pub after:         Option<String>,
	pub app:           App,
	pub before:        Option<String>,
	pub conclusion:    Option<CheckRunCreatedCheckRunCheckSuiteConclusion>,
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	pub head_branch:   Option<String>,
	/// The SHA of the head commit that is being checked.
	pub head_sha:      String,
	/// The id of the check suite that this check run is part of.
	pub id:            i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_branch`.  
	/// **Note:**
	///
	/// * The `head_sha` of the check suite can differ from the `sha` of the
	///   pull request if subsequent pushes are made into the PR.
	/// * When the check suite's `head_branch` is in a forked repository it will
	///   be `null` and the `pull_requests` array will be empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	pub status:        CheckRunCreatedCheckRunCheckSuiteStatus,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
	pub url:           String,
}
impl From<&CheckRunCreatedCheckRunCheckSuite> for CheckRunCreatedCheckRunCheckSuite {
	fn from(value: &CheckRunCreatedCheckRunCheckSuite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteConclusion>
	for CheckRunCreatedCheckRunCheckSuiteConclusion
{
	fn from(value: &CheckRunCreatedCheckRunCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunCheckSuiteStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunCreatedCheckRunCheckSuiteStatus> for CheckRunCreatedCheckRunCheckSuiteStatus {
	fn from(value: &CheckRunCreatedCheckRunCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCreatedCheckRunCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCreatedCheckRunCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The result of the completed check run. Can be one of `success`, `failure`,
/// `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This
/// value will be `null` until the check run has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&CheckRunCreatedCheckRunConclusion> for CheckRunCreatedCheckRunConclusion {
	fn from(value: &CheckRunCreatedCheckRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCreatedCheckRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCreatedCheckRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedCheckRunOutput {
	pub annotations_count: i64,
	pub annotations_url:   String,
	pub summary:           Option<String>,
	pub text:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title:             Option<String>,
}
impl From<&CheckRunCreatedCheckRunOutput> for CheckRunCreatedCheckRunOutput {
	fn from(value: &CheckRunCreatedCheckRunOutput) -> Self {
		value.clone()
	}
}
/// The current status of the check run. Can be `queued`, `in_progress`, or
/// `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunCreatedCheckRunStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "waiting")]
	Waiting,
}
impl From<&CheckRunCreatedCheckRunStatus> for CheckRunCreatedCheckRunStatus {
	fn from(value: &CheckRunCreatedCheckRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunCreatedCheckRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Waiting => "waiting".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunCreatedCheckRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"waiting" => Ok(Self::Waiting),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The action requested by the user.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunCreatedRequestedAction {
	/// The integrator reference of the action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub identifier: Option<String>,
}
impl From<&CheckRunCreatedRequestedAction> for CheckRunCreatedRequestedAction {
	fn from(value: &CheckRunCreatedRequestedAction) -> Self {
		value.clone()
	}
}
/// A deployment to a repository environment. This will only be populated if the
/// check run was created by a GitHub Actions workflow job that references an
/// environment.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunDeployment {
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	pub description:          Option<String>,
	pub environment:          String,
	pub id:                   i64,
	pub node_id:              String,
	pub original_environment: String,
	pub repository_url:       String,
	pub statuses_url:         String,
	pub task:                 String,
	pub updated_at:           chrono::DateTime<chrono::offset::Utc>,
	pub url:                  String,
}
impl From<&CheckRunDeployment> for CheckRunDeployment {
	fn from(value: &CheckRunDeployment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckRunEvent {
	Completed(CheckRunCompleted),
	Created(CheckRunCreated),
	RequestedAction(CheckRunRequestedAction),
	Rerequested(CheckRunRerequested),
}
impl From<&CheckRunEvent> for CheckRunEvent {
	fn from(value: &CheckRunEvent) -> Self {
		value.clone()
	}
}
impl From<CheckRunCompleted> for CheckRunEvent {
	fn from(value: CheckRunCompleted) -> Self {
		Self::Completed(value)
	}
}
impl From<CheckRunCreated> for CheckRunEvent {
	fn from(value: CheckRunCreated) -> Self {
		Self::Created(value)
	}
}
impl From<CheckRunRequestedAction> for CheckRunEvent {
	fn from(value: CheckRunRequestedAction) -> Self {
		Self::RequestedAction(value)
	}
}
impl From<CheckRunRerequested> for CheckRunEvent {
	fn from(value: CheckRunRerequested) -> Self {
		Self::Rerequested(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequest {
	pub base:   CheckRunPullRequestBase,
	pub head:   CheckRunPullRequestHead,
	pub id:     i64,
	pub number: i64,
	pub url:    String,
}
impl From<&CheckRunPullRequest> for CheckRunPullRequest {
	fn from(value: &CheckRunPullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestBase {
	#[serde(rename = "ref")]
	pub ref_: String,
	pub repo: RepoRef,
	pub sha:  String,
}
impl From<&CheckRunPullRequestBase> for CheckRunPullRequestBase {
	fn from(value: &CheckRunPullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunPullRequestHead {
	#[serde(rename = "ref")]
	pub ref_: String,
	pub repo: RepoRef,
	pub sha:  String,
}
impl From<&CheckRunPullRequestHead> for CheckRunPullRequestHead {
	fn from(value: &CheckRunPullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedAction {
	pub action:           CheckRunRequestedActionAction,
	pub check_run:        CheckRunRequestedActionCheckRun,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub repository:       Repository,
	pub requested_action: CheckRunRequestedActionRequestedAction,
	pub sender:           User,
}
impl From<&CheckRunRequestedAction> for CheckRunRequestedAction {
	fn from(value: &CheckRunRequestedAction) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionAction {
	#[serde(rename = "requested_action")]
	RequestedAction,
}
impl From<&CheckRunRequestedActionAction> for CheckRunRequestedActionAction {
	fn from(value: &CheckRunRequestedActionAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRequestedActionAction {
	fn to_string(&self) -> String {
		match *self {
			Self::RequestedAction => "requested_action".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRequestedActionAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested_action" => Ok(Self::RequestedAction),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRun {
	pub app:           App,
	pub check_suite:   CheckRunRequestedActionCheckRunCheckSuite,
	/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub completed_at:  Option<chrono::DateTime<chrono::offset::Utc>>,
	/// The result of the completed check run. Can be one of `success`,
	/// `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or
	/// `stale`. This value will be `null` until the check run has completed.
	pub conclusion:    Option<CheckRunRequestedActionCheckRunConclusion>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub details_url:   Option<String>,
	pub external_id:   String,
	/// The SHA of the commit that is being checked.
	pub head_sha:      String,
	pub html_url:      String,
	/// The id of the check.
	pub id:            i64,
	/// The name of the check run.
	pub name:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	pub output:        CheckRunRequestedActionCheckRunOutput,
	pub pull_requests: Vec<CheckRunPullRequest>,
	/// The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub started_at:    chrono::DateTime<chrono::offset::Utc>,
	/// The current status of the check run. Can be `queued`, `in_progress`, or
	/// `completed`.
	pub status:        CheckRunRequestedActionCheckRunStatus,
	pub url:           String,
}
impl From<&CheckRunRequestedActionCheckRun> for CheckRunRequestedActionCheckRun {
	fn from(value: &CheckRunRequestedActionCheckRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunCheckSuite {
	pub after:         Option<String>,
	pub app:           App,
	pub before:        Option<String>,
	pub conclusion:    Option<CheckRunRequestedActionCheckRunCheckSuiteConclusion>,
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	pub head_branch:   Option<String>,
	/// The SHA of the head commit that is being checked.
	pub head_sha:      String,
	/// The id of the check suite that this check run is part of.
	pub id:            i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_branch`.  
	/// **Note:**
	///
	/// * The `head_sha` of the check suite can differ from the `sha` of the
	///   pull request if subsequent pushes are made into the PR.
	/// * When the check suite's `head_branch` is in a forked repository it will
	///   be `null` and the `pull_requests` array will be empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	pub status:        CheckRunRequestedActionCheckRunCheckSuiteStatus,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
	pub url:           String,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuite>
	for CheckRunRequestedActionCheckRunCheckSuite
{
	fn from(value: &CheckRunRequestedActionCheckRunCheckSuite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteConclusion>
	for CheckRunRequestedActionCheckRunCheckSuiteConclusion
{
	fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunCheckSuiteStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "waiting")]
	Waiting,
}
impl From<&CheckRunRequestedActionCheckRunCheckSuiteStatus>
	for CheckRunRequestedActionCheckRunCheckSuiteStatus
{
	fn from(value: &CheckRunRequestedActionCheckRunCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRequestedActionCheckRunCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Waiting => "waiting".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"waiting" => Ok(Self::Waiting),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The result of the completed check run. Can be one of `success`, `failure`,
/// `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This
/// value will be `null` until the check run has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&CheckRunRequestedActionCheckRunConclusion>
	for CheckRunRequestedActionCheckRunConclusion
{
	fn from(value: &CheckRunRequestedActionCheckRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRequestedActionCheckRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionCheckRunOutput {
	pub annotations_count: i64,
	pub annotations_url:   String,
	pub summary:           Option<String>,
	pub text:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title:             Option<String>,
}
impl From<&CheckRunRequestedActionCheckRunOutput> for CheckRunRequestedActionCheckRunOutput {
	fn from(value: &CheckRunRequestedActionCheckRunOutput) -> Self {
		value.clone()
	}
}
/// The current status of the check run. Can be `queued`, `in_progress`, or
/// `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRequestedActionCheckRunStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunRequestedActionCheckRunStatus> for CheckRunRequestedActionCheckRunStatus {
	fn from(value: &CheckRunRequestedActionCheckRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRequestedActionCheckRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRequestedActionCheckRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRequestedActionCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRequestedActionCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRequestedActionCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The action requested by the user.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRequestedActionRequestedAction {
	/// The integrator reference of the action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub identifier: Option<String>,
}
impl From<&CheckRunRequestedActionRequestedAction> for CheckRunRequestedActionRequestedAction {
	fn from(value: &CheckRunRequestedActionRequestedAction) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequested {
	pub action:           CheckRunRerequestedAction,
	pub check_run:        CheckRunRerequestedCheckRun,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub repository:       Repository,
	/// The action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub requested_action: Option<CheckRunRerequestedRequestedAction>,
	pub sender:           User,
}
impl From<&CheckRunRerequested> for CheckRunRerequested {
	fn from(value: &CheckRunRerequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedAction {
	#[serde(rename = "rerequested")]
	Rerequested,
}
impl From<&CheckRunRerequestedAction> for CheckRunRerequestedAction {
	fn from(value: &CheckRunRerequestedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRerequestedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Rerequested => "rerequested".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRerequestedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"rerequested" => Ok(Self::Rerequested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRerequestedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRun {
	pub app:           App,
	pub check_suite:   CheckRunRerequestedCheckRunCheckSuite,
	/// The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub completed_at:  chrono::DateTime<chrono::offset::Utc>,
	/// The result of the completed check run. Can be one of `success`,
	/// `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or
	/// `stale`. This value will be `null` until the check run has `completed`.
	pub conclusion:    Option<CheckRunRerequestedCheckRunConclusion>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub details_url:   Option<String>,
	pub external_id:   String,
	/// The SHA of the commit that is being checked.
	pub head_sha:      String,
	pub html_url:      String,
	/// The id of the check.
	pub id:            i64,
	/// The name of the check.
	pub name:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	pub output:        CheckRunRerequestedCheckRunOutput,
	pub pull_requests: Vec<CheckRunPullRequest>,
	/// The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub started_at:    chrono::DateTime<chrono::offset::Utc>,
	/// The phase of the lifecycle that the check is currently in.
	pub status:        CheckRunRerequestedCheckRunStatus,
	pub url:           String,
}
impl From<&CheckRunRerequestedCheckRun> for CheckRunRerequestedCheckRun {
	fn from(value: &CheckRunRerequestedCheckRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunCheckSuite {
	pub after:         Option<String>,
	pub app:           App,
	pub before:        Option<String>,
	pub conclusion:    CheckRunRerequestedCheckRunCheckSuiteConclusion,
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployment:    Option<CheckRunDeployment>,
	pub head_branch:   Option<String>,
	/// The SHA of the head commit that is being checked.
	pub head_sha:      String,
	/// The id of the check suite that this check run is part of.
	pub id:            i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:       Option<String>,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_branch`.  
	/// **Note:**
	///
	/// * The `head_sha` of the check suite can differ from the `sha` of the
	///   pull request if subsequent pushes are made into the PR.
	/// * When the check suite's `head_branch` is in a forked repository it will
	///   be `null` and the `pull_requests` array will be empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	pub status:        CheckRunRerequestedCheckRunCheckSuiteStatus,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
	pub url:           String,
}
impl From<&CheckRunRerequestedCheckRunCheckSuite> for CheckRunRerequestedCheckRunCheckSuite {
	fn from(value: &CheckRunRerequestedCheckRunCheckSuite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteConclusion>
	for CheckRunRerequestedCheckRunCheckSuiteConclusion
{
	fn from(value: &CheckRunRerequestedCheckRunCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunCheckSuiteStatus {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunRerequestedCheckRunCheckSuiteStatus>
	for CheckRunRerequestedCheckRunCheckSuiteStatus
{
	fn from(value: &CheckRunRerequestedCheckRunCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRerequestedCheckRunCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRerequestedCheckRunCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The result of the completed check run. Can be one of `success`, `failure`,
/// `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This
/// value will be `null` until the check run has `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&CheckRunRerequestedCheckRunConclusion> for CheckRunRerequestedCheckRunConclusion {
	fn from(value: &CheckRunRerequestedCheckRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRerequestedCheckRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRerequestedCheckRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedCheckRunOutput {
	pub annotations_count: i64,
	pub annotations_url:   String,
	pub summary:           Option<String>,
	pub text:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title:             Option<String>,
}
impl From<&CheckRunRerequestedCheckRunOutput> for CheckRunRerequestedCheckRunOutput {
	fn from(value: &CheckRunRerequestedCheckRunOutput) -> Self {
		value.clone()
	}
}
/// The phase of the lifecycle that the check is currently in.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckRunRerequestedCheckRunStatus {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckRunRerequestedCheckRunStatus> for CheckRunRerequestedCheckRunStatus {
	fn from(value: &CheckRunRerequestedCheckRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckRunRerequestedCheckRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckRunRerequestedCheckRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckRunRerequestedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckRunRerequestedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckRunRerequestedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The action requested by the user.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckRunRerequestedRequestedAction {
	/// The integrator reference of the action requested by the user.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub identifier: Option<String>,
}
impl From<&CheckRunRerequestedRequestedAction> for CheckRunRerequestedRequestedAction {
	fn from(value: &CheckRunRerequestedRequestedAction) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompleted {
	pub action:       CheckSuiteCompletedAction,
	pub check_suite:  CheckSuiteCompletedCheckSuite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CheckSuiteCompleted> for CheckSuiteCompleted {
	fn from(value: &CheckSuiteCompleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedAction {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&CheckSuiteCompletedAction> for CheckSuiteCompletedAction {
	fn from(value: &CheckSuiteCompletedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteCompletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteCompletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteCompletedCheckSuite {
	pub after: Option<String>,
	pub app: App,
	pub before: Option<String>,
	pub check_runs_url: String,
	/// The summary conclusion for all check runs that are part of the check
	/// suite. Can be one of `success`, `failure`, `neutral`, `cancelled`,
	/// `timed_out`, `action_required` or `stale`. This value will be `null`
	/// until the check run has `completed`.
	pub conclusion: Option<CheckSuiteCompletedCheckSuiteConclusion>,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	/// The head branch name the changes are on.
	pub head_branch: Option<String>,
	pub head_commit: CommitSimple,
	/// The SHA of the head commit that is being checked.
	pub head_sha: String,
	pub id: i64,
	pub latest_check_runs_count: i64,
	pub node_id: String,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_sha` and
	/// `head_branch`. When the check suite's `head_branch` is in a forked
	/// repository it will be `null` and the `pull_requests` array will be
	/// empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub rerequestable: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub runs_rerequestable: Option<bool>,
	/// The summary status for all check runs that are part of the check suite.
	/// Can be `queued`, `requested`, `in_progress`, or `completed`.
	pub status: Option<CheckSuiteCompletedCheckSuiteStatus>,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// URL that points to the check suite API resource.
	pub url: String,
}
impl From<&CheckSuiteCompletedCheckSuite> for CheckSuiteCompletedCheckSuite {
	fn from(value: &CheckSuiteCompletedCheckSuite) -> Self {
		value.clone()
	}
}
/// The summary conclusion for all check runs that are part of the check suite.
/// Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`,
/// `action_required` or `stale`. This value will be `null` until the check run
/// has `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckSuiteCompletedCheckSuiteConclusion> for CheckSuiteCompletedCheckSuiteConclusion {
	fn from(value: &CheckSuiteCompletedCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteCompletedCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The summary status for all check runs that are part of the check suite. Can
/// be `queued`, `requested`, `in_progress`, or `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteCompletedCheckSuiteStatus {
	#[serde(rename = "requested")]
	Requested,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
}
impl From<&CheckSuiteCompletedCheckSuiteStatus> for CheckSuiteCompletedCheckSuiteStatus {
	fn from(value: &CheckSuiteCompletedCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteCompletedCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteCompletedCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteCompletedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteCompletedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteCompletedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CheckSuiteEvent {
	Completed(CheckSuiteCompleted),
	Requested(CheckSuiteRequested),
	Rerequested(CheckSuiteRerequested),
}
impl From<&CheckSuiteEvent> for CheckSuiteEvent {
	fn from(value: &CheckSuiteEvent) -> Self {
		value.clone()
	}
}
impl From<CheckSuiteCompleted> for CheckSuiteEvent {
	fn from(value: CheckSuiteCompleted) -> Self {
		Self::Completed(value)
	}
}
impl From<CheckSuiteRequested> for CheckSuiteEvent {
	fn from(value: CheckSuiteRequested) -> Self {
		Self::Requested(value)
	}
}
impl From<CheckSuiteRerequested> for CheckSuiteEvent {
	fn from(value: CheckSuiteRerequested) -> Self {
		Self::Rerequested(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequested {
	pub action:       CheckSuiteRequestedAction,
	pub check_suite:  CheckSuiteRequestedCheckSuite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CheckSuiteRequested> for CheckSuiteRequested {
	fn from(value: &CheckSuiteRequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedAction {
	#[serde(rename = "requested")]
	Requested,
}
impl From<&CheckSuiteRequestedAction> for CheckSuiteRequestedAction {
	fn from(value: &CheckSuiteRequestedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRequestedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRequestedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRequestedCheckSuite {
	pub after: Option<String>,
	pub app: App,
	pub before: Option<String>,
	pub check_runs_url: String,
	/// The summary conclusion for all check runs that are part of the check
	/// suite. Can be one of `success`, `failure`,` neutral`, `cancelled`,
	/// `timed_out`, `action_required` or `stale`. This value will be `null`
	/// until the check run has completed.
	pub conclusion: Option<CheckSuiteRequestedCheckSuiteConclusion>,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	/// The head branch name the changes are on.
	pub head_branch: Option<String>,
	pub head_commit: CommitSimple,
	/// The SHA of the head commit that is being checked.
	pub head_sha: String,
	pub id: i64,
	pub latest_check_runs_count: i64,
	pub node_id: String,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_sha` and
	/// `head_branch`. When the check suite's `head_branch` is in a forked
	/// repository it will be `null` and the `pull_requests` array will be
	/// empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub rerequestable: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub runs_rerequestable: Option<bool>,
	/// The summary status for all check runs that are part of the check suite.
	/// Can be `queued`, `requested`, `in_progress`, or `completed`.
	pub status: Option<CheckSuiteRequestedCheckSuiteStatus>,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// URL that points to the check suite API resource.
	pub url: String,
}
impl From<&CheckSuiteRequestedCheckSuite> for CheckSuiteRequestedCheckSuite {
	fn from(value: &CheckSuiteRequestedCheckSuite) -> Self {
		value.clone()
	}
}
/// The summary conclusion for all check runs that are part of the check suite.
/// Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`,
/// `action_required` or `stale`. This value will be `null` until the check run
/// has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckSuiteRequestedCheckSuiteConclusion> for CheckSuiteRequestedCheckSuiteConclusion {
	fn from(value: &CheckSuiteRequestedCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRequestedCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The summary status for all check runs that are part of the check suite. Can
/// be `queued`, `requested`, `in_progress`, or `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRequestedCheckSuiteStatus {
	#[serde(rename = "requested")]
	Requested,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
}
impl From<&CheckSuiteRequestedCheckSuiteStatus> for CheckSuiteRequestedCheckSuiteStatus {
	fn from(value: &CheckSuiteRequestedCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRequestedCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRequestedCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequested {
	pub action:       CheckSuiteRerequestedAction,
	pub check_suite:  CheckSuiteRerequestedCheckSuite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CheckSuiteRerequested> for CheckSuiteRerequested {
	fn from(value: &CheckSuiteRerequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedAction {
	#[serde(rename = "rerequested")]
	Rerequested,
}
impl From<&CheckSuiteRerequestedAction> for CheckSuiteRerequestedAction {
	fn from(value: &CheckSuiteRerequestedAction) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRerequestedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Rerequested => "rerequested".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRerequestedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"rerequested" => Ok(Self::Rerequested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CheckSuiteRerequestedCheckSuite {
	pub after: Option<String>,
	pub app: App,
	pub before: Option<String>,
	pub check_runs_url: String,
	/// The summary conclusion for all check runs that are part of the check
	/// suite. Can be one of `success`, `failure`,` neutral`, `cancelled`,
	/// `timed_out`, `action_required` or `stale`. This value will be `null`
	/// until the check run has completed.
	pub conclusion: Option<CheckSuiteRerequestedCheckSuiteConclusion>,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	/// The head branch name the changes are on.
	pub head_branch: Option<String>,
	pub head_commit: CommitSimple,
	/// The SHA of the head commit that is being checked.
	pub head_sha: String,
	pub id: i64,
	pub latest_check_runs_count: i64,
	pub node_id: String,
	/// An array of pull requests that match this check suite. A pull request
	/// matches a check suite if they have the same `head_sha` and
	/// `head_branch`. When the check suite's `head_branch` is in a forked
	/// repository it will be `null` and the `pull_requests` array will be
	/// empty.
	pub pull_requests: Vec<CheckRunPullRequest>,
	/// The summary status for all check runs that are part of the check suite.
	/// Can be `queued`, `requested`, `in_progress`, or `completed`.
	pub status: Option<CheckSuiteRerequestedCheckSuiteStatus>,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// URL that points to the check suite API resource.
	pub url: String,
}
impl From<&CheckSuiteRerequestedCheckSuite> for CheckSuiteRerequestedCheckSuite {
	fn from(value: &CheckSuiteRerequestedCheckSuite) -> Self {
		value.clone()
	}
}
/// The summary conclusion for all check runs that are part of the check suite.
/// Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`,
/// `action_required` or `stale`. This value will be `null` until the check run
/// has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&CheckSuiteRerequestedCheckSuiteConclusion>
	for CheckSuiteRerequestedCheckSuiteConclusion
{
	fn from(value: &CheckSuiteRerequestedCheckSuiteConclusion) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRerequestedCheckSuiteConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The summary status for all check runs that are part of the check suite. Can
/// be `queued`, `requested`, `in_progress`, or `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CheckSuiteRerequestedCheckSuiteStatus {
	#[serde(rename = "requested")]
	Requested,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
}
impl From<&CheckSuiteRerequestedCheckSuiteStatus> for CheckSuiteRerequestedCheckSuiteStatus {
	fn from(value: &CheckSuiteRerequestedCheckSuiteStatus) -> Self {
		value.clone()
	}
}
impl ToString for CheckSuiteRerequestedCheckSuiteStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for CheckSuiteRerequestedCheckSuiteStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CheckSuiteRerequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CheckSuiteRerequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CheckSuiteRerequestedCheckSuiteStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranch {
	pub action:       CodeScanningAlertAppearedInBranchAction,
	pub alert:        CodeScanningAlertAppearedInBranchAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&CodeScanningAlertAppearedInBranch> for CodeScanningAlertAppearedInBranch {
	fn from(value: &CodeScanningAlertAppearedInBranch) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAction {
	#[serde(rename = "appeared_in_branch")]
	AppearedInBranch,
}
impl From<&CodeScanningAlertAppearedInBranchAction> for CodeScanningAlertAppearedInBranchAction {
	fn from(value: &CodeScanningAlertAppearedInBranchAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertAppearedInBranchAction {
	fn to_string(&self) -> String {
		match *self {
			Self::AppearedInBranch => "appeared_in_branch".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"appeared_in_branch" => Ok(Self::AppearedInBranch),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         Option<chrono::DateTime<chrono::offset::Utc>>,
	pub dismissed_by:         Option<User>,
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     Option<CodeScanningAlertAppearedInBranchAlertDismissedReason>,
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertAppearedInBranchAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertAppearedInBranchAlertState,
	pub tool:                 CodeScanningAlertAppearedInBranchAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertAppearedInBranchAlert> for CodeScanningAlertAppearedInBranchAlert {
	fn from(value: &CodeScanningAlertAppearedInBranchAlert) -> Self {
		value.clone()
	}
}
/// The reason for dismissing or closing the alert. Can be one of: `false
/// positive`, `won't fix`, and `used in tests`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertDismissedReason {
	#[serde(rename = "false positive")]
	FalsePositive,
	#[serde(rename = "won't fix")]
	WontFix,
	#[serde(rename = "used in tests")]
	UsedInTests,
}
impl From<&CodeScanningAlertAppearedInBranchAlertDismissedReason>
	for CodeScanningAlertAppearedInBranchAlertDismissedReason
{
	fn from(value: &CodeScanningAlertAppearedInBranchAlertDismissedReason) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertAppearedInBranchAlertDismissedReason {
	fn to_string(&self) -> String {
		match *self {
			Self::FalsePositive => "false positive".to_string(),
			Self::WontFix => "won't fix".to_string(),
			Self::UsedInTests => "used in tests".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertDismissedReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"false positive" => Ok(Self::FalsePositive),
			"won't fix" => Ok(Self::WontFix),
			"used in tests" => Ok(Self::UsedInTests),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description: String,
	/// A unique identifier for the rule used to detect the alert.
	pub id:          String,
	/// The severity of the alert.
	pub severity:    Option<CodeScanningAlertAppearedInBranchAlertRuleSeverity>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRule>
	for CodeScanningAlertAppearedInBranchAlertRule
{
	fn from(value: &CodeScanningAlertAppearedInBranchAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertAppearedInBranchAlertRuleSeverity>
	for CodeScanningAlertAppearedInBranchAlertRuleSeverity
{
	fn from(value: &CodeScanningAlertAppearedInBranchAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertAppearedInBranchAlertState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "dismissed")]
	Dismissed,
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&CodeScanningAlertAppearedInBranchAlertState>
	for CodeScanningAlertAppearedInBranchAlertState
{
	fn from(value: &CodeScanningAlertAppearedInBranchAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertAppearedInBranchAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Dismissed => "dismissed".to_string(),
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertAppearedInBranchAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"dismissed" => Ok(Self::Dismissed),
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertAppearedInBranchAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertAppearedInBranchAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertAppearedInBranchAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertAppearedInBranchAlertTool {
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertAppearedInBranchAlertTool>
	for CodeScanningAlertAppearedInBranchAlertTool
{
	fn from(value: &CodeScanningAlertAppearedInBranchAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUser {
	pub action:       CodeScanningAlertClosedByUserAction,
	pub alert:        CodeScanningAlertClosedByUserAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CodeScanningAlertClosedByUser> for CodeScanningAlertClosedByUser {
	fn from(value: &CodeScanningAlertClosedByUser) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAction {
	#[serde(rename = "closed_by_user")]
	ClosedByUser,
}
impl From<&CodeScanningAlertClosedByUserAction> for CodeScanningAlertClosedByUserAction {
	fn from(value: &CodeScanningAlertClosedByUserAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertClosedByUserAction {
	fn to_string(&self) -> String {
		match *self {
			Self::ClosedByUser => "closed_by_user".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"closed_by_user" => Ok(Self::ClosedByUser),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         chrono::DateTime<chrono::offset::Utc>,
	pub dismissed_by:         User,
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     Option<CodeScanningAlertClosedByUserAlertDismissedReason>,
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertClosedByUserAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertClosedByUserAlertState,
	pub tool:                 CodeScanningAlertClosedByUserAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertClosedByUserAlert> for CodeScanningAlertClosedByUserAlert {
	fn from(value: &CodeScanningAlertClosedByUserAlert) -> Self {
		value.clone()
	}
}
/// The reason for dismissing or closing the alert. Can be one of: `false
/// positive`, `won't fix`, and `used in tests`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertDismissedReason {
	#[serde(rename = "false positive")]
	FalsePositive,
	#[serde(rename = "won't fix")]
	WontFix,
	#[serde(rename = "used in tests")]
	UsedInTests,
}
impl From<&CodeScanningAlertClosedByUserAlertDismissedReason>
	for CodeScanningAlertClosedByUserAlertDismissedReason
{
	fn from(value: &CodeScanningAlertClosedByUserAlertDismissedReason) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertClosedByUserAlertDismissedReason {
	fn to_string(&self) -> String {
		match *self {
			Self::FalsePositive => "false positive".to_string(),
			Self::WontFix => "won't fix".to_string(),
			Self::UsedInTests => "used in tests".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertDismissedReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"false positive" => Ok(Self::FalsePositive),
			"won't fix" => Ok(Self::WontFix),
			"used in tests" => Ok(Self::UsedInTests),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description:      String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub full_description: Option<String>,
	#[serde(default)]
	pub help:             (),
	/// A unique identifier for the rule used to detect the alert.
	pub id:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:             Option<String>,
	/// The severity of the alert.
	pub severity:         Option<CodeScanningAlertClosedByUserAlertRuleSeverity>,
	#[serde(default)]
	pub tags:             (),
}
impl From<&CodeScanningAlertClosedByUserAlertRule> for CodeScanningAlertClosedByUserAlertRule {
	fn from(value: &CodeScanningAlertClosedByUserAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertClosedByUserAlertRuleSeverity>
	for CodeScanningAlertClosedByUserAlertRuleSeverity
{
	fn from(value: &CodeScanningAlertClosedByUserAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertClosedByUserAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertClosedByUserAlertState {
	#[serde(rename = "dismissed")]
	Dismissed,
}
impl From<&CodeScanningAlertClosedByUserAlertState> for CodeScanningAlertClosedByUserAlertState {
	fn from(value: &CodeScanningAlertClosedByUserAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertClosedByUserAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Dismissed => "dismissed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertClosedByUserAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dismissed" => Ok(Self::Dismissed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertClosedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertClosedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertClosedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertClosedByUserAlertTool {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub guid:    Option<String>,
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertClosedByUserAlertTool> for CodeScanningAlertClosedByUserAlertTool {
	fn from(value: &CodeScanningAlertClosedByUserAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreated {
	pub action:       CodeScanningAlertCreatedAction,
	pub alert:        CodeScanningAlertCreatedAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&CodeScanningAlertCreated> for CodeScanningAlertCreated {
	fn from(value: &CodeScanningAlertCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&CodeScanningAlertCreatedAction> for CodeScanningAlertCreatedAction {
	fn from(value: &CodeScanningAlertCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         (),
	pub dismissed_by:         (),
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     (),
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertCreatedAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertCreatedAlertState,
	pub tool:                 CodeScanningAlertCreatedAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertCreatedAlert> for CodeScanningAlertCreatedAlert {
	fn from(value: &CodeScanningAlertCreatedAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description:      String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub full_description: Option<String>,
	#[serde(default)]
	pub help:             (),
	/// A unique identifier for the rule used to detect the alert.
	pub id:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:             Option<String>,
	/// The severity of the alert.
	pub severity:         Option<CodeScanningAlertCreatedAlertRuleSeverity>,
	#[serde(default)]
	pub tags:             (),
}
impl From<&CodeScanningAlertCreatedAlertRule> for CodeScanningAlertCreatedAlertRule {
	fn from(value: &CodeScanningAlertCreatedAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertCreatedAlertRuleSeverity>
	for CodeScanningAlertCreatedAlertRuleSeverity
{
	fn from(value: &CodeScanningAlertCreatedAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertCreatedAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertCreatedAlertState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "dismissed")]
	Dismissed,
}
impl From<&CodeScanningAlertCreatedAlertState> for CodeScanningAlertCreatedAlertState {
	fn from(value: &CodeScanningAlertCreatedAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertCreatedAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Dismissed => "dismissed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertCreatedAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"dismissed" => Ok(Self::Dismissed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertCreatedAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertCreatedAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertCreatedAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertCreatedAlertTool {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub guid:    Option<String>,
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertCreatedAlertTool> for CodeScanningAlertCreatedAlertTool {
	fn from(value: &CodeScanningAlertCreatedAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CodeScanningAlertEvent {
	AppearedInBranch(CodeScanningAlertAppearedInBranch),
	ClosedByUser(CodeScanningAlertClosedByUser),
	Created(CodeScanningAlertCreated),
	Fixed(CodeScanningAlertFixed),
	Reopened(CodeScanningAlertReopened),
	ReopenedByUser(CodeScanningAlertReopenedByUser),
}
impl From<&CodeScanningAlertEvent> for CodeScanningAlertEvent {
	fn from(value: &CodeScanningAlertEvent) -> Self {
		value.clone()
	}
}
impl From<CodeScanningAlertAppearedInBranch> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertAppearedInBranch) -> Self {
		Self::AppearedInBranch(value)
	}
}
impl From<CodeScanningAlertClosedByUser> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertClosedByUser) -> Self {
		Self::ClosedByUser(value)
	}
}
impl From<CodeScanningAlertCreated> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertCreated) -> Self {
		Self::Created(value)
	}
}
impl From<CodeScanningAlertFixed> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertFixed) -> Self {
		Self::Fixed(value)
	}
}
impl From<CodeScanningAlertReopened> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertReopened) -> Self {
		Self::Reopened(value)
	}
}
impl From<CodeScanningAlertReopenedByUser> for CodeScanningAlertEvent {
	fn from(value: CodeScanningAlertReopenedByUser) -> Self {
		Self::ReopenedByUser(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixed {
	pub action:       CodeScanningAlertFixedAction,
	pub alert:        CodeScanningAlertFixedAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&CodeScanningAlertFixed> for CodeScanningAlertFixed {
	fn from(value: &CodeScanningAlertFixed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAction {
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&CodeScanningAlertFixedAction> for CodeScanningAlertFixedAction {
	fn from(value: &CodeScanningAlertFixedAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertFixedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertFixedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         Option<chrono::DateTime<chrono::offset::Utc>>,
	pub dismissed_by:         Option<User>,
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     Option<CodeScanningAlertFixedAlertDismissedReason>,
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub instances_url:        Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertFixedAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertFixedAlertState,
	pub tool:                 CodeScanningAlertFixedAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertFixedAlert> for CodeScanningAlertFixedAlert {
	fn from(value: &CodeScanningAlertFixedAlert) -> Self {
		value.clone()
	}
}
/// The reason for dismissing or closing the alert. Can be one of: `false
/// positive`, `won't fix`, and `used in tests`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertDismissedReason {
	#[serde(rename = "false positive")]
	FalsePositive,
	#[serde(rename = "won't fix")]
	WontFix,
	#[serde(rename = "used in tests")]
	UsedInTests,
}
impl From<&CodeScanningAlertFixedAlertDismissedReason>
	for CodeScanningAlertFixedAlertDismissedReason
{
	fn from(value: &CodeScanningAlertFixedAlertDismissedReason) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertFixedAlertDismissedReason {
	fn to_string(&self) -> String {
		match *self {
			Self::FalsePositive => "false positive".to_string(),
			Self::WontFix => "won't fix".to_string(),
			Self::UsedInTests => "used in tests".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertFixedAlertDismissedReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"false positive" => Ok(Self::FalsePositive),
			"won't fix" => Ok(Self::WontFix),
			"used in tests" => Ok(Self::UsedInTests),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description:      String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub full_description: Option<String>,
	#[serde(default)]
	pub help:             (),
	/// A unique identifier for the rule used to detect the alert.
	pub id:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:             Option<String>,
	/// The severity of the alert.
	pub severity:         Option<CodeScanningAlertFixedAlertRuleSeverity>,
	#[serde(default)]
	pub tags:             (),
}
impl From<&CodeScanningAlertFixedAlertRule> for CodeScanningAlertFixedAlertRule {
	fn from(value: &CodeScanningAlertFixedAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertFixedAlertRuleSeverity> for CodeScanningAlertFixedAlertRuleSeverity {
	fn from(value: &CodeScanningAlertFixedAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertFixedAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertFixedAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertFixedAlertState {
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&CodeScanningAlertFixedAlertState> for CodeScanningAlertFixedAlertState {
	fn from(value: &CodeScanningAlertFixedAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertFixedAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertFixedAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertFixedAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertFixedAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertFixedAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertFixedAlertTool {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub guid:    Option<String>,
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertFixedAlertTool> for CodeScanningAlertFixedAlertTool {
	fn from(value: &CodeScanningAlertFixedAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopened {
	pub action:       CodeScanningAlertReopenedAction,
	pub alert:        CodeScanningAlertReopenedAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&CodeScanningAlertReopened> for CodeScanningAlertReopened {
	fn from(value: &CodeScanningAlertReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&CodeScanningAlertReopenedAction> for CodeScanningAlertReopenedAction {
	fn from(value: &CodeScanningAlertReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         (),
	pub dismissed_by:         (),
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     (),
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertReopenedAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertReopenedAlertState,
	pub tool:                 CodeScanningAlertReopenedAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertReopenedAlert> for CodeScanningAlertReopenedAlert {
	fn from(value: &CodeScanningAlertReopenedAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description:      String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub full_description: Option<String>,
	#[serde(default)]
	pub help:             (),
	/// A unique identifier for the rule used to detect the alert.
	pub id:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:             Option<String>,
	/// The severity of the alert.
	pub severity:         Option<CodeScanningAlertReopenedAlertRuleSeverity>,
	#[serde(default)]
	pub tags:             (),
}
impl From<&CodeScanningAlertReopenedAlertRule> for CodeScanningAlertReopenedAlertRule {
	fn from(value: &CodeScanningAlertReopenedAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertReopenedAlertRuleSeverity>
	for CodeScanningAlertReopenedAlertRuleSeverity
{
	fn from(value: &CodeScanningAlertReopenedAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedAlertState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "dismissed")]
	Dismissed,
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&CodeScanningAlertReopenedAlertState> for CodeScanningAlertReopenedAlertState {
	fn from(value: &CodeScanningAlertReopenedAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Dismissed => "dismissed".to_string(),
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"dismissed" => Ok(Self::Dismissed),
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedAlertTool {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub guid:    Option<String>,
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedAlertTool> for CodeScanningAlertReopenedAlertTool {
	fn from(value: &CodeScanningAlertReopenedAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUser {
	pub action:       CodeScanningAlertReopenedByUserAction,
	pub alert:        CodeScanningAlertReopenedByUserAlert,
	/// The commit SHA of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	pub commit_oid:   String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The Git reference of the code scanning alert. When the action is
	/// `reopened_by_user` or `closed_by_user`, the event was triggered by the
	/// `sender` and this value will be empty.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CodeScanningAlertReopenedByUser> for CodeScanningAlertReopenedByUser {
	fn from(value: &CodeScanningAlertReopenedByUser) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAction {
	#[serde(rename = "reopened_by_user")]
	ReopenedByUser,
}
impl From<&CodeScanningAlertReopenedByUserAction> for CodeScanningAlertReopenedByUserAction {
	fn from(value: &CodeScanningAlertReopenedByUserAction) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedByUserAction {
	fn to_string(&self) -> String {
		match *self {
			Self::ReopenedByUser => "reopened_by_user".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened_by_user" => Ok(Self::ReopenedByUser),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The code scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ.`
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:         (),
	pub dismissed_by:         (),
	/// The reason for dismissing or closing the alert. Can be one of: `false
	/// positive`, `won't fix`, and `used in tests`.
	pub dismissed_reason:     (),
	/// The GitHub URL of the alert resource.
	pub html_url:             String,
	pub instances:            Vec<AlertInstance>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub most_recent_instance: Option<AlertInstance>,
	/// The code scanning alert number.
	pub number:               i64,
	pub rule:                 CodeScanningAlertReopenedByUserAlertRule,
	/// State of a code scanning alert.
	pub state:                CodeScanningAlertReopenedByUserAlertState,
	pub tool:                 CodeScanningAlertReopenedByUserAlertTool,
	/// The REST API URL of the alert resource.
	pub url:                  String,
}
impl From<&CodeScanningAlertReopenedByUserAlert> for CodeScanningAlertReopenedByUserAlert {
	fn from(value: &CodeScanningAlertReopenedByUserAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertRule {
	/// A short description of the rule used to detect the alert.
	pub description: String,
	/// A unique identifier for the rule used to detect the alert.
	pub id:          String,
	/// The severity of the alert.
	pub severity:    Option<CodeScanningAlertReopenedByUserAlertRuleSeverity>,
}
impl From<&CodeScanningAlertReopenedByUserAlertRule> for CodeScanningAlertReopenedByUserAlertRule {
	fn from(value: &CodeScanningAlertReopenedByUserAlertRule) -> Self {
		value.clone()
	}
}
/// The severity of the alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertRuleSeverity {
	#[serde(rename = "none")]
	None,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "warning")]
	Warning,
	#[serde(rename = "error")]
	Error,
}
impl From<&CodeScanningAlertReopenedByUserAlertRuleSeverity>
	for CodeScanningAlertReopenedByUserAlertRuleSeverity
{
	fn from(value: &CodeScanningAlertReopenedByUserAlertRuleSeverity) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedByUserAlertRuleSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::None => "none".to_string(),
			Self::Note => "note".to_string(),
			Self::Warning => "warning".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertRuleSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"none" => Ok(Self::None),
			"note" => Ok(Self::Note),
			"warning" => Ok(Self::Warning),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertRuleSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of a code scanning alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CodeScanningAlertReopenedByUserAlertState {
	#[serde(rename = "open")]
	Open,
}
impl From<&CodeScanningAlertReopenedByUserAlertState>
	for CodeScanningAlertReopenedByUserAlertState
{
	fn from(value: &CodeScanningAlertReopenedByUserAlertState) -> Self {
		value.clone()
	}
}
impl ToString for CodeScanningAlertReopenedByUserAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
		}
	}
}
impl std::str::FromStr for CodeScanningAlertReopenedByUserAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CodeScanningAlertReopenedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CodeScanningAlertReopenedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CodeScanningAlertReopenedByUserAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CodeScanningAlertReopenedByUserAlertTool {
	/// The name of the tool used to generate the code scanning analysis alert.
	pub name:    String,
	/// The version of the tool used to detect the alert.
	pub version: Option<String>,
}
impl From<&CodeScanningAlertReopenedByUserAlertTool> for CodeScanningAlertReopenedByUserAlertTool {
	fn from(value: &CodeScanningAlertReopenedByUserAlertTool) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Commit {
	/// An array of files added in the commit. For extremely large commits where
	/// GitHub is unable to calculate this list in a timely manner, this may be
	/// empty even if files were added.
	pub added:     Vec<String>,
	pub author:    Committer,
	pub committer: Committer,
	/// Whether this commit is distinct from any that have been pushed before.
	pub distinct:  bool,
	pub id:        String,
	/// The commit message.
	pub message:   String,
	/// An array of files modified by the commit. For extremely large commits
	/// where GitHub is unable to calculate this list in a timely manner, this
	/// may be empty even if files were modified.
	pub modified:  Vec<String>,
	/// An array of files removed in the commit. For extremely large commits
	/// where GitHub is unable to calculate this list in a timely manner, this
	/// may be empty even if files were removed.
	pub removed:   Vec<String>,
	/// The ISO 8601 timestamp of the commit.
	pub timestamp: chrono::DateTime<chrono::offset::Utc>,
	pub tree_id:   String,
	/// URL that points to the commit API resource.
	pub url:       String,
}
impl From<&Commit> for Commit {
	fn from(value: &Commit) -> Self {
		value.clone()
	}
}
/// A commit comment is created. The type of activity is specified in the
/// `action` property.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreated {
	/// The action performed. Can be `created`.
	pub action:       CommitCommentCreatedAction,
	pub comment:      CommitCommentCreatedComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&CommitCommentCreated> for CommitCommentCreated {
	fn from(value: &CommitCommentCreated) -> Self {
		value.clone()
	}
}
/// The action performed. Can be `created`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CommitCommentCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&CommitCommentCreatedAction> for CommitCommentCreatedAction {
	fn from(value: &CommitCommentCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for CommitCommentCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for CommitCommentCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CommitCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CommitCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CommitCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitCommentCreatedComment {
	pub author_association: AuthorAssociation,
	/// The text of the comment.
	pub body:               String,
	/// The SHA of the commit to which the comment applies.
	pub commit_id:          String,
	pub created_at:         chrono::DateTime<chrono::offset::Utc>,
	pub html_url:           String,
	/// The ID of the commit comment.
	pub id:                 i64,
	/// The line of the blob to which the comment applies. The last line of the
	/// range for a multi-line comment
	pub line:               Option<i64>,
	/// The node ID of the commit comment.
	pub node_id:            String,
	/// The relative path of the file to which the comment applies.
	pub path:               Option<String>,
	/// The line index in the diff to which the comment applies.
	pub position:           Option<i64>,
	pub updated_at:         chrono::DateTime<chrono::offset::Utc>,
	pub url:                String,
	pub user:               User,
}
impl From<&CommitCommentCreatedComment> for CommitCommentCreatedComment {
	fn from(value: &CommitCommentCreatedComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CommitCommentEvent(pub CommitCommentCreated);
impl std::ops::Deref for CommitCommentEvent {
	type Target = CommitCommentCreated;

	fn deref(&self) -> &CommitCommentCreated {
		&self.0
	}
}
impl From<CommitCommentEvent> for CommitCommentCreated {
	fn from(value: CommitCommentEvent) -> Self {
		value.0
	}
}
impl From<&CommitCommentEvent> for CommitCommentEvent {
	fn from(value: &CommitCommentEvent) -> Self {
		value.clone()
	}
}
impl From<CommitCommentCreated> for CommitCommentEvent {
	fn from(value: CommitCommentCreated) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CommitSimple {
	pub author:    Committer,
	pub committer: Committer,
	pub id:        String,
	pub message:   String,
	pub timestamp: String,
	pub tree_id:   String,
}
impl From<&CommitSimple> for CommitSimple {
	fn from(value: &CommitSimple) -> Self {
		value.clone()
	}
}
/// Metaproperties for Git author/committer information.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Committer {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub date:     Option<chrono::DateTime<chrono::offset::Utc>>,
	/// The git author's email address.
	pub email:    Option<String>,
	/// The git author's name.
	pub name:     String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub username: Option<String>,
}
impl From<&Committer> for Committer {
	fn from(value: &Committer) -> Self {
		value.clone()
	}
}
/// A Git branch or tag is created.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CreateEvent {
	/// The repository's current description.
	pub description:   Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:  Option<InstallationLite>,
	/// The name of the repository's default branch (usually `main`).
	pub master_branch: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:  Option<Organization>,
	/// The pusher type for the event. Can be either `user` or a deploy key.
	pub pusher_type:   String,
	/// The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.
	#[serde(rename = "ref")]
	pub ref_:          String,
	/// The type of Git ref object created in the repository. Can be either
	/// `branch` or `tag`.
	pub ref_type:      CreateEventRefType,
	pub repository:    Repository,
	pub sender:        User,
}
impl From<&CreateEvent> for CreateEvent {
	fn from(value: &CreateEvent) -> Self {
		value.clone()
	}
}
/// The type of Git ref object created in the repository. Can be either `branch`
/// or `tag`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CreateEventRefType {
	#[serde(rename = "tag")]
	Tag,
	#[serde(rename = "branch")]
	Branch,
}
impl From<&CreateEventRefType> for CreateEventRefType {
	fn from(value: &CreateEventRefType) -> Self {
		value.clone()
	}
}
impl ToString for CreateEventRefType {
	fn to_string(&self) -> String {
		match *self {
			Self::Tag => "tag".to_string(),
			Self::Branch => "branch".to_string(),
		}
	}
}
impl std::str::FromStr for CreateEventRefType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"tag" => Ok(Self::Tag),
			"branch" => Ok(Self::Branch),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for CreateEventRefType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for CreateEventRefType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for CreateEventRefType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// A Git branch or tag is deleted.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeleteEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The pusher type for the event. Can be either `user` or a deploy key.
	pub pusher_type:  String,
	/// The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.
	#[serde(rename = "ref")]
	pub ref_:         String,
	/// The type of Git ref object deleted in the repository. Can be either
	/// `branch` or `tag`.
	pub ref_type:     DeleteEventRefType,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DeleteEvent> for DeleteEvent {
	fn from(value: &DeleteEvent) -> Self {
		value.clone()
	}
}
/// The type of Git ref object deleted in the repository. Can be either `branch`
/// or `tag`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeleteEventRefType {
	#[serde(rename = "tag")]
	Tag,
	#[serde(rename = "branch")]
	Branch,
}
impl From<&DeleteEventRefType> for DeleteEventRefType {
	fn from(value: &DeleteEventRefType) -> Self {
		value.clone()
	}
}
impl ToString for DeleteEventRefType {
	fn to_string(&self) -> String {
		match *self {
			Self::Tag => "tag".to_string(),
			Self::Branch => "branch".to_string(),
		}
	}
}
impl std::str::FromStr for DeleteEventRefType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"tag" => Ok(Self::Tag),
			"branch" => Ok(Self::Branch),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeleteEventRefType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeleteEventRefType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeleteEventRefType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// A Dependabot alert.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlert {
	/// The time that the alert was created in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub created_at:             chrono::DateTime<chrono::offset::Utc>,
	pub dependency:             DependabotAlertDependency,
	/// The time that the alert was dismissed in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub dismissed_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub dismissed_by:           Option<User>,
	/// An optional comment associated with the alert's dismissal.
	pub dismissed_comment:      Option<String>,
	/// The reason that the alert was dismissed.
	pub dismissed_reason:       Option<DependabotAlertDismissedReason>,
	/// The time that the alert was no longer detected and was considered fixed
	/// in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
	pub fixed_at:               Option<chrono::DateTime<chrono::offset::Utc>>,
	/// The GitHub URL of the alert resource.
	pub html_url:               String,
	/// The security alert number.
	pub number:                 i64,
	pub security_advisory:      DependabotAlertSecurityAdvisory,
	pub security_vulnerability: DependabotAlertSecurityVulnerability,
	/// The state of the Dependabot alert.
	pub state:                  DependabotAlertState,
	/// The time that the alert was last updated in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub updated_at:             chrono::DateTime<chrono::offset::Utc>,
	/// The REST API URL of the alert resource.
	pub url:                    String,
}
impl From<&DependabotAlert> for DependabotAlert {
	fn from(value: &DependabotAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertCreated {
	pub action:       DependabotAlertCreatedAction,
	pub alert:        DependabotAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&DependabotAlertCreated> for DependabotAlertCreated {
	fn from(value: &DependabotAlertCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DependabotAlertCreatedAction> for DependabotAlertCreatedAction {
	fn from(value: &DependabotAlertCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details for the vulnerable dependency.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertDependency {
	/// The full path to the dependency manifest file, relative to the root of
	/// the repository.
	pub manifest_path: String,
	pub package:       DependabotAlertPackage,
	/// The execution scope of the vulnerable dependency.
	pub scope:         Option<DependabotAlertDependencyScope>,
}
impl From<&DependabotAlertDependency> for DependabotAlertDependency {
	fn from(value: &DependabotAlertDependency) -> Self {
		value.clone()
	}
}
/// The execution scope of the vulnerable dependency.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertDependencyScope {
	#[serde(rename = "development")]
	Development,
	#[serde(rename = "runtime")]
	Runtime,
}
impl From<&DependabotAlertDependencyScope> for DependabotAlertDependencyScope {
	fn from(value: &DependabotAlertDependencyScope) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertDependencyScope {
	fn to_string(&self) -> String {
		match *self {
			Self::Development => "development".to_string(),
			Self::Runtime => "runtime".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertDependencyScope {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"development" => Ok(Self::Development),
			"runtime" => Ok(Self::Runtime),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertDependencyScope {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertDependencyScope {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertDependencyScope {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertDismissed {
	pub action:       DependabotAlertDismissedAction,
	pub alert:        DependabotAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DependabotAlertDismissed> for DependabotAlertDismissed {
	fn from(value: &DependabotAlertDismissed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertDismissedAction {
	#[serde(rename = "dismissed")]
	Dismissed,
}
impl From<&DependabotAlertDismissedAction> for DependabotAlertDismissedAction {
	fn from(value: &DependabotAlertDismissedAction) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertDismissedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Dismissed => "dismissed".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertDismissedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dismissed" => Ok(Self::Dismissed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertDismissedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertDismissedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertDismissedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The reason that the alert was dismissed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertDismissedReason {
	#[serde(rename = "fix_started")]
	FixStarted,
	#[serde(rename = "inaccurate")]
	Inaccurate,
	#[serde(rename = "no_bandwidth")]
	NoBandwidth,
	#[serde(rename = "not_used")]
	NotUsed,
	#[serde(rename = "tolerable_risk")]
	TolerableRisk,
}
impl From<&DependabotAlertDismissedReason> for DependabotAlertDismissedReason {
	fn from(value: &DependabotAlertDismissedReason) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertDismissedReason {
	fn to_string(&self) -> String {
		match *self {
			Self::FixStarted => "fix_started".to_string(),
			Self::Inaccurate => "inaccurate".to_string(),
			Self::NoBandwidth => "no_bandwidth".to_string(),
			Self::NotUsed => "not_used".to_string(),
			Self::TolerableRisk => "tolerable_risk".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertDismissedReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"fix_started" => Ok(Self::FixStarted),
			"inaccurate" => Ok(Self::Inaccurate),
			"no_bandwidth" => Ok(Self::NoBandwidth),
			"not_used" => Ok(Self::NotUsed),
			"tolerable_risk" => Ok(Self::TolerableRisk),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertDismissedReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DependabotAlertEvent {
	Created(DependabotAlertCreated),
	Dismissed(DependabotAlertDismissed),
	Fixed(DependabotAlertFixed),
	Reintroduced(DependabotAlertReintroduced),
	Reopened(DependabotAlertReopened),
}
impl From<&DependabotAlertEvent> for DependabotAlertEvent {
	fn from(value: &DependabotAlertEvent) -> Self {
		value.clone()
	}
}
impl From<DependabotAlertCreated> for DependabotAlertEvent {
	fn from(value: DependabotAlertCreated) -> Self {
		Self::Created(value)
	}
}
impl From<DependabotAlertDismissed> for DependabotAlertEvent {
	fn from(value: DependabotAlertDismissed) -> Self {
		Self::Dismissed(value)
	}
}
impl From<DependabotAlertFixed> for DependabotAlertEvent {
	fn from(value: DependabotAlertFixed) -> Self {
		Self::Fixed(value)
	}
}
impl From<DependabotAlertReintroduced> for DependabotAlertEvent {
	fn from(value: DependabotAlertReintroduced) -> Self {
		Self::Reintroduced(value)
	}
}
impl From<DependabotAlertReopened> for DependabotAlertEvent {
	fn from(value: DependabotAlertReopened) -> Self {
		Self::Reopened(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertFixed {
	pub action:       DependabotAlertFixedAction,
	pub alert:        DependabotAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&DependabotAlertFixed> for DependabotAlertFixed {
	fn from(value: &DependabotAlertFixed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertFixedAction {
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&DependabotAlertFixedAction> for DependabotAlertFixedAction {
	fn from(value: &DependabotAlertFixedAction) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertFixedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertFixedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertFixedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details for the vulnerable package.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertPackage {
	/// The package's language or package management ecosystem.
	pub ecosystem: String,
	/// The unique package name within its ecosystem.
	pub name:      String,
}
impl From<&DependabotAlertPackage> for DependabotAlertPackage {
	fn from(value: &DependabotAlertPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertReintroduced {
	pub action:       DependabotAlertReintroducedAction,
	pub alert:        DependabotAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&DependabotAlertReintroduced> for DependabotAlertReintroduced {
	fn from(value: &DependabotAlertReintroduced) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertReintroducedAction {
	#[serde(rename = "reintroduced")]
	Reintroduced,
}
impl From<&DependabotAlertReintroducedAction> for DependabotAlertReintroducedAction {
	fn from(value: &DependabotAlertReintroducedAction) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertReintroducedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reintroduced => "reintroduced".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertReintroducedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reintroduced" => Ok(Self::Reintroduced),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertReintroducedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertReintroducedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertReintroducedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertReopened {
	pub action:       DependabotAlertReopenedAction,
	pub alert:        DependabotAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DependabotAlertReopened> for DependabotAlertReopened {
	fn from(value: &DependabotAlertReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&DependabotAlertReopenedAction> for DependabotAlertReopenedAction {
	fn from(value: &DependabotAlertReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details for the GitHub Security Advisory.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityAdvisory {
	/// The unique CVE ID assigned to the advisory.
	pub cve_id:          Option<String>,
	pub cvss:            SecurityAdvisoryCvss,
	/// Details for the advisory pertaining to Common Weakness Enumeration.
	pub cwes:            Vec<SecurityAdvisoryCwes>,
	/// A long-form Markdown-supported description of the advisory.
	pub description:     String,
	/// Details for the GitHub Security Advisory.
	pub ghsa_id:         String,
	/// Values that identify this advisory among security information sources.
	pub identifiers:     Vec<DependabotAlertSecurityAdvisoryIdentifiersItem>,
	/// The time that the advisory was published in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub published_at:    chrono::DateTime<chrono::offset::Utc>,
	/// Links to additional advisory information.
	pub references:      Vec<DependabotAlertSecurityAdvisoryReferencesItem>,
	/// The severity of the advisory.
	pub severity:        DependabotAlertSecurityAdvisorySeverity,
	/// A short, plain text summary of the advisory.
	pub summary:         String,
	/// The time that the advisory was last modified in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
	/// Vulnerable version range information for the advisory.
	pub vulnerabilities: Vec<DependabotAlertSecurityAdvisoryVulnerabilitiesItem>,
	/// The time that the advisory was withdrawn in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`.
	pub withdrawn_at:    Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&DependabotAlertSecurityAdvisory> for DependabotAlertSecurityAdvisory {
	fn from(value: &DependabotAlertSecurityAdvisory) -> Self {
		value.clone()
	}
}
/// An advisory identifier.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityAdvisoryIdentifiersItem {
	/// The type of advisory identifier.
	#[serde(rename = "type")]
	pub type_: DependabotAlertSecurityAdvisoryIdentifiersItemType,
	/// The value of the advisory identifer.
	pub value: String,
}
impl From<&DependabotAlertSecurityAdvisoryIdentifiersItem>
	for DependabotAlertSecurityAdvisoryIdentifiersItem
{
	fn from(value: &DependabotAlertSecurityAdvisoryIdentifiersItem) -> Self {
		value.clone()
	}
}
/// The type of advisory identifier.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertSecurityAdvisoryIdentifiersItemType {
	#[serde(rename = "CVE")]
	Cve,
	#[serde(rename = "GHSA")]
	Ghsa,
}
impl From<&DependabotAlertSecurityAdvisoryIdentifiersItemType>
	for DependabotAlertSecurityAdvisoryIdentifiersItemType
{
	fn from(value: &DependabotAlertSecurityAdvisoryIdentifiersItemType) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertSecurityAdvisoryIdentifiersItemType {
	fn to_string(&self) -> String {
		match *self {
			Self::Cve => "CVE".to_string(),
			Self::Ghsa => "GHSA".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertSecurityAdvisoryIdentifiersItemType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"CVE" => Ok(Self::Cve),
			"GHSA" => Ok(Self::Ghsa),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertSecurityAdvisoryIdentifiersItemType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertSecurityAdvisoryIdentifiersItemType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertSecurityAdvisoryIdentifiersItemType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityAdvisoryReferencesItem {
	/// The URL of the reference.
	pub url: String,
}
impl From<&DependabotAlertSecurityAdvisoryReferencesItem>
	for DependabotAlertSecurityAdvisoryReferencesItem
{
	fn from(value: &DependabotAlertSecurityAdvisoryReferencesItem) -> Self {
		value.clone()
	}
}
/// The severity of the advisory.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertSecurityAdvisorySeverity {
	#[serde(rename = "low")]
	Low,
	#[serde(rename = "medium")]
	Medium,
	#[serde(rename = "high")]
	High,
	#[serde(rename = "critical")]
	Critical,
}
impl From<&DependabotAlertSecurityAdvisorySeverity> for DependabotAlertSecurityAdvisorySeverity {
	fn from(value: &DependabotAlertSecurityAdvisorySeverity) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertSecurityAdvisorySeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::Low => "low".to_string(),
			Self::Medium => "medium".to_string(),
			Self::High => "high".to_string(),
			Self::Critical => "critical".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertSecurityAdvisorySeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"low" => Ok(Self::Low),
			"medium" => Ok(Self::Medium),
			"high" => Ok(Self::High),
			"critical" => Ok(Self::Critical),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertSecurityAdvisorySeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertSecurityAdvisorySeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertSecurityAdvisorySeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details pertaining to one vulnerable version range for the advisory.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityAdvisoryVulnerabilitiesItem {
	pub first_patched_version:
		DependabotAlertSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
	pub package:                  DependabotAlertPackage,
	/// The severity of the vulnerability.
	pub severity:                 DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity,
	/// Conditions that identify vulnerable versions of this vulnerability's
	/// package.
	pub vulnerable_version_range: String,
}
impl From<&DependabotAlertSecurityAdvisoryVulnerabilitiesItem>
	for DependabotAlertSecurityAdvisoryVulnerabilitiesItem
{
	fn from(value: &DependabotAlertSecurityAdvisoryVulnerabilitiesItem) -> Self {
		value.clone()
	}
}
/// Details pertaining to the package version that patches this vulnerability.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
	/// The package version that patches this vulnerability.
	pub identifier: String,
}
impl From<&DependabotAlertSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
	for DependabotAlertSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
	fn from(value: &DependabotAlertSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion) -> Self {
		value.clone()
	}
}
/// The severity of the vulnerability.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	#[serde(rename = "low")]
	Low,
	#[serde(rename = "medium")]
	Medium,
	#[serde(rename = "high")]
	High,
	#[serde(rename = "critical")]
	Critical,
}
impl From<&DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity>
	for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity
{
	fn from(value: &DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::Low => "low".to_string(),
			Self::Medium => "medium".to_string(),
			Self::High => "high".to_string(),
			Self::Critical => "critical".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"low" => Ok(Self::Low),
			"medium" => Ok(Self::Medium),
			"high" => Ok(Self::High),
			"critical" => Ok(Self::Critical),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertSecurityAdvisoryVulnerabilitiesItemSeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details pertaining to one vulnerable version range for the advisory.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityVulnerability {
	pub first_patched_version:    DependabotAlertSecurityVulnerabilityFirstPatchedVersion,
	pub package:                  DependabotAlertPackage,
	/// The severity of the vulnerability.
	pub severity:                 DependabotAlertSecurityVulnerabilitySeverity,
	/// Conditions that identify vulnerable versions of this vulnerability's
	/// package.
	pub vulnerable_version_range: String,
}
impl From<&DependabotAlertSecurityVulnerability> for DependabotAlertSecurityVulnerability {
	fn from(value: &DependabotAlertSecurityVulnerability) -> Self {
		value.clone()
	}
}
/// Details pertaining to the package version that patches this vulnerability.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DependabotAlertSecurityVulnerabilityFirstPatchedVersion {
	/// The package version that patches this vulnerability.
	pub identifier: String,
}
impl From<&DependabotAlertSecurityVulnerabilityFirstPatchedVersion>
	for DependabotAlertSecurityVulnerabilityFirstPatchedVersion
{
	fn from(value: &DependabotAlertSecurityVulnerabilityFirstPatchedVersion) -> Self {
		value.clone()
	}
}
/// The severity of the vulnerability.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertSecurityVulnerabilitySeverity {
	#[serde(rename = "low")]
	Low,
	#[serde(rename = "medium")]
	Medium,
	#[serde(rename = "high")]
	High,
	#[serde(rename = "critical")]
	Critical,
}
impl From<&DependabotAlertSecurityVulnerabilitySeverity>
	for DependabotAlertSecurityVulnerabilitySeverity
{
	fn from(value: &DependabotAlertSecurityVulnerabilitySeverity) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertSecurityVulnerabilitySeverity {
	fn to_string(&self) -> String {
		match *self {
			Self::Low => "low".to_string(),
			Self::Medium => "medium".to_string(),
			Self::High => "high".to_string(),
			Self::Critical => "critical".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertSecurityVulnerabilitySeverity {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"low" => Ok(Self::Low),
			"medium" => Ok(Self::Medium),
			"high" => Ok(Self::High),
			"critical" => Ok(Self::Critical),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertSecurityVulnerabilitySeverity {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertSecurityVulnerabilitySeverity {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertSecurityVulnerabilitySeverity {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The state of the Dependabot alert.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DependabotAlertState {
	#[serde(rename = "dismissed")]
	Dismissed,
	#[serde(rename = "fixed")]
	Fixed,
	#[serde(rename = "open")]
	Open,
}
impl From<&DependabotAlertState> for DependabotAlertState {
	fn from(value: &DependabotAlertState) -> Self {
		value.clone()
	}
}
impl ToString for DependabotAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Dismissed => "dismissed".to_string(),
			Self::Fixed => "fixed".to_string(),
			Self::Open => "open".to_string(),
		}
	}
}
impl std::str::FromStr for DependabotAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dismissed" => Ok(Self::Dismissed),
			"fixed" => Ok(Self::Fixed),
			"open" => Ok(Self::Open),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DependabotAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DependabotAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DependabotAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreated {
	pub action:       DeployKeyCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub key:          DeployKeyCreatedKey,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DeployKeyCreated> for DeployKeyCreated {
	fn from(value: &DeployKeyCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DeployKeyCreatedAction> for DeployKeyCreatedAction {
	fn from(value: &DeployKeyCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DeployKeyCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DeployKeyCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeployKeyCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeployKeyCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeployKeyCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [`deploy key`](https://docs.github.com/en/rest/reference/deployments#get-a-deploy-key) resource.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyCreatedKey {
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub id:         i64,
	pub key:        String,
	pub read_only:  bool,
	pub title:      String,
	pub url:        String,
	pub verified:   bool,
}
impl From<&DeployKeyCreatedKey> for DeployKeyCreatedKey {
	fn from(value: &DeployKeyCreatedKey) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeleted {
	pub action:       DeployKeyDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub key:          DeployKeyDeletedKey,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DeployKeyDeleted> for DeployKeyDeleted {
	fn from(value: &DeployKeyDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeployKeyDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&DeployKeyDeletedAction> for DeployKeyDeletedAction {
	fn from(value: &DeployKeyDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for DeployKeyDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for DeployKeyDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeployKeyDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeployKeyDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeployKeyDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [`deploy key`](https://docs.github.com/en/rest/reference/deployments#get-a-deploy-key) resource.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeployKeyDeletedKey {
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub id:         i64,
	pub key:        String,
	pub read_only:  bool,
	pub title:      String,
	pub url:        String,
	pub verified:   bool,
}
impl From<&DeployKeyDeletedKey> for DeployKeyDeletedKey {
	fn from(value: &DeployKeyDeletedKey) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DeployKeyEvent {
	Created(DeployKeyCreated),
	Deleted(DeployKeyDeleted),
}
impl From<&DeployKeyEvent> for DeployKeyEvent {
	fn from(value: &DeployKeyEvent) -> Self {
		value.clone()
	}
}
impl From<DeployKeyCreated> for DeployKeyEvent {
	fn from(value: DeployKeyCreated) -> Self {
		Self::Created(value)
	}
}
impl From<DeployKeyDeleted> for DeployKeyEvent {
	fn from(value: DeployKeyDeleted) -> Self {
		Self::Deleted(value)
	}
}
/// The [deployment](https://docs.github.com/en/rest/reference/deployments#list-deployments).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Deployment {
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub creator: User,
	pub description: Option<String>,
	/// Name of the target deployment environment.
	pub environment: String,
	/// Unique identifier of the deployment
	pub id: i64,
	pub node_id: String,
	pub original_environment: String,
	pub payload: std::collections::HashMap<String, serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub performed_via_github_app: Option<App>,
	/// Specifies if the given environment is one that end-users directly
	/// interact with. Default: false.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub production_environment: Option<bool>,
	/// The ref to deploy. This can be a branch, tag, or sha.
	#[serde(rename = "ref")]
	pub ref_: String,
	pub repository_url: String,
	pub sha: String,
	pub statuses_url: String,
	/// Parameter to specify a task to execute
	pub task: String,
	/// Specifies if the given environment will no longer exist at some point in
	/// the future. Default: false.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub transient_environment: Option<bool>,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	pub url: String,
}
impl From<&Deployment> for Deployment {
	fn from(value: &Deployment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentCreated {
	pub action:       DeploymentCreatedAction,
	pub deployment:   Deployment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow:     Option<Workflow>,
	pub workflow_run: Option<DeploymentWorkflowRun>,
}
impl From<&DeploymentCreated> for DeploymentCreated {
	fn from(value: &DeploymentCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DeploymentCreatedAction> for DeploymentCreatedAction {
	fn from(value: &DeploymentCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentEvent(pub DeploymentCreated);
impl std::ops::Deref for DeploymentEvent {
	type Target = DeploymentCreated;

	fn deref(&self) -> &DeploymentCreated {
		&self.0
	}
}
impl From<DeploymentEvent> for DeploymentCreated {
	fn from(value: DeploymentEvent) -> Self {
		value.0
	}
}
impl From<&DeploymentEvent> for DeploymentEvent {
	fn from(value: &DeploymentEvent) -> Self {
		value.clone()
	}
}
impl From<DeploymentCreated> for DeploymentEvent {
	fn from(value: DeploymentCreated) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreated {
	pub action:            DeploymentStatusCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub check_run:         Option<DeploymentStatusCreatedCheckRun>,
	pub deployment:        Deployment,
	pub deployment_status: DeploymentStatusCreatedDeploymentStatus,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:      Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:      Option<Organization>,
	pub repository:        Repository,
	pub sender:            User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub workflow:          Option<Workflow>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub workflow_run:      Option<DeploymentWorkflowRun>,
}
impl From<&DeploymentStatusCreated> for DeploymentStatusCreated {
	fn from(value: &DeploymentStatusCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DeploymentStatusCreatedAction> for DeploymentStatusCreatedAction {
	fn from(value: &DeploymentStatusCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentStatusCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentStatusCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedCheckRun {
	pub completed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	/// The result of the completed check run. Can be one of `success`,
	/// `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or
	/// `stale`. This value will be `null` until the check run has completed.
	pub conclusion:   Option<DeploymentStatusCreatedCheckRunConclusion>,
	pub details_url:  String,
	pub external_id:  String,
	/// The SHA of the commit that is being checked.
	pub head_sha:     String,
	pub html_url:     String,
	/// The id of the check.
	pub id:           i64,
	/// The name of the check run.
	pub name:         String,
	pub node_id:      String,
	pub started_at:   chrono::DateTime<chrono::offset::Utc>,
	/// The current status of the check run. Can be `queued`, `in_progress`, or
	/// `completed`.
	pub status:       DeploymentStatusCreatedCheckRunStatus,
	pub url:          String,
}
impl From<&DeploymentStatusCreatedCheckRun> for DeploymentStatusCreatedCheckRun {
	fn from(value: &DeploymentStatusCreatedCheckRun) -> Self {
		value.clone()
	}
}
/// The result of the completed check run. Can be one of `success`, `failure`,
/// `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This
/// value will be `null` until the check run has completed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedCheckRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&DeploymentStatusCreatedCheckRunConclusion>
	for DeploymentStatusCreatedCheckRunConclusion
{
	fn from(value: &DeploymentStatusCreatedCheckRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentStatusCreatedCheckRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentStatusCreatedCheckRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedCheckRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The current status of the check run. Can be `queued`, `in_progress`, or
/// `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedCheckRunStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "waiting")]
	Waiting,
}
impl From<&DeploymentStatusCreatedCheckRunStatus> for DeploymentStatusCreatedCheckRunStatus {
	fn from(value: &DeploymentStatusCreatedCheckRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentStatusCreatedCheckRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Waiting => "waiting".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentStatusCreatedCheckRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"waiting" => Ok(Self::Waiting),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedCheckRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [deployment status](https://docs.github.com/en/rest/reference/deployments#list-deployment-statuses).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentStatusCreatedDeploymentStatus {
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub creator: User,
	pub deployment_url: String,
	/// The optional human-readable description added to the status.
	pub description: String,
	pub environment: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub environment_url: Option<DeploymentStatusCreatedDeploymentStatusEnvironmentUrl>,
	pub id: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub log_url: Option<String>,
	pub node_id: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub performed_via_github_app: Option<App>,
	pub repository_url: String,
	/// The new state. Can be `pending`, `success`, `failure`, or `error`.
	pub state: String,
	/// The optional link added to the status.
	pub target_url: String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	pub url: String,
}
impl From<&DeploymentStatusCreatedDeploymentStatus> for DeploymentStatusCreatedDeploymentStatus {
	fn from(value: &DeploymentStatusCreatedDeploymentStatus) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	Variant0(String),
	Variant1(DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1),
}
impl From<&DeploymentStatusCreatedDeploymentStatusEnvironmentUrl>
	for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl
{
	fn from(value: &DeploymentStatusCreatedDeploymentStatusEnvironmentUrl) -> Self {
		value.clone()
	}
}
impl std::str::FromStr for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		if let Ok(v) = value.parse() {
			Ok(Self::Variant0(v))
		} else if let Ok(v) = value.parse() {
			Ok(Self::Variant1(v))
		} else {
			Err("string conversion failed for all variants")
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl ToString for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl {
	fn to_string(&self) -> String {
		match self {
			Self::Variant0(x) => x.to_string(),
			Self::Variant1(x) => x.to_string(),
		}
	}
}
impl From<DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1>
	for DeploymentStatusCreatedDeploymentStatusEnvironmentUrl
{
	fn from(value: DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1 {
	#[serde(rename = "")]
	X,
}
impl From<&DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1>
	for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1
{
	fn from(value: &DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1 {
	fn to_string(&self) -> String {
		match *self {
			Self::X => "".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1 {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"" => Ok(Self::X),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1 {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String>
	for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1
{
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String>
	for DeploymentStatusCreatedDeploymentStatusEnvironmentUrlVariant1
{
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DeploymentStatusEvent(pub DeploymentStatusCreated);
impl std::ops::Deref for DeploymentStatusEvent {
	type Target = DeploymentStatusCreated;

	fn deref(&self) -> &DeploymentStatusCreated {
		&self.0
	}
}
impl From<DeploymentStatusEvent> for DeploymentStatusCreated {
	fn from(value: DeploymentStatusEvent) -> Self {
		value.0
	}
}
impl From<&DeploymentStatusEvent> for DeploymentStatusEvent {
	fn from(value: &DeploymentStatusEvent) -> Self {
		value.clone()
	}
}
impl From<DeploymentStatusCreated> for DeploymentStatusEvent {
	fn from(value: DeploymentStatusCreated) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DeploymentWorkflowRun {
	pub actor:                User,
	pub check_suite_id:       i64,
	pub check_suite_node_id:  String,
	pub conclusion:           Option<DeploymentWorkflowRunConclusion>,
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub display_title:        Option<String>,
	pub event:                String,
	pub head_branch:          String,
	pub head_sha:             String,
	pub html_url:             String,
	pub id:                   i64,
	pub name:                 String,
	pub node_id:              String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub path:                 Option<String>,
	pub pull_requests:        Vec<CheckRunPullRequest>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub referenced_workflows: Vec<ReferencedWorkflow>,
	pub run_attempt:          i64,
	pub run_number:           i64,
	pub run_started_at:       chrono::DateTime<chrono::offset::Utc>,
	pub status:               DeploymentWorkflowRunStatus,
	pub triggering_actor:     User,
	pub updated_at:           chrono::DateTime<chrono::offset::Utc>,
	pub url:                  String,
	pub workflow_id:          i64,
}
impl From<&DeploymentWorkflowRun> for DeploymentWorkflowRun {
	fn from(value: &DeploymentWorkflowRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentWorkflowRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
}
impl From<&DeploymentWorkflowRunConclusion> for DeploymentWorkflowRunConclusion {
	fn from(value: &DeploymentWorkflowRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentWorkflowRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentWorkflowRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentWorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentWorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentWorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DeploymentWorkflowRunStatus {
	#[serde(rename = "requested")]
	Requested,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
}
impl From<&DeploymentWorkflowRunStatus> for DeploymentWorkflowRunStatus {
	fn from(value: &DeploymentWorkflowRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for DeploymentWorkflowRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for DeploymentWorkflowRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DeploymentWorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DeploymentWorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DeploymentWorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Discussion {
	pub active_lock_reason: Option<String>,
	pub answer_chosen_at:   Option<chrono::DateTime<chrono::offset::Utc>>,
	pub answer_chosen_by:   Option<User>,
	pub answer_html_url:    Option<String>,
	pub author_association: AuthorAssociation,
	/// The discussion post's body text.
	pub body:               String,
	pub category:           DiscussionCategory,
	pub comments:           i64,
	pub created_at:         chrono::DateTime<chrono::offset::Utc>,
	pub html_url:           String,
	pub id:                 i64,
	pub locked:             bool,
	pub node_id:            String,
	pub number:             i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub reactions:          Option<Reactions>,
	pub repository_url:     String,
	pub state:              DiscussionState,
	/// The discussion post's title.
	pub title:              String,
	pub updated_at:         chrono::DateTime<chrono::offset::Utc>,
	pub user:               User,
}
impl From<&Discussion> for Discussion {
	fn from(value: &Discussion) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnswered {
	pub action:       DiscussionAnsweredAction,
	pub answer:       DiscussionAnsweredAnswer,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionAnswered> for DiscussionAnswered {
	fn from(value: &DiscussionAnswered) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionAnsweredAction {
	#[serde(rename = "answered")]
	Answered,
}
impl From<&DiscussionAnsweredAction> for DiscussionAnsweredAction {
	fn from(value: &DiscussionAnsweredAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionAnsweredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Answered => "answered".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionAnsweredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"answered" => Ok(Self::Answered),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionAnsweredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionAnsweredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionAnsweredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionAnsweredAnswer {
	pub author_association:  AuthorAssociation,
	pub body:                String,
	pub child_comment_count: i64,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub discussion_id:       i64,
	pub html_url:            String,
	pub id:                  i64,
	pub node_id:             String,
	pub parent_id:           (),
	pub repository_url:      String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub user:                User,
}
impl From<&DiscussionAnsweredAnswer> for DiscussionAnsweredAnswer {
	fn from(value: &DiscussionAnsweredAnswer) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategory {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub description:   String,
	pub emoji:         String,
	pub id:            i64,
	pub is_answerable: bool,
	pub name:          String,
	pub repository_id: i64,
	pub slug:          String,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
}
impl From<&DiscussionCategory> for DiscussionCategory {
	fn from(value: &DiscussionCategory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChanged {
	pub action:       DiscussionCategoryChangedAction,
	pub changes:      DiscussionCategoryChangedChanges,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionCategoryChanged> for DiscussionCategoryChanged {
	fn from(value: &DiscussionCategoryChanged) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCategoryChangedAction {
	#[serde(rename = "category_changed")]
	CategoryChanged,
}
impl From<&DiscussionCategoryChangedAction> for DiscussionCategoryChangedAction {
	fn from(value: &DiscussionCategoryChangedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionCategoryChangedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::CategoryChanged => "category_changed".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionCategoryChangedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"category_changed" => Ok(Self::CategoryChanged),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionCategoryChangedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionCategoryChangedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionCategoryChangedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChanges {
	pub category: DiscussionCategoryChangedChangesCategory,
}
impl From<&DiscussionCategoryChangedChanges> for DiscussionCategoryChangedChanges {
	fn from(value: &DiscussionCategoryChangedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategory {
	pub from: DiscussionCategoryChangedChangesCategoryFrom,
}
impl From<&DiscussionCategoryChangedChangesCategory> for DiscussionCategoryChangedChangesCategory {
	fn from(value: &DiscussionCategoryChangedChangesCategory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCategoryChangedChangesCategoryFrom {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub description:   String,
	pub emoji:         String,
	pub id:            i64,
	pub is_answerable: bool,
	pub name:          String,
	pub repository_id: i64,
	pub slug:          String,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
}
impl From<&DiscussionCategoryChangedChangesCategoryFrom>
	for DiscussionCategoryChangedChangesCategoryFrom
{
	fn from(value: &DiscussionCategoryChangedChangesCategoryFrom) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreated {
	pub action:       DiscussionCommentCreatedAction,
	pub comment:      DiscussionCommentCreatedComment,
	pub discussion:   Discussion,
	pub installation: InstallationLite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionCommentCreated> for DiscussionCommentCreated {
	fn from(value: &DiscussionCommentCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DiscussionCommentCreatedAction> for DiscussionCommentCreatedAction {
	fn from(value: &DiscussionCommentCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionCommentCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionCommentCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentCreatedComment {
	pub author_association:  AuthorAssociation,
	/// The main text of the comment.
	pub body:                String,
	pub child_comment_count: i64,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub discussion_id:       i64,
	pub html_url:            String,
	pub id:                  i64,
	pub node_id:             String,
	pub parent_id:           Option<i64>,
	pub reactions:           Reactions,
	pub repository_url:      String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub user:                User,
}
impl From<&DiscussionCommentCreatedComment> for DiscussionCommentCreatedComment {
	fn from(value: &DiscussionCommentCreatedComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeleted {
	pub action:       DiscussionCommentDeletedAction,
	pub comment:      DiscussionCommentDeletedComment,
	pub discussion:   Discussion,
	pub installation: InstallationLite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionCommentDeleted> for DiscussionCommentDeleted {
	fn from(value: &DiscussionCommentDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&DiscussionCommentDeletedAction> for DiscussionCommentDeletedAction {
	fn from(value: &DiscussionCommentDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionCommentDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionCommentDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentDeletedComment {
	pub author_association:  AuthorAssociation,
	/// The main text of the comment.
	pub body:                String,
	pub child_comment_count: i64,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub discussion_id:       i64,
	pub html_url:            String,
	pub id:                  i64,
	pub node_id:             String,
	pub parent_id:           Option<i64>,
	pub reactions:           Reactions,
	pub repository_url:      String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub user:                User,
}
impl From<&DiscussionCommentDeletedComment> for DiscussionCommentDeletedComment {
	fn from(value: &DiscussionCommentDeletedComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEdited {
	pub action:       DiscussionCommentEditedAction,
	pub changes:      DiscussionCommentEditedChanges,
	pub comment:      DiscussionCommentEditedComment,
	pub discussion:   Discussion,
	pub installation: InstallationLite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionCommentEdited> for DiscussionCommentEdited {
	fn from(value: &DiscussionCommentEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCommentEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&DiscussionCommentEditedAction> for DiscussionCommentEditedAction {
	fn from(value: &DiscussionCommentEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionCommentEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionCommentEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChanges {
	pub body: DiscussionCommentEditedChangesBody,
}
impl From<&DiscussionCommentEditedChanges> for DiscussionCommentEditedChanges {
	fn from(value: &DiscussionCommentEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedChangesBody {
	pub from: String,
}
impl From<&DiscussionCommentEditedChangesBody> for DiscussionCommentEditedChangesBody {
	fn from(value: &DiscussionCommentEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCommentEditedComment {
	pub author_association:  AuthorAssociation,
	/// The main text of the comment.
	pub body:                String,
	pub child_comment_count: i64,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub discussion_id:       i64,
	pub html_url:            String,
	pub id:                  i64,
	pub node_id:             String,
	pub parent_id:           Option<i64>,
	pub reactions:           Reactions,
	pub repository_url:      String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub user:                User,
}
impl From<&DiscussionCommentEditedComment> for DiscussionCommentEditedComment {
	fn from(value: &DiscussionCommentEditedComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionCommentEvent {
	Created(DiscussionCommentCreated),
	Deleted(DiscussionCommentDeleted),
	Edited(DiscussionCommentEdited),
}
impl From<&DiscussionCommentEvent> for DiscussionCommentEvent {
	fn from(value: &DiscussionCommentEvent) -> Self {
		value.clone()
	}
}
impl From<DiscussionCommentCreated> for DiscussionCommentEvent {
	fn from(value: DiscussionCommentCreated) -> Self {
		Self::Created(value)
	}
}
impl From<DiscussionCommentDeleted> for DiscussionCommentEvent {
	fn from(value: DiscussionCommentDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<DiscussionCommentEdited> for DiscussionCommentEvent {
	fn from(value: DiscussionCommentEdited) -> Self {
		Self::Edited(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionCreated {
	pub action:       DiscussionCreatedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionCreated> for DiscussionCreated {
	fn from(value: &DiscussionCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&DiscussionCreatedAction> for DiscussionCreatedAction {
	fn from(value: &DiscussionCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionDeleted {
	pub action:       DiscussionDeletedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionDeleted> for DiscussionDeleted {
	fn from(value: &DiscussionDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&DiscussionDeletedAction> for DiscussionDeletedAction {
	fn from(value: &DiscussionDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEdited {
	pub action:       DiscussionEditedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<DiscussionEditedChanges>,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionEdited> for DiscussionEdited {
	fn from(value: &DiscussionEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&DiscussionEditedAction> for DiscussionEditedAction {
	fn from(value: &DiscussionEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:  Option<DiscussionEditedChangesBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title: Option<DiscussionEditedChangesTitle>,
}
impl From<&DiscussionEditedChanges> for DiscussionEditedChanges {
	fn from(value: &DiscussionEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesBody {
	pub from: String,
}
impl From<&DiscussionEditedChangesBody> for DiscussionEditedChangesBody {
	fn from(value: &DiscussionEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionEditedChangesTitle {
	pub from: String,
}
impl From<&DiscussionEditedChangesTitle> for DiscussionEditedChangesTitle {
	fn from(value: &DiscussionEditedChangesTitle) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DiscussionEvent {
	Answered(DiscussionAnswered),
	CategoryChanged(DiscussionCategoryChanged),
	Created(DiscussionCreated),
	Deleted(DiscussionDeleted),
	Edited(DiscussionEdited),
	Labeled(DiscussionLabeled),
	Locked(DiscussionLocked),
	Pinned(DiscussionPinned),
	Transferred(DiscussionTransferred),
	Unanswered(DiscussionUnanswered),
	Unlabeled(DiscussionUnlabeled),
	Unlocked(DiscussionUnlocked),
	Unpinned(DiscussionUnpinned),
}
impl From<&DiscussionEvent> for DiscussionEvent {
	fn from(value: &DiscussionEvent) -> Self {
		value.clone()
	}
}
impl From<DiscussionAnswered> for DiscussionEvent {
	fn from(value: DiscussionAnswered) -> Self {
		Self::Answered(value)
	}
}
impl From<DiscussionCategoryChanged> for DiscussionEvent {
	fn from(value: DiscussionCategoryChanged) -> Self {
		Self::CategoryChanged(value)
	}
}
impl From<DiscussionCreated> for DiscussionEvent {
	fn from(value: DiscussionCreated) -> Self {
		Self::Created(value)
	}
}
impl From<DiscussionDeleted> for DiscussionEvent {
	fn from(value: DiscussionDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<DiscussionEdited> for DiscussionEvent {
	fn from(value: DiscussionEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<DiscussionLabeled> for DiscussionEvent {
	fn from(value: DiscussionLabeled) -> Self {
		Self::Labeled(value)
	}
}
impl From<DiscussionLocked> for DiscussionEvent {
	fn from(value: DiscussionLocked) -> Self {
		Self::Locked(value)
	}
}
impl From<DiscussionPinned> for DiscussionEvent {
	fn from(value: DiscussionPinned) -> Self {
		Self::Pinned(value)
	}
}
impl From<DiscussionTransferred> for DiscussionEvent {
	fn from(value: DiscussionTransferred) -> Self {
		Self::Transferred(value)
	}
}
impl From<DiscussionUnanswered> for DiscussionEvent {
	fn from(value: DiscussionUnanswered) -> Self {
		Self::Unanswered(value)
	}
}
impl From<DiscussionUnlabeled> for DiscussionEvent {
	fn from(value: DiscussionUnlabeled) -> Self {
		Self::Unlabeled(value)
	}
}
impl From<DiscussionUnlocked> for DiscussionEvent {
	fn from(value: DiscussionUnlocked) -> Self {
		Self::Unlocked(value)
	}
}
impl From<DiscussionUnpinned> for DiscussionEvent {
	fn from(value: DiscussionUnpinned) -> Self {
		Self::Unpinned(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLabeled {
	pub action:       DiscussionLabeledAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub label:        Label,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionLabeled> for DiscussionLabeled {
	fn from(value: &DiscussionLabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLabeledAction {
	#[serde(rename = "labeled")]
	Labeled,
}
impl From<&DiscussionLabeledAction> for DiscussionLabeledAction {
	fn from(value: &DiscussionLabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionLabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Labeled => "labeled".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionLabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"labeled" => Ok(Self::Labeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionLabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionLabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionLabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionLocked {
	pub action:       DiscussionLockedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionLocked> for DiscussionLocked {
	fn from(value: &DiscussionLocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionLockedAction {
	#[serde(rename = "locked")]
	Locked,
}
impl From<&DiscussionLockedAction> for DiscussionLockedAction {
	fn from(value: &DiscussionLockedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionLockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Locked => "locked".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionLockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"locked" => Ok(Self::Locked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionLockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionLockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionLockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionPinned {
	pub action:       DiscussionPinnedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionPinned> for DiscussionPinned {
	fn from(value: &DiscussionPinned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionPinnedAction {
	#[serde(rename = "pinned")]
	Pinned,
}
impl From<&DiscussionPinnedAction> for DiscussionPinnedAction {
	fn from(value: &DiscussionPinnedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionPinnedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Pinned => "pinned".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionPinnedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pinned" => Ok(Self::Pinned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionPinnedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionPinnedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionPinnedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "locked")]
	Locked,
	#[serde(rename = "converting")]
	Converting,
}
impl From<&DiscussionState> for DiscussionState {
	fn from(value: &DiscussionState) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Locked => "locked".to_string(),
			Self::Converting => "converting".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"locked" => Ok(Self::Locked),
			"converting" => Ok(Self::Converting),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferred {
	pub action:       DiscussionTransferredAction,
	pub changes:      DiscussionTransferredChanges,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionTransferred> for DiscussionTransferred {
	fn from(value: &DiscussionTransferred) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionTransferredAction {
	#[serde(rename = "transferred")]
	Transferred,
}
impl From<&DiscussionTransferredAction> for DiscussionTransferredAction {
	fn from(value: &DiscussionTransferredAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionTransferredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Transferred => "transferred".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionTransferredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"transferred" => Ok(Self::Transferred),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionTransferredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionTransferredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionTransferredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionTransferredChanges {
	pub new_discussion: Discussion,
	pub new_repository: Repository,
}
impl From<&DiscussionTransferredChanges> for DiscussionTransferredChanges {
	fn from(value: &DiscussionTransferredChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnanswered {
	pub action:       DiscussionUnansweredAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub old_answer:   DiscussionUnansweredOldAnswer,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionUnanswered> for DiscussionUnanswered {
	fn from(value: &DiscussionUnanswered) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnansweredAction {
	#[serde(rename = "unanswered")]
	Unanswered,
}
impl From<&DiscussionUnansweredAction> for DiscussionUnansweredAction {
	fn from(value: &DiscussionUnansweredAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionUnansweredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unanswered => "unanswered".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionUnansweredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unanswered" => Ok(Self::Unanswered),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionUnansweredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionUnansweredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionUnansweredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnansweredOldAnswer {
	pub author_association:  AuthorAssociation,
	pub body:                String,
	pub child_comment_count: i64,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub discussion_id:       i64,
	pub html_url:            String,
	pub id:                  i64,
	pub node_id:             String,
	pub parent_id:           (),
	pub repository_url:      String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub user:                User,
}
impl From<&DiscussionUnansweredOldAnswer> for DiscussionUnansweredOldAnswer {
	fn from(value: &DiscussionUnansweredOldAnswer) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlabeled {
	pub action:       DiscussionUnlabeledAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub label:        Label,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionUnlabeled> for DiscussionUnlabeled {
	fn from(value: &DiscussionUnlabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlabeledAction {
	#[serde(rename = "unlabeled")]
	Unlabeled,
}
impl From<&DiscussionUnlabeledAction> for DiscussionUnlabeledAction {
	fn from(value: &DiscussionUnlabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionUnlabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlabeled => "unlabeled".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionUnlabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlabeled" => Ok(Self::Unlabeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnlocked {
	pub action:       DiscussionUnlockedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionUnlocked> for DiscussionUnlocked {
	fn from(value: &DiscussionUnlocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnlockedAction {
	#[serde(rename = "unlocked")]
	Unlocked,
}
impl From<&DiscussionUnlockedAction> for DiscussionUnlockedAction {
	fn from(value: &DiscussionUnlockedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionUnlockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlocked => "unlocked".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionUnlockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlocked" => Ok(Self::Unlocked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionUnlockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DiscussionUnpinned {
	pub action:       DiscussionUnpinnedAction,
	pub discussion:   Discussion,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&DiscussionUnpinned> for DiscussionUnpinned {
	fn from(value: &DiscussionUnpinned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DiscussionUnpinnedAction {
	#[serde(rename = "unpinned")]
	Unpinned,
}
impl From<&DiscussionUnpinnedAction> for DiscussionUnpinnedAction {
	fn from(value: &DiscussionUnpinnedAction) -> Self {
		value.clone()
	}
}
impl ToString for DiscussionUnpinnedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unpinned => "unpinned".to_string(),
		}
	}
}
impl std::str::FromStr for DiscussionUnpinnedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unpinned" => Ok(Self::Unpinned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for DiscussionUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for DiscussionUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for DiscussionUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// A user forks a repository.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForkEvent {
	/// The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.
	pub forkee:       Repository,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ForkEvent> for ForkEvent {
	fn from(value: &ForkEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GithubAppAuthorizationEvent(pub GithubAppAuthorizationRevoked);
impl std::ops::Deref for GithubAppAuthorizationEvent {
	type Target = GithubAppAuthorizationRevoked;

	fn deref(&self) -> &GithubAppAuthorizationRevoked {
		&self.0
	}
}
impl From<GithubAppAuthorizationEvent> for GithubAppAuthorizationRevoked {
	fn from(value: GithubAppAuthorizationEvent) -> Self {
		value.0
	}
}
impl From<&GithubAppAuthorizationEvent> for GithubAppAuthorizationEvent {
	fn from(value: &GithubAppAuthorizationEvent) -> Self {
		value.clone()
	}
}
impl From<GithubAppAuthorizationRevoked> for GithubAppAuthorizationEvent {
	fn from(value: GithubAppAuthorizationRevoked) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubAppAuthorizationRevoked {
	pub action: GithubAppAuthorizationRevokedAction,
	pub sender: User,
}
impl From<&GithubAppAuthorizationRevoked> for GithubAppAuthorizationRevoked {
	fn from(value: &GithubAppAuthorizationRevoked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GithubAppAuthorizationRevokedAction {
	#[serde(rename = "revoked")]
	Revoked,
}
impl From<&GithubAppAuthorizationRevokedAction> for GithubAppAuthorizationRevokedAction {
	fn from(value: &GithubAppAuthorizationRevokedAction) -> Self {
		value.clone()
	}
}
impl ToString for GithubAppAuthorizationRevokedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Revoked => "revoked".to_string(),
		}
	}
}
impl std::str::FromStr for GithubAppAuthorizationRevokedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"revoked" => Ok(Self::Revoked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for GithubAppAuthorizationRevokedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for GithubAppAuthorizationRevokedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for GithubAppAuthorizationRevokedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GithubOrg {
	pub avatar_url:          String,
	#[serde(default)]
	pub email:               (),
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:                Option<String>,
	pub node_id:             String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&GithubOrg> for GithubOrg {
	fn from(value: &GithubOrg) -> Self {
		value.clone()
	}
}
/// A wiki page is created or updated.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The pages that were updated.
	pub pages:        Vec<GollumEventPagesItem>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&GollumEvent> for GollumEvent {
	fn from(value: &GollumEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GollumEventPagesItem {
	/// The action that was performed on the page. Can be `created` or `edited`.
	pub action:    GollumEventPagesItemAction,
	/// Points to the HTML wiki page.
	pub html_url:  String,
	/// The name of the page.
	pub page_name: String,
	/// The latest commit SHA of the page.
	pub sha:       String,
	pub summary:   (),
	/// The current page title.
	pub title:     String,
}
impl From<&GollumEventPagesItem> for GollumEventPagesItem {
	fn from(value: &GollumEventPagesItem) -> Self {
		value.clone()
	}
}
/// The action that was performed on the page. Can be `created` or `edited`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GollumEventPagesItemAction {
	#[serde(rename = "created")]
	Created,
	#[serde(rename = "edited")]
	Edited,
}
impl From<&GollumEventPagesItemAction> for GollumEventPagesItemAction {
	fn from(value: &GollumEventPagesItemAction) -> Self {
		value.clone()
	}
}
impl ToString for GollumEventPagesItemAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for GollumEventPagesItemAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for GollumEventPagesItemAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for GollumEventPagesItemAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for GollumEventPagesItemAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The GitHub App installation.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Installation {
	pub access_tokens_url: String,
	pub account: User,
	pub app_id: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub app_slug: Option<String>,
	pub created_at: InstallationCreatedAt,
	pub events: Vec<InstallationEventsItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub has_multiple_single_files: Option<bool>,
	pub html_url: String,
	/// The ID of the installation.
	pub id: i64,
	pub permissions: InstallationPermissions,
	pub repositories_url: String,
	/// Describe whether all repositories have been selected or there's a
	/// selection involved
	pub repository_selection: InstallationRepositorySelection,
	pub single_file_name: Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub single_file_paths: Vec<String>,
	pub suspended_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	pub suspended_by: Option<User>,
	/// The ID of the user or organization this token is being scoped to.
	pub target_id: i64,
	pub target_type: InstallationTargetType,
	pub updated_at: InstallationUpdatedAt,
}
impl From<&Installation> for Installation {
	fn from(value: &Installation) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreated {
	pub action:       InstallationCreatedAction,
	pub installation: Installation,
	/// An array of repository objects that the installation can access.
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub repositories: Vec<InstallationCreatedRepositoriesItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub requester:    Option<User>,
	pub sender:       User,
}
impl From<&InstallationCreated> for InstallationCreated {
	fn from(value: &InstallationCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&InstallationCreatedAction> for InstallationCreatedAction {
	fn from(value: &InstallationCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationCreatedAt {
	Variant0(chrono::DateTime<chrono::offset::Utc>),
	Variant1(i64),
}
impl From<&InstallationCreatedAt> for InstallationCreatedAt {
	fn from(value: &InstallationCreatedAt) -> Self {
		value.clone()
	}
}
impl std::str::FromStr for InstallationCreatedAt {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		if let Ok(v) = value.parse() {
			Ok(Self::Variant0(v))
		} else if let Ok(v) = value.parse() {
			Ok(Self::Variant1(v))
		} else {
			Err("string conversion failed for all variants")
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationCreatedAt {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationCreatedAt {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationCreatedAt {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl ToString for InstallationCreatedAt {
	fn to_string(&self) -> String {
		match self {
			Self::Variant0(x) => x.to_string(),
			Self::Variant1(x) => x.to_string(),
		}
	}
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationCreatedAt {
	fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
		Self::Variant0(value)
	}
}
impl From<i64> for InstallationCreatedAt {
	fn from(value: i64) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationCreatedRepositoriesItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationCreatedRepositoriesItem> for InstallationCreatedRepositoriesItem {
	fn from(value: &InstallationCreatedRepositoriesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeleted {
	pub action:       InstallationDeletedAction,
	pub installation: Installation,
	/// An array of repository objects that the installation can access.
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub repositories: Vec<InstallationDeletedRepositoriesItem>,
	#[serde(default)]
	pub requester:    (),
	pub sender:       User,
}
impl From<&InstallationDeleted> for InstallationDeleted {
	fn from(value: &InstallationDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&InstallationDeletedAction> for InstallationDeletedAction {
	fn from(value: &InstallationDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationDeletedRepositoriesItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationDeletedRepositoriesItem> for InstallationDeletedRepositoriesItem {
	fn from(value: &InstallationDeletedRepositoriesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationEvent {
	Created(InstallationCreated),
	Deleted(InstallationDeleted),
	NewPermissionsAccepted(InstallationNewPermissionsAccepted),
	Suspend(InstallationSuspend),
	Unsuspend(InstallationUnsuspend),
}
impl From<&InstallationEvent> for InstallationEvent {
	fn from(value: &InstallationEvent) -> Self {
		value.clone()
	}
}
impl From<InstallationCreated> for InstallationEvent {
	fn from(value: InstallationCreated) -> Self {
		Self::Created(value)
	}
}
impl From<InstallationDeleted> for InstallationEvent {
	fn from(value: InstallationDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<InstallationNewPermissionsAccepted> for InstallationEvent {
	fn from(value: InstallationNewPermissionsAccepted) -> Self {
		Self::NewPermissionsAccepted(value)
	}
}
impl From<InstallationSuspend> for InstallationEvent {
	fn from(value: InstallationSuspend) -> Self {
		Self::Suspend(value)
	}
}
impl From<InstallationUnsuspend> for InstallationEvent {
	fn from(value: InstallationUnsuspend) -> Self {
		Self::Unsuspend(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationEventsItem {
	#[serde(rename = "branch_protection_rule")]
	BranchProtectionRule,
	#[serde(rename = "check_run")]
	CheckRun,
	#[serde(rename = "check_suite")]
	CheckSuite,
	#[serde(rename = "code_scanning_alert")]
	CodeScanningAlert,
	#[serde(rename = "commit_comment")]
	CommitComment,
	#[serde(rename = "content_reference")]
	ContentReference,
	#[serde(rename = "create")]
	Create,
	#[serde(rename = "delete")]
	Delete,
	#[serde(rename = "deployment")]
	Deployment,
	#[serde(rename = "deployment_review")]
	DeploymentReview,
	#[serde(rename = "deployment_status")]
	DeploymentStatus,
	#[serde(rename = "deploy_key")]
	DeployKey,
	#[serde(rename = "discussion")]
	Discussion,
	#[serde(rename = "discussion_comment")]
	DiscussionComment,
	#[serde(rename = "fork")]
	Fork,
	#[serde(rename = "gollum")]
	Gollum,
	#[serde(rename = "issues")]
	Issues,
	#[serde(rename = "issue_comment")]
	IssueComment,
	#[serde(rename = "label")]
	Label,
	#[serde(rename = "member")]
	Member,
	#[serde(rename = "membership")]
	Membership,
	#[serde(rename = "merge_queue_entry")]
	MergeQueueEntry,
	#[serde(rename = "milestone")]
	Milestone,
	#[serde(rename = "organization")]
	Organization,
	#[serde(rename = "org_block")]
	OrgBlock,
	#[serde(rename = "page_build")]
	PageBuild,
	#[serde(rename = "project")]
	Project,
	#[serde(rename = "projects_v2_item")]
	ProjectsV2Item,
	#[serde(rename = "project_card")]
	ProjectCard,
	#[serde(rename = "project_column")]
	ProjectColumn,
	#[serde(rename = "public")]
	Public,
	#[serde(rename = "pull_request")]
	PullRequest,
	#[serde(rename = "pull_request_review")]
	PullRequestReview,
	#[serde(rename = "pull_request_review_comment")]
	PullRequestReviewComment,
	#[serde(rename = "pull_request_review_thread")]
	PullRequestReviewThread,
	#[serde(rename = "push")]
	Push,
	#[serde(rename = "registry_package")]
	RegistryPackage,
	#[serde(rename = "release")]
	Release,
	#[serde(rename = "repository")]
	Repository,
	#[serde(rename = "repository_dispatch")]
	RepositoryDispatch,
	#[serde(rename = "secret_scanning_alert")]
	SecretScanningAlert,
	#[serde(rename = "secret_scanning_alert_location")]
	SecretScanningAlertLocation,
	#[serde(rename = "star")]
	Star,
	#[serde(rename = "status")]
	Status,
	#[serde(rename = "team")]
	Team,
	#[serde(rename = "team_add")]
	TeamAdd,
	#[serde(rename = "watch")]
	Watch,
	#[serde(rename = "workflow_dispatch")]
	WorkflowDispatch,
	#[serde(rename = "workflow_job")]
	WorkflowJob,
	#[serde(rename = "workflow_run")]
	WorkflowRun,
}
impl From<&InstallationEventsItem> for InstallationEventsItem {
	fn from(value: &InstallationEventsItem) -> Self {
		value.clone()
	}
}
impl ToString for InstallationEventsItem {
	fn to_string(&self) -> String {
		match *self {
			Self::BranchProtectionRule => "branch_protection_rule".to_string(),
			Self::CheckRun => "check_run".to_string(),
			Self::CheckSuite => "check_suite".to_string(),
			Self::CodeScanningAlert => "code_scanning_alert".to_string(),
			Self::CommitComment => "commit_comment".to_string(),
			Self::ContentReference => "content_reference".to_string(),
			Self::Create => "create".to_string(),
			Self::Delete => "delete".to_string(),
			Self::Deployment => "deployment".to_string(),
			Self::DeploymentReview => "deployment_review".to_string(),
			Self::DeploymentStatus => "deployment_status".to_string(),
			Self::DeployKey => "deploy_key".to_string(),
			Self::Discussion => "discussion".to_string(),
			Self::DiscussionComment => "discussion_comment".to_string(),
			Self::Fork => "fork".to_string(),
			Self::Gollum => "gollum".to_string(),
			Self::Issues => "issues".to_string(),
			Self::IssueComment => "issue_comment".to_string(),
			Self::Label => "label".to_string(),
			Self::Member => "member".to_string(),
			Self::Membership => "membership".to_string(),
			Self::MergeQueueEntry => "merge_queue_entry".to_string(),
			Self::Milestone => "milestone".to_string(),
			Self::Organization => "organization".to_string(),
			Self::OrgBlock => "org_block".to_string(),
			Self::PageBuild => "page_build".to_string(),
			Self::Project => "project".to_string(),
			Self::ProjectsV2Item => "projects_v2_item".to_string(),
			Self::ProjectCard => "project_card".to_string(),
			Self::ProjectColumn => "project_column".to_string(),
			Self::Public => "public".to_string(),
			Self::PullRequest => "pull_request".to_string(),
			Self::PullRequestReview => "pull_request_review".to_string(),
			Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
			Self::PullRequestReviewThread => "pull_request_review_thread".to_string(),
			Self::Push => "push".to_string(),
			Self::RegistryPackage => "registry_package".to_string(),
			Self::Release => "release".to_string(),
			Self::Repository => "repository".to_string(),
			Self::RepositoryDispatch => "repository_dispatch".to_string(),
			Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
			Self::SecretScanningAlertLocation => "secret_scanning_alert_location".to_string(),
			Self::Star => "star".to_string(),
			Self::Status => "status".to_string(),
			Self::Team => "team".to_string(),
			Self::TeamAdd => "team_add".to_string(),
			Self::Watch => "watch".to_string(),
			Self::WorkflowDispatch => "workflow_dispatch".to_string(),
			Self::WorkflowJob => "workflow_job".to_string(),
			Self::WorkflowRun => "workflow_run".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationEventsItem {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"branch_protection_rule" => Ok(Self::BranchProtectionRule),
			"check_run" => Ok(Self::CheckRun),
			"check_suite" => Ok(Self::CheckSuite),
			"code_scanning_alert" => Ok(Self::CodeScanningAlert),
			"commit_comment" => Ok(Self::CommitComment),
			"content_reference" => Ok(Self::ContentReference),
			"create" => Ok(Self::Create),
			"delete" => Ok(Self::Delete),
			"deployment" => Ok(Self::Deployment),
			"deployment_review" => Ok(Self::DeploymentReview),
			"deployment_status" => Ok(Self::DeploymentStatus),
			"deploy_key" => Ok(Self::DeployKey),
			"discussion" => Ok(Self::Discussion),
			"discussion_comment" => Ok(Self::DiscussionComment),
			"fork" => Ok(Self::Fork),
			"gollum" => Ok(Self::Gollum),
			"issues" => Ok(Self::Issues),
			"issue_comment" => Ok(Self::IssueComment),
			"label" => Ok(Self::Label),
			"member" => Ok(Self::Member),
			"membership" => Ok(Self::Membership),
			"merge_queue_entry" => Ok(Self::MergeQueueEntry),
			"milestone" => Ok(Self::Milestone),
			"organization" => Ok(Self::Organization),
			"org_block" => Ok(Self::OrgBlock),
			"page_build" => Ok(Self::PageBuild),
			"project" => Ok(Self::Project),
			"projects_v2_item" => Ok(Self::ProjectsV2Item),
			"project_card" => Ok(Self::ProjectCard),
			"project_column" => Ok(Self::ProjectColumn),
			"public" => Ok(Self::Public),
			"pull_request" => Ok(Self::PullRequest),
			"pull_request_review" => Ok(Self::PullRequestReview),
			"pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
			"pull_request_review_thread" => Ok(Self::PullRequestReviewThread),
			"push" => Ok(Self::Push),
			"registry_package" => Ok(Self::RegistryPackage),
			"release" => Ok(Self::Release),
			"repository" => Ok(Self::Repository),
			"repository_dispatch" => Ok(Self::RepositoryDispatch),
			"secret_scanning_alert" => Ok(Self::SecretScanningAlert),
			"secret_scanning_alert_location" => Ok(Self::SecretScanningAlertLocation),
			"star" => Ok(Self::Star),
			"status" => Ok(Self::Status),
			"team" => Ok(Self::Team),
			"team_add" => Ok(Self::TeamAdd),
			"watch" => Ok(Self::Watch),
			"workflow_dispatch" => Ok(Self::WorkflowDispatch),
			"workflow_job" => Ok(Self::WorkflowJob),
			"workflow_run" => Ok(Self::WorkflowRun),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationEventsItem {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationEventsItem {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationEventsItem {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Installation
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationLite {
	/// The ID of the installation.
	pub id:      i64,
	pub node_id: String,
}
impl From<&InstallationLite> for InstallationLite {
	fn from(value: &InstallationLite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAccepted {
	pub action:       InstallationNewPermissionsAcceptedAction,
	pub installation: Installation,
	/// An array of repository objects that the installation can access.
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub repositories: Vec<InstallationNewPermissionsAcceptedRepositoriesItem>,
	#[serde(default)]
	pub requester:    (),
	pub sender:       User,
}
impl From<&InstallationNewPermissionsAccepted> for InstallationNewPermissionsAccepted {
	fn from(value: &InstallationNewPermissionsAccepted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationNewPermissionsAcceptedAction {
	#[serde(rename = "new_permissions_accepted")]
	NewPermissionsAccepted,
}
impl From<&InstallationNewPermissionsAcceptedAction> for InstallationNewPermissionsAcceptedAction {
	fn from(value: &InstallationNewPermissionsAcceptedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationNewPermissionsAcceptedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::NewPermissionsAccepted => "new_permissions_accepted".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationNewPermissionsAcceptedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"new_permissions_accepted" => Ok(Self::NewPermissionsAccepted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationNewPermissionsAcceptedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationNewPermissionsAcceptedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationNewPermissionsAcceptedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationNewPermissionsAcceptedRepositoriesItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationNewPermissionsAcceptedRepositoriesItem>
	for InstallationNewPermissionsAcceptedRepositoriesItem
{
	fn from(value: &InstallationNewPermissionsAcceptedRepositoriesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationPermissions {
	/// The level of permission granted to the access token for GitHub Actions
	/// workflows, workflow runs, and artifacts.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub actions: Option<InstallationPermissionsActions>,
	/// The level of permission granted to the access token for repository
	/// creation, deletion, settings, teams, and collaborators creation.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub administration: Option<InstallationPermissionsAdministration>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub blocking: Option<InstallationPermissionsBlocking>,
	/// The level of permission granted to the access token for checks on code.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub checks: Option<InstallationPermissionsChecks>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub content_references: Option<InstallationPermissionsContentReferences>,
	/// The level of permission granted to the access token for repository
	/// contents, commits, branches, downloads, releases, and merges.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub contents: Option<InstallationPermissionsContents>,
	/// The level of permission granted to the access token for deployments and
	/// deployment statuses.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deployments: Option<InstallationPermissionsDeployments>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub discussions: Option<InstallationPermissionsDiscussions>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub emails: Option<InstallationPermissionsEmails>,
	/// The level of permission granted to the access token for managing
	/// repository environments.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub environments: Option<InstallationPermissionsEnvironments>,
	/// The level of permission granted to the access token for issues and
	/// related comments, assignees, labels, and milestones.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub issues: Option<InstallationPermissionsIssues>,
	/// The level of permission granted to the access token for organization
	/// teams and members.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub members: Option<InstallationPermissionsMembers>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub merge_queues: Option<InstallationPermissionsMergeQueues>,
	/// The level of permission granted to the access token to search
	/// repositories, list collaborators, and access repository metadata.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub metadata: Option<InstallationPermissionsMetadata>,
	/// The level of permission granted to the access token to manage access to
	/// an organization.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_administration: Option<InstallationPermissionsOrganizationAdministration>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_events: Option<InstallationPermissionsOrganizationEvents>,
	/// The level of permission granted to the access token to manage the
	/// post-receive hooks for an organization.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_hooks: Option<InstallationPermissionsOrganizationHooks>,
	/// The level of permission granted to the access token for organization
	/// packages published to GitHub Packages.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_packages: Option<InstallationPermissionsOrganizationPackages>,
	/// The level of permission granted to the access token for viewing an
	/// organization's plan.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_plan: Option<InstallationPermissionsOrganizationPlan>,
	/// The level of permission granted to the access token to manage
	/// organization projects and projects beta (where available).
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_projects: Option<InstallationPermissionsOrganizationProjects>,
	/// The level of permission granted to the access token to manage
	/// organization secrets.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_secrets: Option<InstallationPermissionsOrganizationSecrets>,
	/// The level of permission granted to the access token to view and manage
	/// GitHub Actions self-hosted runners available to an organization.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_self_hosted_runners:
		Option<InstallationPermissionsOrganizationSelfHostedRunners>,
	/// The level of permission granted to the access token to view and manage
	/// users blocked by the organization.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization_user_blocking: Option<InstallationPermissionsOrganizationUserBlocking>,
	/// The level of permission granted to the access token for packages
	/// published to GitHub Packages.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub packages: Option<InstallationPermissionsPackages>,
	/// The level of permission granted to the access token to retrieve Pages
	/// statuses, configuration, and builds, as well as create new builds.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pages: Option<InstallationPermissionsPages>,
	/// The level of permission granted to the access token for pull requests
	/// and related comments, assignees, labels, milestones, and merges.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pull_requests: Option<InstallationPermissionsPullRequests>,
	/// The level of permission granted to the access token to manage the
	/// post-receive hooks for a repository.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository_hooks: Option<InstallationPermissionsRepositoryHooks>,
	/// The level of permission granted to the access token to manage repository
	/// projects, columns, and cards.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository_projects: Option<InstallationPermissionsRepositoryProjects>,
	/// The level of permission granted to the access token to view and manage
	/// secret scanning alerts.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secret_scanning_alerts: Option<InstallationPermissionsSecretScanningAlerts>,
	/// The level of permission granted to the access token to manage repository
	/// secrets.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secrets: Option<InstallationPermissionsSecrets>,
	/// The level of permission granted to the access token to view and manage
	/// security events like code scanning alerts.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub security_events: Option<InstallationPermissionsSecurityEvents>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub security_scanning_alert: Option<InstallationPermissionsSecurityScanningAlert>,
	/// The level of permission granted to the access token to manage just a
	/// single file.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub single_file: Option<InstallationPermissionsSingleFile>,
	/// The level of permission granted to the access token for commit statuses.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub statuses: Option<InstallationPermissionsStatuses>,
	/// The level of permission granted to the access token to manage team
	/// discussions and related comments.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub team_discussions: Option<InstallationPermissionsTeamDiscussions>,
	/// The level of permission granted to the access token to manage Dependabot
	/// alerts.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub vulnerability_alerts: Option<InstallationPermissionsVulnerabilityAlerts>,
	/// The level of permission granted to the access token to update GitHub
	/// Actions workflow files.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub workflows: Option<InstallationPermissionsWorkflows>,
}
impl From<&InstallationPermissions> for InstallationPermissions {
	fn from(value: &InstallationPermissions) -> Self {
		value.clone()
	}
}
/// The level of permission granted to the access token for GitHub Actions
/// workflows, workflow runs, and artifacts.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsActions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsActions> for InstallationPermissionsActions {
	fn from(value: &InstallationPermissionsActions) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsActions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsActions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsActions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsActions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsActions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for repository creation,
/// deletion, settings, teams, and collaborators creation.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsAdministration {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsAdministration> for InstallationPermissionsAdministration {
	fn from(value: &InstallationPermissionsAdministration) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsAdministration {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsAdministration {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsAdministration {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsBlocking {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsBlocking> for InstallationPermissionsBlocking {
	fn from(value: &InstallationPermissionsBlocking) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsBlocking {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsBlocking {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsBlocking {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for checks on code.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsChecks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsChecks> for InstallationPermissionsChecks {
	fn from(value: &InstallationPermissionsChecks) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsChecks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsChecks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsChecks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContentReferences {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsContentReferences> for InstallationPermissionsContentReferences {
	fn from(value: &InstallationPermissionsContentReferences) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsContentReferences {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsContentReferences {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsContentReferences {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for repository contents,
/// commits, branches, downloads, releases, and merges.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsContents {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsContents> for InstallationPermissionsContents {
	fn from(value: &InstallationPermissionsContents) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsContents {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsContents {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsContents {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsContents {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsContents {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for deployments and
/// deployment statuses.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDeployments {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsDeployments> for InstallationPermissionsDeployments {
	fn from(value: &InstallationPermissionsDeployments) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsDeployments {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsDeployments {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsDeployments {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsDiscussions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsDiscussions> for InstallationPermissionsDiscussions {
	fn from(value: &InstallationPermissionsDiscussions) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsDiscussions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsDiscussions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsDiscussions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEmails {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsEmails> for InstallationPermissionsEmails {
	fn from(value: &InstallationPermissionsEmails) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsEmails {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsEmails {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsEmails {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for managing repository
/// environments.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsEnvironments {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsEnvironments> for InstallationPermissionsEnvironments {
	fn from(value: &InstallationPermissionsEnvironments) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsEnvironments {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsEnvironments {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsEnvironments {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for issues and related
/// comments, assignees, labels, and milestones.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsIssues {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsIssues> for InstallationPermissionsIssues {
	fn from(value: &InstallationPermissionsIssues) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsIssues {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsIssues {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsIssues {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for organization teams
/// and members.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMembers {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsMembers> for InstallationPermissionsMembers {
	fn from(value: &InstallationPermissionsMembers) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsMembers {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsMembers {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsMembers {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMergeQueues {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsMergeQueues> for InstallationPermissionsMergeQueues {
	fn from(value: &InstallationPermissionsMergeQueues) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsMergeQueues {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsMergeQueues {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsMergeQueues {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to search repositories,
/// list collaborators, and access repository metadata.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsMetadata {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsMetadata> for InstallationPermissionsMetadata {
	fn from(value: &InstallationPermissionsMetadata) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsMetadata {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsMetadata {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsMetadata {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage access to an
/// organization.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationAdministration {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationAdministration>
	for InstallationPermissionsOrganizationAdministration
{
	fn from(value: &InstallationPermissionsOrganizationAdministration) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationAdministration {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationAdministration {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationAdministration {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationEvents {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationEvents>
	for InstallationPermissionsOrganizationEvents
{
	fn from(value: &InstallationPermissionsOrganizationEvents) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationEvents {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationEvents {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationEvents {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationEvents {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationEvents {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage the
/// post-receive hooks for an organization.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationHooks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationHooks> for InstallationPermissionsOrganizationHooks {
	fn from(value: &InstallationPermissionsOrganizationHooks) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationHooks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationHooks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationHooks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for organization
/// packages published to GitHub Packages.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPackages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationPackages>
	for InstallationPermissionsOrganizationPackages
{
	fn from(value: &InstallationPermissionsOrganizationPackages) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationPackages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationPackages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPackages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for viewing an
/// organization's plan.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationPlan {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationPlan> for InstallationPermissionsOrganizationPlan {
	fn from(value: &InstallationPermissionsOrganizationPlan) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationPlan {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationPlan {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationPlan {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage organization
/// projects and projects beta (where available).
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationProjects {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationProjects>
	for InstallationPermissionsOrganizationProjects
{
	fn from(value: &InstallationPermissionsOrganizationProjects) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationProjects {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationProjects {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationProjects {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage organization
/// secrets.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSecrets {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationSecrets>
	for InstallationPermissionsOrganizationSecrets
{
	fn from(value: &InstallationPermissionsOrganizationSecrets) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationSecrets {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationSecrets {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSecrets {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to view and manage
/// GitHub Actions self-hosted runners available to an organization.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationSelfHostedRunners {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationSelfHostedRunners>
	for InstallationPermissionsOrganizationSelfHostedRunners
{
	fn from(value: &InstallationPermissionsOrganizationSelfHostedRunners) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationSelfHostedRunners {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationSelfHostedRunners {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationSelfHostedRunners {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to view and manage users
/// blocked by the organization.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsOrganizationUserBlocking {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsOrganizationUserBlocking>
	for InstallationPermissionsOrganizationUserBlocking
{
	fn from(value: &InstallationPermissionsOrganizationUserBlocking) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsOrganizationUserBlocking {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsOrganizationUserBlocking {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsOrganizationUserBlocking {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for packages published
/// to GitHub Packages.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPackages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsPackages> for InstallationPermissionsPackages {
	fn from(value: &InstallationPermissionsPackages) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsPackages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsPackages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsPackages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to retrieve Pages
/// statuses, configuration, and builds, as well as create new builds.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPages {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsPages> for InstallationPermissionsPages {
	fn from(value: &InstallationPermissionsPages) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsPages {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsPages {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPages {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPages {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsPages {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for pull requests and
/// related comments, assignees, labels, milestones, and merges.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsPullRequests {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsPullRequests> for InstallationPermissionsPullRequests {
	fn from(value: &InstallationPermissionsPullRequests) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsPullRequests {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsPullRequests {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsPullRequests {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage the
/// post-receive hooks for a repository.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryHooks {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsRepositoryHooks> for InstallationPermissionsRepositoryHooks {
	fn from(value: &InstallationPermissionsRepositoryHooks) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsRepositoryHooks {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsRepositoryHooks {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryHooks {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage repository
/// projects, columns, and cards.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsRepositoryProjects {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsRepositoryProjects>
	for InstallationPermissionsRepositoryProjects
{
	fn from(value: &InstallationPermissionsRepositoryProjects) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsRepositoryProjects {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsRepositoryProjects {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsRepositoryProjects {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to view and manage
/// secret scanning alerts.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecretScanningAlerts {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsSecretScanningAlerts>
	for InstallationPermissionsSecretScanningAlerts
{
	fn from(value: &InstallationPermissionsSecretScanningAlerts) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsSecretScanningAlerts {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsSecretScanningAlerts {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecretScanningAlerts {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage repository
/// secrets.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecrets {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsSecrets> for InstallationPermissionsSecrets {
	fn from(value: &InstallationPermissionsSecrets) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsSecrets {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsSecrets {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecrets {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to view and manage
/// security events like code scanning alerts.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityEvents {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsSecurityEvents> for InstallationPermissionsSecurityEvents {
	fn from(value: &InstallationPermissionsSecurityEvents) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsSecurityEvents {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsSecurityEvents {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityEvents {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSecurityScanningAlert {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsSecurityScanningAlert>
	for InstallationPermissionsSecurityScanningAlert
{
	fn from(value: &InstallationPermissionsSecurityScanningAlert) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsSecurityScanningAlert {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsSecurityScanningAlert {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsSecurityScanningAlert {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage just a single
/// file.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsSingleFile {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsSingleFile> for InstallationPermissionsSingleFile {
	fn from(value: &InstallationPermissionsSingleFile) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsSingleFile {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsSingleFile {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsSingleFile {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token for commit statuses.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsStatuses {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsStatuses> for InstallationPermissionsStatuses {
	fn from(value: &InstallationPermissionsStatuses) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsStatuses {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsStatuses {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsStatuses {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage team
/// discussions and related comments.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsTeamDiscussions {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsTeamDiscussions> for InstallationPermissionsTeamDiscussions {
	fn from(value: &InstallationPermissionsTeamDiscussions) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsTeamDiscussions {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsTeamDiscussions {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsTeamDiscussions {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to manage Dependabot
/// alerts.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsVulnerabilityAlerts {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsVulnerabilityAlerts>
	for InstallationPermissionsVulnerabilityAlerts
{
	fn from(value: &InstallationPermissionsVulnerabilityAlerts) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsVulnerabilityAlerts {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsVulnerabilityAlerts {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsVulnerabilityAlerts {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level of permission granted to the access token to update GitHub Actions
/// workflow files.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationPermissionsWorkflows {
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "write")]
	Write,
}
impl From<&InstallationPermissionsWorkflows> for InstallationPermissionsWorkflows {
	fn from(value: &InstallationPermissionsWorkflows) -> Self {
		value.clone()
	}
}
impl ToString for InstallationPermissionsWorkflows {
	fn to_string(&self) -> String {
		match *self {
			Self::Read => "read".to_string(),
			Self::Write => "write".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationPermissionsWorkflows {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"read" => Ok(Self::Read),
			"write" => Ok(Self::Write),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationPermissionsWorkflows {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAdded {
	pub action:               InstallationRepositoriesAddedAction,
	pub installation:         Installation,
	/// An array of repository objects, which were added to the installation.
	pub repositories_added:   Vec<InstallationRepositoriesAddedRepositoriesAddedItem>,
	/// An array of repository objects, which were removed from the
	/// installation.
	pub repositories_removed: Vec<InstallationRepositoriesAddedRepositoriesRemovedItem>,
	/// Describe whether all repositories have been selected or there's a
	/// selection involved
	pub repository_selection: InstallationRepositoriesAddedRepositorySelection,
	pub requester:            Option<User>,
	pub sender:               User,
}
impl From<&InstallationRepositoriesAdded> for InstallationRepositoriesAdded {
	fn from(value: &InstallationRepositoriesAdded) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedAction {
	#[serde(rename = "added")]
	Added,
}
impl From<&InstallationRepositoriesAddedAction> for InstallationRepositoriesAddedAction {
	fn from(value: &InstallationRepositoriesAddedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationRepositoriesAddedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Added => "added".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationRepositoriesAddedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"added" => Ok(Self::Added),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesAddedItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationRepositoriesAddedRepositoriesAddedItem>
	for InstallationRepositoriesAddedRepositoriesAddedItem
{
	fn from(value: &InstallationRepositoriesAddedRepositoriesAddedItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesAddedRepositoriesRemovedItem {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub full_name: Option<String>,
	/// Unique identifier of the repository
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub id:        Option<i64>,
	/// The name of the repository.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:      Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_id:   Option<String>,
	/// Whether the repository is private or public.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub private:   Option<bool>,
}
impl From<&InstallationRepositoriesAddedRepositoriesRemovedItem>
	for InstallationRepositoriesAddedRepositoriesRemovedItem
{
	fn from(value: &InstallationRepositoriesAddedRepositoriesRemovedItem) -> Self {
		value.clone()
	}
}
/// Describe whether all repositories have been selected or there's a selection
/// involved
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesAddedRepositorySelection {
	#[serde(rename = "all")]
	All,
	#[serde(rename = "selected")]
	Selected,
}
impl From<&InstallationRepositoriesAddedRepositorySelection>
	for InstallationRepositoriesAddedRepositorySelection
{
	fn from(value: &InstallationRepositoriesAddedRepositorySelection) -> Self {
		value.clone()
	}
}
impl ToString for InstallationRepositoriesAddedRepositorySelection {
	fn to_string(&self) -> String {
		match *self {
			Self::All => "all".to_string(),
			Self::Selected => "selected".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationRepositoriesAddedRepositorySelection {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"all" => Ok(Self::All),
			"selected" => Ok(Self::Selected),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesAddedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesAddedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationRepositoriesAddedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationRepositoriesEvent {
	Added(InstallationRepositoriesAdded),
	Removed(InstallationRepositoriesRemoved),
}
impl From<&InstallationRepositoriesEvent> for InstallationRepositoriesEvent {
	fn from(value: &InstallationRepositoriesEvent) -> Self {
		value.clone()
	}
}
impl From<InstallationRepositoriesAdded> for InstallationRepositoriesEvent {
	fn from(value: InstallationRepositoriesAdded) -> Self {
		Self::Added(value)
	}
}
impl From<InstallationRepositoriesRemoved> for InstallationRepositoriesEvent {
	fn from(value: InstallationRepositoriesRemoved) -> Self {
		Self::Removed(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemoved {
	pub action:               InstallationRepositoriesRemovedAction,
	pub installation:         Installation,
	/// An array of repository objects, which were added to the installation.
	pub repositories_added:   Vec<InstallationRepositoriesRemovedRepositoriesAddedItem>,
	/// An array of repository objects, which were removed from the
	/// installation.
	pub repositories_removed: Vec<InstallationRepositoriesRemovedRepositoriesRemovedItem>,
	/// Describe whether all repositories have been selected or there's a
	/// selection involved
	pub repository_selection: InstallationRepositoriesRemovedRepositorySelection,
	pub requester:            Option<User>,
	pub sender:               User,
}
impl From<&InstallationRepositoriesRemoved> for InstallationRepositoriesRemoved {
	fn from(value: &InstallationRepositoriesRemoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedAction {
	#[serde(rename = "removed")]
	Removed,
}
impl From<&InstallationRepositoriesRemovedAction> for InstallationRepositoriesRemovedAction {
	fn from(value: &InstallationRepositoriesRemovedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationRepositoriesRemovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Removed => "removed".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationRepositoriesRemovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"removed" => Ok(Self::Removed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesAddedItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesAddedItem>
	for InstallationRepositoriesRemovedRepositoriesAddedItem
{
	fn from(value: &InstallationRepositoriesRemovedRepositoriesAddedItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationRepositoriesRemovedRepositoriesRemovedItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationRepositoriesRemovedRepositoriesRemovedItem>
	for InstallationRepositoriesRemovedRepositoriesRemovedItem
{
	fn from(value: &InstallationRepositoriesRemovedRepositoriesRemovedItem) -> Self {
		value.clone()
	}
}
/// Describe whether all repositories have been selected or there's a selection
/// involved
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositoriesRemovedRepositorySelection {
	#[serde(rename = "all")]
	All,
	#[serde(rename = "selected")]
	Selected,
}
impl From<&InstallationRepositoriesRemovedRepositorySelection>
	for InstallationRepositoriesRemovedRepositorySelection
{
	fn from(value: &InstallationRepositoriesRemovedRepositorySelection) -> Self {
		value.clone()
	}
}
impl ToString for InstallationRepositoriesRemovedRepositorySelection {
	fn to_string(&self) -> String {
		match *self {
			Self::All => "all".to_string(),
			Self::Selected => "selected".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationRepositoriesRemovedRepositorySelection {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"all" => Ok(Self::All),
			"selected" => Ok(Self::Selected),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationRepositoriesRemovedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationRepositoriesRemovedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationRepositoriesRemovedRepositorySelection {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Describe whether all repositories have been selected or there's a selection
/// involved
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationRepositorySelection {
	#[serde(rename = "all")]
	All,
	#[serde(rename = "selected")]
	Selected,
}
impl From<&InstallationRepositorySelection> for InstallationRepositorySelection {
	fn from(value: &InstallationRepositorySelection) -> Self {
		value.clone()
	}
}
impl ToString for InstallationRepositorySelection {
	fn to_string(&self) -> String {
		match *self {
			Self::All => "all".to_string(),
			Self::Selected => "selected".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationRepositorySelection {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"all" => Ok(Self::All),
			"selected" => Ok(Self::Selected),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationRepositorySelection {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationRepositorySelection {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspend {
	pub action:       InstallationSuspendAction,
	pub installation: Installation,
	/// An array of repository objects that the installation can access.
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub repositories: Vec<InstallationSuspendRepositoriesItem>,
	#[serde(default)]
	pub requester:    (),
	pub sender:       User,
}
impl From<&InstallationSuspend> for InstallationSuspend {
	fn from(value: &InstallationSuspend) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationSuspendAction {
	#[serde(rename = "suspend")]
	Suspend,
}
impl From<&InstallationSuspendAction> for InstallationSuspendAction {
	fn from(value: &InstallationSuspendAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationSuspendAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Suspend => "suspend".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationSuspendAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"suspend" => Ok(Self::Suspend),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationSuspendAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationSuspendAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationSuspendAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationSuspendRepositoriesItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationSuspendRepositoriesItem> for InstallationSuspendRepositoriesItem {
	fn from(value: &InstallationSuspendRepositoriesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct InstallationTargetEvent(pub InstallationTargetRenamed);
impl std::ops::Deref for InstallationTargetEvent {
	type Target = InstallationTargetRenamed;

	fn deref(&self) -> &InstallationTargetRenamed {
		&self.0
	}
}
impl From<InstallationTargetEvent> for InstallationTargetRenamed {
	fn from(value: InstallationTargetEvent) -> Self {
		value.0
	}
}
impl From<&InstallationTargetEvent> for InstallationTargetEvent {
	fn from(value: &InstallationTargetEvent) -> Self {
		value.clone()
	}
}
impl From<InstallationTargetRenamed> for InstallationTargetEvent {
	fn from(value: InstallationTargetRenamed) -> Self {
		Self(value)
	}
}
/// Somebody renamed the user or organization account that a GitHub App is
/// installed on.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationTargetRenamed {
	pub account:      InstallationTargetRenamedAccount,
	pub action:       InstallationTargetRenamedAction,
	pub changes:      InstallationTargetRenamedChanges,
	pub installation: InstallationLite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub sender:       Option<User>,
	pub target_type:  String,
}
impl From<&InstallationTargetRenamed> for InstallationTargetRenamed {
	fn from(value: &InstallationTargetRenamed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationTargetRenamedAccount {
	pub avatar_url: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<InstallationTargetRenamedAccountDescription>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub events_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub followers: Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub followers_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub following: Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub following_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub gists_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub gravatar_id: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub has_organization_projects: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub has_repository_projects: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub hooks_url: Option<String>,
	pub html_url: String,
	pub id: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub is_verified: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub issues_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub login: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub members_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name: Option<String>,
	pub node_id: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organizations_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub public_gists: Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub public_members_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub public_repos: Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub received_events_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repos_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub site_admin: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub slug: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub starred_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub subscriptions_url: Option<String>,
	#[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
	pub type_: Option<InstallationTargetRenamedAccountType>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub updated_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub website_url: Option<InstallationTargetRenamedAccountWebsiteUrl>,
}
impl From<&InstallationTargetRenamedAccount> for InstallationTargetRenamedAccount {
	fn from(value: &InstallationTargetRenamedAccount) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(untagged)]
pub enum InstallationTargetRenamedAccountDescription {
	Null,
}
impl From<&InstallationTargetRenamedAccountDescription>
	for InstallationTargetRenamedAccountDescription
{
	fn from(value: &InstallationTargetRenamedAccountDescription) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationTargetRenamedAccountType {
	Bot,
	User,
	Organization,
}
impl From<&InstallationTargetRenamedAccountType> for InstallationTargetRenamedAccountType {
	fn from(value: &InstallationTargetRenamedAccountType) -> Self {
		value.clone()
	}
}
impl ToString for InstallationTargetRenamedAccountType {
	fn to_string(&self) -> String {
		match *self {
			Self::Bot => "Bot".to_string(),
			Self::User => "User".to_string(),
			Self::Organization => "Organization".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationTargetRenamedAccountType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"Bot" => Ok(Self::Bot),
			"User" => Ok(Self::User),
			"Organization" => Ok(Self::Organization),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationTargetRenamedAccountType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationTargetRenamedAccountType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationTargetRenamedAccountType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(untagged)]
pub enum InstallationTargetRenamedAccountWebsiteUrl {
	Null,
}
impl From<&InstallationTargetRenamedAccountWebsiteUrl>
	for InstallationTargetRenamedAccountWebsiteUrl
{
	fn from(value: &InstallationTargetRenamedAccountWebsiteUrl) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationTargetRenamedAction {
	#[serde(rename = "renamed")]
	Renamed,
}
impl From<&InstallationTargetRenamedAction> for InstallationTargetRenamedAction {
	fn from(value: &InstallationTargetRenamedAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationTargetRenamedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Renamed => "renamed".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationTargetRenamedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"renamed" => Ok(Self::Renamed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationTargetRenamedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationTargetRenamedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationTargetRenamedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationTargetRenamedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub login: Option<InstallationTargetRenamedChangesLogin>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub slug:  Option<InstallationTargetRenamedChangesSlug>,
}
impl From<&InstallationTargetRenamedChanges> for InstallationTargetRenamedChanges {
	fn from(value: &InstallationTargetRenamedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationTargetRenamedChangesLogin {
	pub from: String,
}
impl From<&InstallationTargetRenamedChangesLogin> for InstallationTargetRenamedChangesLogin {
	fn from(value: &InstallationTargetRenamedChangesLogin) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationTargetRenamedChangesSlug {
	pub from: String,
}
impl From<&InstallationTargetRenamedChangesSlug> for InstallationTargetRenamedChangesSlug {
	fn from(value: &InstallationTargetRenamedChangesSlug) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationTargetType {
	User,
	Organization,
}
impl From<&InstallationTargetType> for InstallationTargetType {
	fn from(value: &InstallationTargetType) -> Self {
		value.clone()
	}
}
impl ToString for InstallationTargetType {
	fn to_string(&self) -> String {
		match *self {
			Self::User => "User".to_string(),
			Self::Organization => "Organization".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationTargetType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"User" => Ok(Self::User),
			"Organization" => Ok(Self::Organization),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationTargetType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationTargetType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationTargetType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspend {
	pub action:       InstallationUnsuspendAction,
	pub installation: Installation,
	/// An array of repository objects that the installation can access.
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub repositories: Vec<InstallationUnsuspendRepositoriesItem>,
	#[serde(default)]
	pub requester:    (),
	pub sender:       User,
}
impl From<&InstallationUnsuspend> for InstallationUnsuspend {
	fn from(value: &InstallationUnsuspend) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstallationUnsuspendAction {
	#[serde(rename = "unsuspend")]
	Unsuspend,
}
impl From<&InstallationUnsuspendAction> for InstallationUnsuspendAction {
	fn from(value: &InstallationUnsuspendAction) -> Self {
		value.clone()
	}
}
impl ToString for InstallationUnsuspendAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unsuspend => "unsuspend".to_string(),
		}
	}
}
impl std::str::FromStr for InstallationUnsuspendAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unsuspend" => Ok(Self::Unsuspend),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationUnsuspendAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationUnsuspendAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationUnsuspendAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct InstallationUnsuspendRepositoriesItem {
	pub full_name: String,
	/// Unique identifier of the repository
	pub id:        i64,
	/// The name of the repository.
	pub name:      String,
	pub node_id:   String,
	/// Whether the repository is private or public.
	pub private:   bool,
}
impl From<&InstallationUnsuspendRepositoriesItem> for InstallationUnsuspendRepositoriesItem {
	fn from(value: &InstallationUnsuspendRepositoriesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum InstallationUpdatedAt {
	Variant0(chrono::DateTime<chrono::offset::Utc>),
	Variant1(i64),
}
impl From<&InstallationUpdatedAt> for InstallationUpdatedAt {
	fn from(value: &InstallationUpdatedAt) -> Self {
		value.clone()
	}
}
impl std::str::FromStr for InstallationUpdatedAt {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		if let Ok(v) = value.parse() {
			Ok(Self::Variant0(v))
		} else if let Ok(v) = value.parse() {
			Ok(Self::Variant1(v))
		} else {
			Err("string conversion failed for all variants")
		}
	}
}
impl std::convert::TryFrom<&str> for InstallationUpdatedAt {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for InstallationUpdatedAt {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for InstallationUpdatedAt {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl ToString for InstallationUpdatedAt {
	fn to_string(&self) -> String {
		match self {
			Self::Variant0(x) => x.to_string(),
			Self::Variant1(x) => x.to_string(),
		}
	}
}
impl From<chrono::DateTime<chrono::offset::Utc>> for InstallationUpdatedAt {
	fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
		Self::Variant0(value)
	}
}
impl From<i64> for InstallationUpdatedAt {
	fn from(value: i64) -> Self {
		Self::Variant1(value)
	}
}
/// The [issue](https://docs.github.com/en/rest/reference/issues) itself.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Issue {
	pub active_lock_reason: Option<IssueActiveLockReason>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub assignee: Option<User>,
	pub assignees: Vec<User>,
	pub author_association: AuthorAssociation,
	/// Contents of the issue
	pub body: Option<String>,
	pub closed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments: i64,
	pub comments_url: String,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft: Option<bool>,
	pub events_url: String,
	pub html_url: String,
	pub id: i64,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub labels: Vec<Label>,
	pub labels_url: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub locked: Option<bool>,
	pub milestone: Option<Milestone>,
	pub node_id: String,
	/// Number uniquely identifying the issue within its repository
	pub number: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub performed_via_github_app: Option<App>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pull_request: Option<IssuePullRequest>,
	pub reactions: Reactions,
	pub repository_url: String,
	/// State of the issue; either 'open' or 'closed'
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub state: Option<IssueState>,
	/// The reason for the current state
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub state_reason: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub timeline_url: Option<String>,
	/// Title of the issue
	pub title: String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// URL for the issue
	pub url: String,
	pub user: User,
}
impl From<&Issue> for Issue {
	fn from(value: &Issue) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&IssueActiveLockReason> for IssueActiveLockReason {
	fn from(value: &IssueActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for IssueActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for IssueActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssueActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssueActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssueActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueComment {
	pub author_association: AuthorAssociation,
	/// Contents of the issue comment
	pub body: String,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub html_url: String,
	/// Unique identifier of the issue comment
	pub id: i64,
	pub issue_url: String,
	pub node_id: String,
	pub performed_via_github_app: Option<App>,
	pub reactions: Reactions,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// URL for the issue comment
	pub url: String,
	pub user: User,
}
impl From<&IssueComment> for IssueComment {
	fn from(value: &IssueComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentCreated {
	pub action:       IssueCommentCreatedAction,
	pub comment:      IssueComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssueCommentCreated> for IssueCommentCreated {
	fn from(value: &IssueCommentCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&IssueCommentCreatedAction> for IssueCommentCreatedAction {
	fn from(value: &IssueCommentCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssueCommentCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for IssueCommentCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssueCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssueCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssueCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentDeleted {
	pub action:       IssueCommentDeletedAction,
	pub comment:      IssueComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssueCommentDeleted> for IssueCommentDeleted {
	fn from(value: &IssueCommentDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&IssueCommentDeletedAction> for IssueCommentDeletedAction {
	fn from(value: &IssueCommentDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssueCommentDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for IssueCommentDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssueCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssueCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssueCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEdited {
	pub action:       IssueCommentEditedAction,
	pub changes:      IssueCommentEditedChanges,
	pub comment:      IssueComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssueCommentEdited> for IssueCommentEdited {
	fn from(value: &IssueCommentEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueCommentEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&IssueCommentEditedAction> for IssueCommentEditedAction {
	fn from(value: &IssueCommentEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssueCommentEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for IssueCommentEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssueCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssueCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssueCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the comment.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body: Option<IssueCommentEditedChangesBody>,
}
impl From<&IssueCommentEditedChanges> for IssueCommentEditedChanges {
	fn from(value: &IssueCommentEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssueCommentEditedChangesBody {
	/// The previous version of the body.
	pub from: String,
}
impl From<&IssueCommentEditedChangesBody> for IssueCommentEditedChangesBody {
	fn from(value: &IssueCommentEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssueCommentEvent {
	Created(IssueCommentCreated),
	Deleted(IssueCommentDeleted),
	Edited(IssueCommentEdited),
}
impl From<&IssueCommentEvent> for IssueCommentEvent {
	fn from(value: &IssueCommentEvent) -> Self {
		value.clone()
	}
}
impl From<IssueCommentCreated> for IssueCommentEvent {
	fn from(value: IssueCommentCreated) -> Self {
		Self::Created(value)
	}
}
impl From<IssueCommentDeleted> for IssueCommentEvent {
	fn from(value: IssueCommentDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<IssueCommentEdited> for IssueCommentEvent {
	fn from(value: IssueCommentEdited) -> Self {
		Self::Edited(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuePullRequest {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub diff_url:  Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub html_url:  Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub merged_at: Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub patch_url: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub url:       Option<String>,
}
impl From<&IssuePullRequest> for IssuePullRequest {
	fn from(value: &IssuePullRequest) -> Self {
		value.clone()
	}
}
/// State of the issue; either 'open' or 'closed'
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssueState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&IssueState> for IssueState {
	fn from(value: &IssueState) -> Self {
		value.clone()
	}
}
impl ToString for IssueState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for IssueState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssueState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssueState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssueState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Activity related to an issue. The type of activity is specified in the
/// action property.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesAssigned {
	/// The action that was performed.
	pub action:       IssuesAssignedAction,
	/// The optional user who was assigned or unassigned from the issue.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub assignee:     Option<User>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesAssigned> for IssuesAssigned {
	fn from(value: &IssuesAssigned) -> Self {
		value.clone()
	}
}
/// The action that was performed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesAssignedAction {
	#[serde(rename = "assigned")]
	Assigned,
}
impl From<&IssuesAssignedAction> for IssuesAssignedAction {
	fn from(value: &IssuesAssignedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesAssignedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Assigned => "assigned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesAssignedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"assigned" => Ok(Self::Assigned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesAssignedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesAssignedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesAssignedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesClosed {
	/// The action that was performed.
	pub action:       IssuesClosedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [issue](https://docs.github.com/en/rest/reference/issues) itself.
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesClosed> for IssuesClosed {
	fn from(value: &IssuesClosed) -> Self {
		value.clone()
	}
}
/// The action that was performed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesClosedAction {
	#[serde(rename = "closed")]
	Closed,
}
impl From<&IssuesClosedAction> for IssuesClosedAction {
	fn from(value: &IssuesClosedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesClosedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesClosedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesClosedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesClosedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesClosedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDeleted {
	pub action:       IssuesDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesDeleted> for IssuesDeleted {
	fn from(value: &IssuesDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&IssuesDeletedAction> for IssuesDeletedAction {
	fn from(value: &IssuesDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesDemilestoned {
	pub action:       IssuesDemilestonedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesDemilestoned> for IssuesDemilestoned {
	fn from(value: &IssuesDemilestoned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesDemilestonedAction {
	#[serde(rename = "demilestoned")]
	Demilestoned,
}
impl From<&IssuesDemilestonedAction> for IssuesDemilestonedAction {
	fn from(value: &IssuesDemilestonedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesDemilestonedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Demilestoned => "demilestoned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesDemilestonedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"demilestoned" => Ok(Self::Demilestoned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEdited {
	pub action:       IssuesEditedAction,
	pub changes:      IssuesEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub label:        Option<Label>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesEdited> for IssuesEdited {
	fn from(value: &IssuesEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&IssuesEditedAction> for IssuesEditedAction {
	fn from(value: &IssuesEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the issue.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:  Option<IssuesEditedChangesBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title: Option<IssuesEditedChangesTitle>,
}
impl From<&IssuesEditedChanges> for IssuesEditedChanges {
	fn from(value: &IssuesEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesBody {
	/// The previous version of the body.
	pub from: String,
}
impl From<&IssuesEditedChangesBody> for IssuesEditedChangesBody {
	fn from(value: &IssuesEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesEditedChangesTitle {
	/// The previous version of the title.
	pub from: String,
}
impl From<&IssuesEditedChangesTitle> for IssuesEditedChangesTitle {
	fn from(value: &IssuesEditedChangesTitle) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IssuesEvent {
	Assigned(IssuesAssigned),
	Closed(IssuesClosed),
	Deleted(IssuesDeleted),
	Demilestoned(IssuesDemilestoned),
	Edited(IssuesEdited),
	Labeled(IssuesLabeled),
	Locked(IssuesLocked),
	Milestoned(IssuesMilestoned),
	Opened(IssuesOpened),
	Pinned(IssuesPinned),
	Reopened(IssuesReopened),
	Transferred(IssuesTransferred),
	Unassigned(IssuesUnassigned),
	Unlabeled(IssuesUnlabeled),
	Unlocked(IssuesUnlocked),
	Unpinned(IssuesUnpinned),
}
impl From<&IssuesEvent> for IssuesEvent {
	fn from(value: &IssuesEvent) -> Self {
		value.clone()
	}
}
impl From<IssuesAssigned> for IssuesEvent {
	fn from(value: IssuesAssigned) -> Self {
		Self::Assigned(value)
	}
}
impl From<IssuesClosed> for IssuesEvent {
	fn from(value: IssuesClosed) -> Self {
		Self::Closed(value)
	}
}
impl From<IssuesDeleted> for IssuesEvent {
	fn from(value: IssuesDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<IssuesDemilestoned> for IssuesEvent {
	fn from(value: IssuesDemilestoned) -> Self {
		Self::Demilestoned(value)
	}
}
impl From<IssuesEdited> for IssuesEvent {
	fn from(value: IssuesEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<IssuesLabeled> for IssuesEvent {
	fn from(value: IssuesLabeled) -> Self {
		Self::Labeled(value)
	}
}
impl From<IssuesLocked> for IssuesEvent {
	fn from(value: IssuesLocked) -> Self {
		Self::Locked(value)
	}
}
impl From<IssuesMilestoned> for IssuesEvent {
	fn from(value: IssuesMilestoned) -> Self {
		Self::Milestoned(value)
	}
}
impl From<IssuesOpened> for IssuesEvent {
	fn from(value: IssuesOpened) -> Self {
		Self::Opened(value)
	}
}
impl From<IssuesPinned> for IssuesEvent {
	fn from(value: IssuesPinned) -> Self {
		Self::Pinned(value)
	}
}
impl From<IssuesReopened> for IssuesEvent {
	fn from(value: IssuesReopened) -> Self {
		Self::Reopened(value)
	}
}
impl From<IssuesTransferred> for IssuesEvent {
	fn from(value: IssuesTransferred) -> Self {
		Self::Transferred(value)
	}
}
impl From<IssuesUnassigned> for IssuesEvent {
	fn from(value: IssuesUnassigned) -> Self {
		Self::Unassigned(value)
	}
}
impl From<IssuesUnlabeled> for IssuesEvent {
	fn from(value: IssuesUnlabeled) -> Self {
		Self::Unlabeled(value)
	}
}
impl From<IssuesUnlocked> for IssuesEvent {
	fn from(value: IssuesUnlocked) -> Self {
		Self::Unlocked(value)
	}
}
impl From<IssuesUnpinned> for IssuesEvent {
	fn from(value: IssuesUnpinned) -> Self {
		Self::Unpinned(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLabeled {
	pub action:       IssuesLabeledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	/// The label that was added to the issue.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub label:        Option<Label>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesLabeled> for IssuesLabeled {
	fn from(value: &IssuesLabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLabeledAction {
	#[serde(rename = "labeled")]
	Labeled,
}
impl From<&IssuesLabeledAction> for IssuesLabeledAction {
	fn from(value: &IssuesLabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesLabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Labeled => "labeled".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesLabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"labeled" => Ok(Self::Labeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesLabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesLabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesLabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesLocked {
	pub action:       IssuesLockedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesLocked> for IssuesLocked {
	fn from(value: &IssuesLocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesLockedAction {
	#[serde(rename = "locked")]
	Locked,
}
impl From<&IssuesLockedAction> for IssuesLockedAction {
	fn from(value: &IssuesLockedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesLockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Locked => "locked".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesLockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"locked" => Ok(Self::Locked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesLockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesLockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesLockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesMilestoned {
	pub action:       IssuesMilestonedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesMilestoned> for IssuesMilestoned {
	fn from(value: &IssuesMilestoned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesMilestonedAction {
	#[serde(rename = "milestoned")]
	Milestoned,
}
impl From<&IssuesMilestonedAction> for IssuesMilestonedAction {
	fn from(value: &IssuesMilestonedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesMilestonedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Milestoned => "milestoned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesMilestonedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"milestoned" => Ok(Self::Milestoned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesMilestonedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesMilestonedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesMilestonedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpened {
	pub action:       IssuesOpenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<IssuesOpenedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesOpened> for IssuesOpened {
	fn from(value: &IssuesOpened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesOpenedAction {
	#[serde(rename = "opened")]
	Opened,
}
impl From<&IssuesOpenedAction> for IssuesOpenedAction {
	fn from(value: &IssuesOpenedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesOpenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Opened => "opened".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesOpenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"opened" => Ok(Self::Opened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesOpenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesOpenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesOpenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesOpenedChanges {
	pub old_issue:      Issue,
	pub old_repository: Repository,
}
impl From<&IssuesOpenedChanges> for IssuesOpenedChanges {
	fn from(value: &IssuesOpenedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesPinned {
	pub action:       IssuesPinnedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesPinned> for IssuesPinned {
	fn from(value: &IssuesPinned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesPinnedAction {
	#[serde(rename = "pinned")]
	Pinned,
}
impl From<&IssuesPinnedAction> for IssuesPinnedAction {
	fn from(value: &IssuesPinnedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesPinnedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Pinned => "pinned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesPinnedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pinned" => Ok(Self::Pinned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesPinnedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesPinnedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesPinnedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesReopened {
	pub action:       IssuesReopenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesReopened> for IssuesReopened {
	fn from(value: &IssuesReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&IssuesReopenedAction> for IssuesReopenedAction {
	fn from(value: &IssuesReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferred {
	pub action:       IssuesTransferredAction,
	pub changes:      IssuesTransferredChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesTransferred> for IssuesTransferred {
	fn from(value: &IssuesTransferred) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesTransferredAction {
	#[serde(rename = "transferred")]
	Transferred,
}
impl From<&IssuesTransferredAction> for IssuesTransferredAction {
	fn from(value: &IssuesTransferredAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesTransferredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Transferred => "transferred".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesTransferredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"transferred" => Ok(Self::Transferred),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesTransferredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesTransferredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesTransferredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesTransferredChanges {
	pub new_issue:      Issue,
	pub new_repository: Repository,
}
impl From<&IssuesTransferredChanges> for IssuesTransferredChanges {
	fn from(value: &IssuesTransferredChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnassigned {
	/// The action that was performed.
	pub action:       IssuesUnassignedAction,
	/// The optional user who was assigned or unassigned from the issue.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub assignee:     Option<User>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesUnassigned> for IssuesUnassigned {
	fn from(value: &IssuesUnassigned) -> Self {
		value.clone()
	}
}
/// The action that was performed.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnassignedAction {
	#[serde(rename = "unassigned")]
	Unassigned,
}
impl From<&IssuesUnassignedAction> for IssuesUnassignedAction {
	fn from(value: &IssuesUnassignedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesUnassignedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unassigned => "unassigned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesUnassignedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unassigned" => Ok(Self::Unassigned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesUnassignedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesUnassignedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesUnassignedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlabeled {
	pub action:       IssuesUnlabeledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	/// The label that was removed from the issue.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub label:        Option<Label>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesUnlabeled> for IssuesUnlabeled {
	fn from(value: &IssuesUnlabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlabeledAction {
	#[serde(rename = "unlabeled")]
	Unlabeled,
}
impl From<&IssuesUnlabeledAction> for IssuesUnlabeledAction {
	fn from(value: &IssuesUnlabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesUnlabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlabeled => "unlabeled".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesUnlabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlabeled" => Ok(Self::Unlabeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnlocked {
	pub action:       IssuesUnlockedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesUnlocked> for IssuesUnlocked {
	fn from(value: &IssuesUnlocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnlockedAction {
	#[serde(rename = "unlocked")]
	Unlocked,
}
impl From<&IssuesUnlockedAction> for IssuesUnlockedAction {
	fn from(value: &IssuesUnlockedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesUnlockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlocked => "unlocked".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesUnlockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlocked" => Ok(Self::Unlocked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesUnlockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IssuesUnpinned {
	pub action:       IssuesUnpinnedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub issue:        Issue,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&IssuesUnpinned> for IssuesUnpinned {
	fn from(value: &IssuesUnpinned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IssuesUnpinnedAction {
	#[serde(rename = "unpinned")]
	Unpinned,
}
impl From<&IssuesUnpinnedAction> for IssuesUnpinnedAction {
	fn from(value: &IssuesUnpinnedAction) -> Self {
		value.clone()
	}
}
impl ToString for IssuesUnpinnedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unpinned => "unpinned".to_string(),
		}
	}
}
impl std::str::FromStr for IssuesUnpinnedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unpinned" => Ok(Self::Unpinned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for IssuesUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for IssuesUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for IssuesUnpinnedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Label {
	/// 6-character hex code, without the leading #, identifying the color
	pub color:       String,
	pub default:     bool,
	pub description: Option<String>,
	pub id:          i64,
	/// The name of the label.
	pub name:        String,
	pub node_id:     String,
	/// URL for the label
	pub url:         String,
}
impl From<&Label> for Label {
	fn from(value: &Label) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelCreated {
	pub action:       LabelCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The label that was added.
	pub label:        Label,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&LabelCreated> for LabelCreated {
	fn from(value: &LabelCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&LabelCreatedAction> for LabelCreatedAction {
	fn from(value: &LabelCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for LabelCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for LabelCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for LabelCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for LabelCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for LabelCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelDeleted {
	pub action:       LabelDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The label that was removed.
	pub label:        Label,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&LabelDeleted> for LabelDeleted {
	fn from(value: &LabelDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&LabelDeletedAction> for LabelDeletedAction {
	fn from(value: &LabelDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for LabelDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for LabelDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for LabelDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for LabelDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for LabelDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEdited {
	pub action:       LabelEditedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<LabelEditedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The label that was edited.
	pub label:        Label,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&LabelEdited> for LabelEdited {
	fn from(value: &LabelEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&LabelEditedAction> for LabelEditedAction {
	fn from(value: &LabelEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for LabelEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for LabelEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for LabelEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for LabelEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for LabelEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the label if the action was `edited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub color:       Option<LabelEditedChangesColor>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<LabelEditedChangesDescription>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:        Option<LabelEditedChangesName>,
}
impl From<&LabelEditedChanges> for LabelEditedChanges {
	fn from(value: &LabelEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesColor {
	/// The previous version of the color if the action was `edited`.
	pub from: String,
}
impl From<&LabelEditedChangesColor> for LabelEditedChangesColor {
	fn from(value: &LabelEditedChangesColor) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesDescription {
	/// The previous version of the description if the action was `edited`.
	pub from: String,
}
impl From<&LabelEditedChangesDescription> for LabelEditedChangesDescription {
	fn from(value: &LabelEditedChangesDescription) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelEditedChangesName {
	/// The previous version of the name if the action was `edited`.
	pub from: String,
}
impl From<&LabelEditedChangesName> for LabelEditedChangesName {
	fn from(value: &LabelEditedChangesName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelEvent {
	Created(LabelCreated),
	Deleted(LabelDeleted),
	Edited(LabelEdited),
}
impl From<&LabelEvent> for LabelEvent {
	fn from(value: &LabelEvent) -> Self {
		value.clone()
	}
}
impl From<LabelCreated> for LabelEvent {
	fn from(value: LabelCreated) -> Self {
		Self::Created(value)
	}
}
impl From<LabelDeleted> for LabelEvent {
	fn from(value: LabelDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<LabelEdited> for LabelEvent {
	fn from(value: LabelEdited) -> Self {
		Self::Edited(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct License {
	pub key:     String,
	pub name:    String,
	pub node_id: String,
	pub spdx_id: String,
	pub url:     Option<String>,
}
impl From<&License> for License {
	fn from(value: &License) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Link {
	pub href: String,
}
impl From<&Link> for Link {
	fn from(value: &Link) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchase {
	pub account:            MarketplacePurchaseAccount,
	pub billing_cycle:      String,
	pub free_trial_ends_on: Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub next_billing_date:  Option<String>,
	pub on_free_trial:      bool,
	pub plan:               MarketplacePurchasePlan,
	pub unit_count:         i64,
}
impl From<&MarketplacePurchase> for MarketplacePurchase {
	fn from(value: &MarketplacePurchase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseAccount {
	pub id: i64,
	pub login: String,
	pub node_id: String,
	pub organization_billing_email: String,
	#[serde(rename = "type")]
	pub type_: String,
}
impl From<&MarketplacePurchaseAccount> for MarketplacePurchaseAccount {
	fn from(value: &MarketplacePurchaseAccount) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelled {
	pub action: MarketplacePurchaseCancelledAction,
	pub effective_date: chrono::DateTime<chrono::offset::Utc>,
	pub marketplace_purchase: MarketplacePurchase,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub previous_marketplace_purchase: Option<MarketplacePurchase>,
	pub sender: MarketplacePurchaseCancelledSender,
}
impl From<&MarketplacePurchaseCancelled> for MarketplacePurchaseCancelled {
	fn from(value: &MarketplacePurchaseCancelled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseCancelledAction {
	#[serde(rename = "cancelled")]
	Cancelled,
}
impl From<&MarketplacePurchaseCancelledAction> for MarketplacePurchaseCancelledAction {
	fn from(value: &MarketplacePurchaseCancelledAction) -> Self {
		value.clone()
	}
}
impl ToString for MarketplacePurchaseCancelledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Cancelled => "cancelled".to_string(),
		}
	}
}
impl std::str::FromStr for MarketplacePurchaseCancelledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"cancelled" => Ok(Self::Cancelled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseCancelledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseCancelledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MarketplacePurchaseCancelledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseCancelledSender {
	pub avatar_url:          String,
	pub email:               String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&MarketplacePurchaseCancelledSender> for MarketplacePurchaseCancelledSender {
	fn from(value: &MarketplacePurchaseCancelledSender) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChanged {
	pub action: MarketplacePurchaseChangedAction,
	pub effective_date: chrono::DateTime<chrono::offset::Utc>,
	pub marketplace_purchase: MarketplacePurchase,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub previous_marketplace_purchase: Option<MarketplacePurchase>,
	pub sender: MarketplacePurchaseChangedSender,
}
impl From<&MarketplacePurchaseChanged> for MarketplacePurchaseChanged {
	fn from(value: &MarketplacePurchaseChanged) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchaseChangedAction {
	#[serde(rename = "changed")]
	Changed,
}
impl From<&MarketplacePurchaseChangedAction> for MarketplacePurchaseChangedAction {
	fn from(value: &MarketplacePurchaseChangedAction) -> Self {
		value.clone()
	}
}
impl ToString for MarketplacePurchaseChangedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Changed => "changed".to_string(),
		}
	}
}
impl std::str::FromStr for MarketplacePurchaseChangedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"changed" => Ok(Self::Changed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MarketplacePurchaseChangedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MarketplacePurchaseChangedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MarketplacePurchaseChangedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchaseChangedSender {
	pub avatar_url:          String,
	pub email:               String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&MarketplacePurchaseChangedSender> for MarketplacePurchaseChangedSender {
	fn from(value: &MarketplacePurchaseChangedSender) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarketplacePurchaseEvent {
	Cancelled(MarketplacePurchaseCancelled),
	Changed(MarketplacePurchaseChanged),
	PendingChange(MarketplacePurchasePendingChange),
	PendingChangeCancelled(MarketplacePurchasePendingChangeCancelled),
	Purchased(MarketplacePurchasePurchased),
}
impl From<&MarketplacePurchaseEvent> for MarketplacePurchaseEvent {
	fn from(value: &MarketplacePurchaseEvent) -> Self {
		value.clone()
	}
}
impl From<MarketplacePurchaseCancelled> for MarketplacePurchaseEvent {
	fn from(value: MarketplacePurchaseCancelled) -> Self {
		Self::Cancelled(value)
	}
}
impl From<MarketplacePurchaseChanged> for MarketplacePurchaseEvent {
	fn from(value: MarketplacePurchaseChanged) -> Self {
		Self::Changed(value)
	}
}
impl From<MarketplacePurchasePendingChange> for MarketplacePurchaseEvent {
	fn from(value: MarketplacePurchasePendingChange) -> Self {
		Self::PendingChange(value)
	}
}
impl From<MarketplacePurchasePendingChangeCancelled> for MarketplacePurchaseEvent {
	fn from(value: MarketplacePurchasePendingChangeCancelled) -> Self {
		Self::PendingChangeCancelled(value)
	}
}
impl From<MarketplacePurchasePurchased> for MarketplacePurchaseEvent {
	fn from(value: MarketplacePurchasePurchased) -> Self {
		Self::Purchased(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChange {
	pub action: MarketplacePurchasePendingChangeAction,
	pub effective_date: chrono::DateTime<chrono::offset::Utc>,
	pub marketplace_purchase: MarketplacePurchase,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub previous_marketplace_purchase: Option<MarketplacePurchase>,
	pub sender: MarketplacePurchasePendingChangeSender,
}
impl From<&MarketplacePurchasePendingChange> for MarketplacePurchasePendingChange {
	fn from(value: &MarketplacePurchasePendingChange) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeAction {
	#[serde(rename = "pending_change")]
	PendingChange,
}
impl From<&MarketplacePurchasePendingChangeAction> for MarketplacePurchasePendingChangeAction {
	fn from(value: &MarketplacePurchasePendingChangeAction) -> Self {
		value.clone()
	}
}
impl ToString for MarketplacePurchasePendingChangeAction {
	fn to_string(&self) -> String {
		match *self {
			Self::PendingChange => "pending_change".to_string(),
		}
	}
}
impl std::str::FromStr for MarketplacePurchasePendingChangeAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pending_change" => Ok(Self::PendingChange),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelled {
	pub action: MarketplacePurchasePendingChangeCancelledAction,
	pub effective_date: chrono::DateTime<chrono::offset::Utc>,
	pub marketplace_purchase: MarketplacePurchase,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub previous_marketplace_purchase: Option<MarketplacePurchase>,
	pub sender: MarketplacePurchasePendingChangeCancelledSender,
}
impl From<&MarketplacePurchasePendingChangeCancelled>
	for MarketplacePurchasePendingChangeCancelled
{
	fn from(value: &MarketplacePurchasePendingChangeCancelled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePendingChangeCancelledAction {
	#[serde(rename = "pending_change_cancelled")]
	PendingChangeCancelled,
}
impl From<&MarketplacePurchasePendingChangeCancelledAction>
	for MarketplacePurchasePendingChangeCancelledAction
{
	fn from(value: &MarketplacePurchasePendingChangeCancelledAction) -> Self {
		value.clone()
	}
}
impl ToString for MarketplacePurchasePendingChangeCancelledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::PendingChangeCancelled => "pending_change_cancelled".to_string(),
		}
	}
}
impl std::str::FromStr for MarketplacePurchasePendingChangeCancelledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pending_change_cancelled" => Ok(Self::PendingChangeCancelled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePendingChangeCancelledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePendingChangeCancelledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MarketplacePurchasePendingChangeCancelledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeCancelledSender {
	pub avatar_url:          String,
	pub email:               String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&MarketplacePurchasePendingChangeCancelledSender>
	for MarketplacePurchasePendingChangeCancelledSender
{
	fn from(value: &MarketplacePurchasePendingChangeCancelledSender) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePendingChangeSender {
	pub avatar_url:          String,
	pub email:               String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&MarketplacePurchasePendingChangeSender> for MarketplacePurchasePendingChangeSender {
	fn from(value: &MarketplacePurchasePendingChangeSender) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePlan {
	pub bullets:                Vec<String>,
	pub description:            String,
	pub has_free_trial:         bool,
	pub id:                     i64,
	pub monthly_price_in_cents: i64,
	pub name:                   String,
	pub price_model:            String,
	pub unit_name:              Option<String>,
	pub yearly_price_in_cents:  i64,
}
impl From<&MarketplacePurchasePlan> for MarketplacePurchasePlan {
	fn from(value: &MarketplacePurchasePlan) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchased {
	pub action: MarketplacePurchasePurchasedAction,
	pub effective_date: chrono::DateTime<chrono::offset::Utc>,
	pub marketplace_purchase: MarketplacePurchase,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub previous_marketplace_purchase: Option<MarketplacePurchase>,
	pub sender: MarketplacePurchasePurchasedSender,
}
impl From<&MarketplacePurchasePurchased> for MarketplacePurchasePurchased {
	fn from(value: &MarketplacePurchasePurchased) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketplacePurchasePurchasedAction {
	#[serde(rename = "purchased")]
	Purchased,
}
impl From<&MarketplacePurchasePurchasedAction> for MarketplacePurchasePurchasedAction {
	fn from(value: &MarketplacePurchasePurchasedAction) -> Self {
		value.clone()
	}
}
impl ToString for MarketplacePurchasePurchasedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Purchased => "purchased".to_string(),
		}
	}
}
impl std::str::FromStr for MarketplacePurchasePurchasedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"purchased" => Ok(Self::Purchased),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MarketplacePurchasePurchasedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MarketplacePurchasePurchasedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MarketplacePurchasePurchasedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MarketplacePurchasePurchasedSender {
	pub avatar_url:          String,
	pub email:               String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&MarketplacePurchasePurchasedSender> for MarketplacePurchasePurchasedSender {
	fn from(value: &MarketplacePurchasePurchasedSender) -> Self {
		value.clone()
	}
}
/// Activity related to repository collaborators. The type of activity is
/// specified in the action property.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAdded {
	pub action:       MemberAddedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<MemberAddedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The user that was added.
	pub member:       User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MemberAdded> for MemberAdded {
	fn from(value: &MemberAdded) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedAction {
	#[serde(rename = "added")]
	Added,
}
impl From<&MemberAddedAction> for MemberAddedAction {
	fn from(value: &MemberAddedAction) -> Self {
		value.clone()
	}
}
impl ToString for MemberAddedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Added => "added".to_string(),
		}
	}
}
impl std::str::FromStr for MemberAddedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"added" => Ok(Self::Added),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MemberAddedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MemberAddedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MemberAddedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub permission: Option<MemberAddedChangesPermission>,
}
impl From<&MemberAddedChanges> for MemberAddedChanges {
	fn from(value: &MemberAddedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberAddedChangesPermission {
	pub to: MemberAddedChangesPermissionTo,
}
impl From<&MemberAddedChangesPermission> for MemberAddedChangesPermission {
	fn from(value: &MemberAddedChangesPermission) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberAddedChangesPermissionTo {
	#[serde(rename = "write")]
	Write,
	#[serde(rename = "admin")]
	Admin,
}
impl From<&MemberAddedChangesPermissionTo> for MemberAddedChangesPermissionTo {
	fn from(value: &MemberAddedChangesPermissionTo) -> Self {
		value.clone()
	}
}
impl ToString for MemberAddedChangesPermissionTo {
	fn to_string(&self) -> String {
		match *self {
			Self::Write => "write".to_string(),
			Self::Admin => "admin".to_string(),
		}
	}
}
impl std::str::FromStr for MemberAddedChangesPermissionTo {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"write" => Ok(Self::Write),
			"admin" => Ok(Self::Admin),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MemberAddedChangesPermissionTo {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MemberAddedChangesPermissionTo {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MemberAddedChangesPermissionTo {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEdited {
	pub action:       MemberEditedAction,
	pub changes:      MemberEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The user who's permissions are changed.
	pub member:       User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MemberEdited> for MemberEdited {
	fn from(value: &MemberEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&MemberEditedAction> for MemberEditedAction {
	fn from(value: &MemberEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for MemberEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for MemberEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MemberEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MemberEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MemberEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the collaborator permissions
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChanges {
	pub old_permission: MemberEditedChangesOldPermission,
}
impl From<&MemberEditedChanges> for MemberEditedChanges {
	fn from(value: &MemberEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberEditedChangesOldPermission {
	/// The previous permissions of the collaborator if the action was edited.
	pub from: String,
}
impl From<&MemberEditedChangesOldPermission> for MemberEditedChangesOldPermission {
	fn from(value: &MemberEditedChangesOldPermission) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MemberEvent {
	Added(MemberAdded),
	Edited(MemberEdited),
	Removed(MemberRemoved),
}
impl From<&MemberEvent> for MemberEvent {
	fn from(value: &MemberEvent) -> Self {
		value.clone()
	}
}
impl From<MemberAdded> for MemberEvent {
	fn from(value: MemberAdded) -> Self {
		Self::Added(value)
	}
}
impl From<MemberEdited> for MemberEvent {
	fn from(value: MemberEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<MemberRemoved> for MemberEvent {
	fn from(value: MemberRemoved) -> Self {
		Self::Removed(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MemberRemoved {
	pub action:       MemberRemovedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The user that was removed.
	pub member:       User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MemberRemoved> for MemberRemoved {
	fn from(value: &MemberRemoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MemberRemovedAction {
	#[serde(rename = "removed")]
	Removed,
}
impl From<&MemberRemovedAction> for MemberRemovedAction {
	fn from(value: &MemberRemovedAction) -> Self {
		value.clone()
	}
}
impl ToString for MemberRemovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Removed => "removed".to_string(),
		}
	}
}
impl std::str::FromStr for MemberRemovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"removed" => Ok(Self::Removed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The membership between the user and the organization. Not present when the
/// action is `member_invited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Membership {
	pub organization_url: String,
	/// The role of the user in the team.
	pub role:             String,
	/// The state of the user's membership in the team.
	pub state:            String,
	pub url:              String,
	pub user:             User,
}
impl From<&Membership> for Membership {
	fn from(value: &Membership) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipAdded {
	pub action:       MembershipAddedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.
	pub member:       User,
	pub organization: Organization,
	/// The scope of the membership. Currently, can only be `team`.
	pub scope:        MembershipAddedScope,
	pub sender:       User,
	/// The [team](https://docs.github.com/en/rest/reference/teams) for the membership.
	pub team:         Team,
}
impl From<&MembershipAdded> for MembershipAdded {
	fn from(value: &MembershipAdded) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedAction {
	#[serde(rename = "added")]
	Added,
}
impl From<&MembershipAddedAction> for MembershipAddedAction {
	fn from(value: &MembershipAddedAction) -> Self {
		value.clone()
	}
}
impl ToString for MembershipAddedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Added => "added".to_string(),
		}
	}
}
impl std::str::FromStr for MembershipAddedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"added" => Ok(Self::Added),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MembershipAddedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MembershipAddedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MembershipAddedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The scope of the membership. Currently, can only be `team`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipAddedScope {
	#[serde(rename = "team")]
	Team,
}
impl From<&MembershipAddedScope> for MembershipAddedScope {
	fn from(value: &MembershipAddedScope) -> Self {
		value.clone()
	}
}
impl ToString for MembershipAddedScope {
	fn to_string(&self) -> String {
		match *self {
			Self::Team => "team".to_string(),
		}
	}
}
impl std::str::FromStr for MembershipAddedScope {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"team" => Ok(Self::Team),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MembershipAddedScope {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MembershipAddedScope {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MembershipAddedScope {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MembershipEvent {
	Added(MembershipAdded),
	Removed(MembershipRemoved),
}
impl From<&MembershipEvent> for MembershipEvent {
	fn from(value: &MembershipEvent) -> Self {
		value.clone()
	}
}
impl From<MembershipAdded> for MembershipEvent {
	fn from(value: MembershipAdded) -> Self {
		Self::Added(value)
	}
}
impl From<MembershipRemoved> for MembershipEvent {
	fn from(value: MembershipRemoved) -> Self {
		Self::Removed(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MembershipRemoved {
	pub action:       MembershipRemovedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The [user](https://docs.github.com/en/rest/reference/users) that was added or removed.
	pub member:       User,
	pub organization: Organization,
	/// The scope of the membership. Currently, can only be `team`.
	pub scope:        MembershipRemovedScope,
	pub sender:       User,
	/// The [team](https://docs.github.com/en/rest/reference/teams) for the membership.
	pub team:         MembershipRemovedTeam,
}
impl From<&MembershipRemoved> for MembershipRemoved {
	fn from(value: &MembershipRemoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedAction {
	#[serde(rename = "removed")]
	Removed,
}
impl From<&MembershipRemovedAction> for MembershipRemovedAction {
	fn from(value: &MembershipRemovedAction) -> Self {
		value.clone()
	}
}
impl ToString for MembershipRemovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Removed => "removed".to_string(),
		}
	}
}
impl std::str::FromStr for MembershipRemovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"removed" => Ok(Self::Removed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MembershipRemovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MembershipRemovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MembershipRemovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The scope of the membership. Currently, can only be `team`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MembershipRemovedScope {
	#[serde(rename = "team")]
	Team,
	#[serde(rename = "organization")]
	Organization,
}
impl From<&MembershipRemovedScope> for MembershipRemovedScope {
	fn from(value: &MembershipRemovedScope) -> Self {
		value.clone()
	}
}
impl ToString for MembershipRemovedScope {
	fn to_string(&self) -> String {
		match *self {
			Self::Team => "team".to_string(),
			Self::Organization => "organization".to_string(),
		}
	}
}
impl std::str::FromStr for MembershipRemovedScope {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"team" => Ok(Self::Team),
			"organization" => Ok(Self::Organization),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MembershipRemovedScope {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MembershipRemovedScope {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MembershipRemovedScope {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The [team](https://docs.github.com/en/rest/reference/teams) for the membership.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum MembershipRemovedTeam {
	Variant0(Team),
	Variant1 {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		deleted: Option<bool>,
		id:      i64,
		name:    String,
	},
}
impl From<&MembershipRemovedTeam> for MembershipRemovedTeam {
	fn from(value: &MembershipRemovedTeam) -> Self {
		value.clone()
	}
}
impl From<Team> for MembershipRemovedTeam {
	fn from(value: Team) -> Self {
		Self::Variant0(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MergeGroupChecksRequested {
	pub action:       MergeGroupChecksRequestedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub merge_group:  MergeGroupChecksRequestedMergeGroup,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MergeGroupChecksRequested> for MergeGroupChecksRequested {
	fn from(value: &MergeGroupChecksRequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MergeGroupChecksRequestedAction {
	#[serde(rename = "checks_requested")]
	ChecksRequested,
}
impl From<&MergeGroupChecksRequestedAction> for MergeGroupChecksRequestedAction {
	fn from(value: &MergeGroupChecksRequestedAction) -> Self {
		value.clone()
	}
}
impl ToString for MergeGroupChecksRequestedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::ChecksRequested => "checks_requested".to_string(),
		}
	}
}
impl std::str::FromStr for MergeGroupChecksRequestedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"checks_requested" => Ok(Self::ChecksRequested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MergeGroupChecksRequestedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MergeGroupChecksRequestedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MergeGroupChecksRequestedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The merge group.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MergeGroupChecksRequestedMergeGroup {
	/// The full ref of the branch the merge group will be merged into.
	pub base_ref:    String,
	/// The SHA of the merge group's parent commit.
	pub base_sha:    String,
	pub head_commit: MergeGroupChecksRequestedMergeGroupHeadCommit,
	/// The full ref of the merge group.
	pub head_ref:    String,
	/// The SHA of the merge group.
	pub head_sha:    String,
}
impl From<&MergeGroupChecksRequestedMergeGroup> for MergeGroupChecksRequestedMergeGroup {
	fn from(value: &MergeGroupChecksRequestedMergeGroup) -> Self {
		value.clone()
	}
}
/// An expanded representation of the `head_sha` commit.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MergeGroupChecksRequestedMergeGroupHeadCommit {
	pub author:    MergeGroupChecksRequestedMergeGroupHeadCommitAuthor,
	pub committer: MergeGroupChecksRequestedMergeGroupHeadCommitCommitter,
	pub id:        String,
	pub message:   String,
	pub timestamp: chrono::DateTime<chrono::offset::Utc>,
	pub tree_id:   String,
}
impl From<&MergeGroupChecksRequestedMergeGroupHeadCommit>
	for MergeGroupChecksRequestedMergeGroupHeadCommit
{
	fn from(value: &MergeGroupChecksRequestedMergeGroupHeadCommit) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MergeGroupChecksRequestedMergeGroupHeadCommitAuthor {
	pub email: String,
	pub name:  String,
}
impl From<&MergeGroupChecksRequestedMergeGroupHeadCommitAuthor>
	for MergeGroupChecksRequestedMergeGroupHeadCommitAuthor
{
	fn from(value: &MergeGroupChecksRequestedMergeGroupHeadCommitAuthor) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MergeGroupChecksRequestedMergeGroupHeadCommitCommitter {
	pub email: String,
	pub name:  String,
}
impl From<&MergeGroupChecksRequestedMergeGroupHeadCommitCommitter>
	for MergeGroupChecksRequestedMergeGroupHeadCommitCommitter
{
	fn from(value: &MergeGroupChecksRequestedMergeGroupHeadCommitCommitter) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MergeGroupEvent(pub MergeGroupChecksRequested);
impl std::ops::Deref for MergeGroupEvent {
	type Target = MergeGroupChecksRequested;

	fn deref(&self) -> &MergeGroupChecksRequested {
		&self.0
	}
}
impl From<MergeGroupEvent> for MergeGroupChecksRequested {
	fn from(value: MergeGroupEvent) -> Self {
		value.0
	}
}
impl From<&MergeGroupEvent> for MergeGroupEvent {
	fn from(value: &MergeGroupEvent) -> Self {
		value.clone()
	}
}
impl From<MergeGroupChecksRequested> for MergeGroupEvent {
	fn from(value: MergeGroupChecksRequested) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeleted {
	pub action:     MetaDeletedAction,
	pub hook:       MetaDeletedHook,
	/// The id of the modified webhook.
	pub hook_id:    i64,
	pub repository: Repository,
	pub sender:     User,
}
impl From<&MetaDeleted> for MetaDeleted {
	fn from(value: &MetaDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&MetaDeletedAction> for MetaDeletedAction {
	fn from(value: &MetaDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for MetaDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for MetaDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MetaDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MetaDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MetaDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The modified webhook. This will contain different keys based on the type of
/// webhook it is: repository, organization, business, app, or GitHub
/// Marketplace.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHook {
	pub active:     bool,
	pub config:     MetaDeletedHookConfig,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub events:     WebhookEvents,
	pub id:         i64,
	pub name:       String,
	#[serde(rename = "type")]
	pub type_:      String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
}
impl From<&MetaDeletedHook> for MetaDeletedHook {
	fn from(value: &MetaDeletedHook) -> Self {
		value.clone()
	}
}
/// Configuration object of the webhook
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaDeletedHookConfig {
	/// The media type used to serialize the payloads. Supported values include
	/// `json` and `form`. The default is `form`.
	pub content_type: MetaDeletedHookConfigContentType,
	/// Determines whether the SSL certificate of the host for `url` will be
	/// verified when delivering payloads. Supported values include `0`
	/// (verification is performed) and `1` (verification is not performed). The
	/// default is `0`.
	pub insecure_ssl: MetaDeletedHookConfigInsecureSsl,
	/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secret:       Option<String>,
	/// The URL to which the payloads will be delivered.
	pub url:          String,
}
impl From<&MetaDeletedHookConfig> for MetaDeletedHookConfig {
	fn from(value: &MetaDeletedHookConfig) -> Self {
		value.clone()
	}
}
/// The media type used to serialize the payloads. Supported values include
/// `json` and `form`. The default is `form`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedHookConfigContentType {
	#[serde(rename = "json")]
	Json,
	#[serde(rename = "form")]
	Form,
}
impl From<&MetaDeletedHookConfigContentType> for MetaDeletedHookConfigContentType {
	fn from(value: &MetaDeletedHookConfigContentType) -> Self {
		value.clone()
	}
}
impl ToString for MetaDeletedHookConfigContentType {
	fn to_string(&self) -> String {
		match *self {
			Self::Json => "json".to_string(),
			Self::Form => "form".to_string(),
		}
	}
}
impl std::str::FromStr for MetaDeletedHookConfigContentType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"json" => Ok(Self::Json),
			"form" => Ok(Self::Form),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MetaDeletedHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MetaDeletedHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MetaDeletedHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Determines whether the SSL certificate of the host for `url` will be
/// verified when delivering payloads. Supported values include `0`
/// (verification is performed) and `1` (verification is not performed). The
/// default is `0`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MetaDeletedHookConfigInsecureSsl {
	#[serde(rename = "0")]
	_0,
	#[serde(rename = "1")]
	_1,
}
impl From<&MetaDeletedHookConfigInsecureSsl> for MetaDeletedHookConfigInsecureSsl {
	fn from(value: &MetaDeletedHookConfigInsecureSsl) -> Self {
		value.clone()
	}
}
impl ToString for MetaDeletedHookConfigInsecureSsl {
	fn to_string(&self) -> String {
		match *self {
			Self::_0 => "0".to_string(),
			Self::_1 => "1".to_string(),
		}
	}
}
impl std::str::FromStr for MetaDeletedHookConfigInsecureSsl {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"0" => Ok(Self::_0),
			"1" => Ok(Self::_1),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MetaDeletedHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MetaDeletedHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MetaDeletedHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MetaEvent(pub MetaDeleted);
impl std::ops::Deref for MetaEvent {
	type Target = MetaDeleted;

	fn deref(&self) -> &MetaDeleted {
		&self.0
	}
}
impl From<MetaEvent> for MetaDeleted {
	fn from(value: MetaEvent) -> Self {
		value.0
	}
}
impl From<&MetaEvent> for MetaEvent {
	fn from(value: &MetaEvent) -> Self {
		value.clone()
	}
}
impl From<MetaDeleted> for MetaEvent {
	fn from(value: MetaDeleted) -> Self {
		Self(value)
	}
}
/// A collection of related issues and pull requests.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Milestone {
	pub closed_at:     Option<chrono::DateTime<chrono::offset::Utc>>,
	pub closed_issues: i64,
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub creator:       User,
	pub description:   Option<String>,
	pub due_on:        Option<chrono::DateTime<chrono::offset::Utc>>,
	pub html_url:      String,
	pub id:            i64,
	pub labels_url:    String,
	pub node_id:       String,
	/// The number of the milestone.
	pub number:        i64,
	pub open_issues:   i64,
	/// The state of the milestone.
	pub state:         MilestoneState,
	/// The title of the milestone.
	pub title:         String,
	pub updated_at:    chrono::DateTime<chrono::offset::Utc>,
	pub url:           String,
}
impl From<&Milestone> for Milestone {
	fn from(value: &Milestone) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneClosed {
	pub action:       MilestoneClosedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MilestoneClosed> for MilestoneClosed {
	fn from(value: &MilestoneClosed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneClosedAction {
	#[serde(rename = "closed")]
	Closed,
}
impl From<&MilestoneClosedAction> for MilestoneClosedAction {
	fn from(value: &MilestoneClosedAction) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneClosedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneClosedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneClosedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneClosedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneClosedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneCreated {
	pub action:       MilestoneCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MilestoneCreated> for MilestoneCreated {
	fn from(value: &MilestoneCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&MilestoneCreatedAction> for MilestoneCreatedAction {
	fn from(value: &MilestoneCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneDeleted {
	pub action:       MilestoneDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MilestoneDeleted> for MilestoneDeleted {
	fn from(value: &MilestoneDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&MilestoneDeletedAction> for MilestoneDeletedAction {
	fn from(value: &MilestoneDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEdited {
	pub action:       MilestoneEditedAction,
	pub changes:      MilestoneEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MilestoneEdited> for MilestoneEdited {
	fn from(value: &MilestoneEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&MilestoneEditedAction> for MilestoneEditedAction {
	fn from(value: &MilestoneEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the milestone if the action was `edited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<MilestoneEditedChangesDescription>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub due_on:      Option<MilestoneEditedChangesDueOn>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title:       Option<MilestoneEditedChangesTitle>,
}
impl From<&MilestoneEditedChanges> for MilestoneEditedChanges {
	fn from(value: &MilestoneEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDescription {
	/// The previous version of the description if the action was `edited`.
	pub from: String,
}
impl From<&MilestoneEditedChangesDescription> for MilestoneEditedChangesDescription {
	fn from(value: &MilestoneEditedChangesDescription) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesDueOn {
	/// The previous version of the due date if the action was `edited`.
	pub from: String,
}
impl From<&MilestoneEditedChangesDueOn> for MilestoneEditedChangesDueOn {
	fn from(value: &MilestoneEditedChangesDueOn) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneEditedChangesTitle {
	/// The previous version of the title if the action was `edited`.
	pub from: String,
}
impl From<&MilestoneEditedChangesTitle> for MilestoneEditedChangesTitle {
	fn from(value: &MilestoneEditedChangesTitle) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MilestoneEvent {
	Closed(MilestoneClosed),
	Created(MilestoneCreated),
	Deleted(MilestoneDeleted),
	Edited(MilestoneEdited),
	Opened(MilestoneOpened),
}
impl From<&MilestoneEvent> for MilestoneEvent {
	fn from(value: &MilestoneEvent) -> Self {
		value.clone()
	}
}
impl From<MilestoneClosed> for MilestoneEvent {
	fn from(value: MilestoneClosed) -> Self {
		Self::Closed(value)
	}
}
impl From<MilestoneCreated> for MilestoneEvent {
	fn from(value: MilestoneCreated) -> Self {
		Self::Created(value)
	}
}
impl From<MilestoneDeleted> for MilestoneEvent {
	fn from(value: MilestoneDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<MilestoneEdited> for MilestoneEvent {
	fn from(value: MilestoneEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<MilestoneOpened> for MilestoneEvent {
	fn from(value: MilestoneOpened) -> Self {
		Self::Opened(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MilestoneOpened {
	pub action:       MilestoneOpenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&MilestoneOpened> for MilestoneOpened {
	fn from(value: &MilestoneOpened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneOpenedAction {
	#[serde(rename = "opened")]
	Opened,
}
impl From<&MilestoneOpenedAction> for MilestoneOpenedAction {
	fn from(value: &MilestoneOpenedAction) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneOpenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Opened => "opened".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneOpenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"opened" => Ok(Self::Opened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneOpenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneOpenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneOpenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The state of the milestone.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MilestoneState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&MilestoneState> for MilestoneState {
	fn from(value: &MilestoneState) -> Self {
		value.clone()
	}
}
impl ToString for MilestoneState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for MilestoneState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for MilestoneState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for MilestoneState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for MilestoneState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockBlocked {
	pub action:       OrgBlockBlockedAction,
	/// Information about the user that was blocked or unblocked.
	pub blocked_user: User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrgBlockBlocked> for OrgBlockBlocked {
	fn from(value: &OrgBlockBlocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockBlockedAction {
	#[serde(rename = "blocked")]
	Blocked,
}
impl From<&OrgBlockBlockedAction> for OrgBlockBlockedAction {
	fn from(value: &OrgBlockBlockedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrgBlockBlockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Blocked => "blocked".to_string(),
		}
	}
}
impl std::str::FromStr for OrgBlockBlockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"blocked" => Ok(Self::Blocked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrgBlockBlockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrgBlockBlockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrgBlockBlockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrgBlockEvent {
	Blocked(OrgBlockBlocked),
	Unblocked(OrgBlockUnblocked),
}
impl From<&OrgBlockEvent> for OrgBlockEvent {
	fn from(value: &OrgBlockEvent) -> Self {
		value.clone()
	}
}
impl From<OrgBlockBlocked> for OrgBlockEvent {
	fn from(value: OrgBlockBlocked) -> Self {
		Self::Blocked(value)
	}
}
impl From<OrgBlockUnblocked> for OrgBlockEvent {
	fn from(value: OrgBlockUnblocked) -> Self {
		Self::Unblocked(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrgBlockUnblocked {
	pub action:       OrgBlockUnblockedAction,
	/// Information about the user that was blocked or unblocked.
	pub blocked_user: User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrgBlockUnblocked> for OrgBlockUnblocked {
	fn from(value: &OrgBlockUnblocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrgBlockUnblockedAction {
	#[serde(rename = "unblocked")]
	Unblocked,
}
impl From<&OrgBlockUnblockedAction> for OrgBlockUnblockedAction {
	fn from(value: &OrgBlockUnblockedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrgBlockUnblockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unblocked => "unblocked".to_string(),
		}
	}
}
impl std::str::FromStr for OrgBlockUnblockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unblocked" => Ok(Self::Unblocked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrgBlockUnblockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrgBlockUnblockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrgBlockUnblockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Organization {
	pub avatar_url:         String,
	pub description:        Option<String>,
	pub events_url:         String,
	pub hooks_url:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub html_url:           Option<String>,
	pub id:                 i64,
	pub issues_url:         String,
	pub login:              String,
	pub members_url:        String,
	pub node_id:            String,
	pub public_members_url: String,
	pub repos_url:          String,
	pub url:                String,
}
impl From<&Organization> for Organization {
	fn from(value: &Organization) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationDeleted {
	pub action:       OrganizationDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub membership:   Option<Membership>,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrganizationDeleted> for OrganizationDeleted {
	fn from(value: &OrganizationDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&OrganizationDeletedAction> for OrganizationDeletedAction {
	fn from(value: &OrganizationDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrganizationDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for OrganizationDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrganizationDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrganizationDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrganizationDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrganizationEvent {
	Deleted(OrganizationDeleted),
	MemberAdded(OrganizationMemberAdded),
	MemberInvited(OrganizationMemberInvited),
	MemberRemoved(OrganizationMemberRemoved),
	Renamed(OrganizationRenamed),
}
impl From<&OrganizationEvent> for OrganizationEvent {
	fn from(value: &OrganizationEvent) -> Self {
		value.clone()
	}
}
impl From<OrganizationDeleted> for OrganizationEvent {
	fn from(value: OrganizationDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<OrganizationMemberAdded> for OrganizationEvent {
	fn from(value: OrganizationMemberAdded) -> Self {
		Self::MemberAdded(value)
	}
}
impl From<OrganizationMemberInvited> for OrganizationEvent {
	fn from(value: OrganizationMemberInvited) -> Self {
		Self::MemberInvited(value)
	}
}
impl From<OrganizationMemberRemoved> for OrganizationEvent {
	fn from(value: OrganizationMemberRemoved) -> Self {
		Self::MemberRemoved(value)
	}
}
impl From<OrganizationRenamed> for OrganizationEvent {
	fn from(value: OrganizationRenamed) -> Self {
		Self::Renamed(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberAdded {
	pub action:       OrganizationMemberAddedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub membership:   Membership,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrganizationMemberAdded> for OrganizationMemberAdded {
	fn from(value: &OrganizationMemberAdded) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberAddedAction {
	#[serde(rename = "member_added")]
	MemberAdded,
}
impl From<&OrganizationMemberAddedAction> for OrganizationMemberAddedAction {
	fn from(value: &OrganizationMemberAddedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrganizationMemberAddedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::MemberAdded => "member_added".to_string(),
		}
	}
}
impl std::str::FromStr for OrganizationMemberAddedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"member_added" => Ok(Self::MemberAdded),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrganizationMemberAddedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrganizationMemberAddedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrganizationMemberAddedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvited {
	pub action:       OrganizationMemberInvitedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub invitation:   OrganizationMemberInvitedInvitation,
	pub organization: Organization,
	pub sender:       User,
	pub user:         User,
}
impl From<&OrganizationMemberInvited> for OrganizationMemberInvited {
	fn from(value: &OrganizationMemberInvited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberInvitedAction {
	#[serde(rename = "member_invited")]
	MemberInvited,
}
impl From<&OrganizationMemberInvitedAction> for OrganizationMemberInvitedAction {
	fn from(value: &OrganizationMemberInvitedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrganizationMemberInvitedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::MemberInvited => "member_invited".to_string(),
		}
	}
}
impl std::str::FromStr for OrganizationMemberInvitedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"member_invited" => Ok(Self::MemberInvited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrganizationMemberInvitedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrganizationMemberInvitedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrganizationMemberInvitedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The invitation for the user or email if the action is `member_invited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberInvitedInvitation {
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	pub email:                Option<String>,
	pub failed_at:            Option<chrono::DateTime<chrono::offset::Utc>>,
	pub failed_reason:        Option<String>,
	pub id:                   f64,
	pub invitation_teams_url: String,
	pub inviter:              User,
	pub login:                String,
	pub node_id:              String,
	pub role:                 String,
	pub team_count:           f64,
}
impl From<&OrganizationMemberInvitedInvitation> for OrganizationMemberInvitedInvitation {
	fn from(value: &OrganizationMemberInvitedInvitation) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationMemberRemoved {
	pub action:       OrganizationMemberRemovedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub membership:   Membership,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrganizationMemberRemoved> for OrganizationMemberRemoved {
	fn from(value: &OrganizationMemberRemoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationMemberRemovedAction {
	#[serde(rename = "member_removed")]
	MemberRemoved,
}
impl From<&OrganizationMemberRemovedAction> for OrganizationMemberRemovedAction {
	fn from(value: &OrganizationMemberRemovedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrganizationMemberRemovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::MemberRemoved => "member_removed".to_string(),
		}
	}
}
impl std::str::FromStr for OrganizationMemberRemovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"member_removed" => Ok(Self::MemberRemoved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrganizationMemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrganizationMemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrganizationMemberRemovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamed {
	pub action:       OrganizationRenamedAction,
	pub changes:      OrganizationRenamedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	pub sender:       User,
}
impl From<&OrganizationRenamed> for OrganizationRenamed {
	fn from(value: &OrganizationRenamed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrganizationRenamedAction {
	#[serde(rename = "renamed")]
	Renamed,
}
impl From<&OrganizationRenamedAction> for OrganizationRenamedAction {
	fn from(value: &OrganizationRenamedAction) -> Self {
		value.clone()
	}
}
impl ToString for OrganizationRenamedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Renamed => "renamed".to_string(),
		}
	}
}
impl std::str::FromStr for OrganizationRenamedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"renamed" => Ok(Self::Renamed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for OrganizationRenamedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for OrganizationRenamedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for OrganizationRenamedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamedChanges {
	pub login: OrganizationRenamedChangesLogin,
}
impl From<&OrganizationRenamedChanges> for OrganizationRenamedChanges {
	fn from(value: &OrganizationRenamedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrganizationRenamedChangesLogin {
	pub from: String,
}
impl From<&OrganizationRenamedChangesLogin> for OrganizationRenamedChangesLogin {
	fn from(value: &OrganizationRenamedChangesLogin) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackageEvent {
	Published(PackagePublished),
	Updated(PackageUpdated),
}
impl From<&PackageEvent> for PackageEvent {
	fn from(value: &PackageEvent) -> Self {
		value.clone()
	}
}
impl From<PackagePublished> for PackageEvent {
	fn from(value: PackagePublished) -> Self {
		Self::Published(value)
	}
}
impl From<PackageUpdated> for PackageEvent {
	fn from(value: PackageUpdated) -> Self {
		Self::Updated(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageNpmMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub author:                Option<std::collections::HashMap<String, String>>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub bin:                   std::collections::HashMap<String, serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub bugs:                  Option<std::collections::HashMap<String, String>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub commit_oid:            Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub contributors:          Vec<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub cpu:                   Vec<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub deleted_by_id:         Option<i64>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub dependencies:          std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description:           Option<String>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub dev_dependencies:      std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub directories:           Option<std::collections::HashMap<String, String>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub dist:                  Option<std::collections::HashMap<String, String>>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub engines:               std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub files:                 Vec<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub git_head:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub has_shrinkwrap:        Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub homepage:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub id:                    Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation_command:  Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub keywords:              Vec<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub license:               Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub main:                  Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub maintainers:           Vec<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub man:                   std::collections::HashMap<String, serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:                  Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub node_version:          Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_user:              Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_version:           Option<String>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub optional_dependencies: std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub os:                    Vec<String>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub peer_dependencies:     std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub published_via_actions: Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub readme:                Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub release_id:            Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:            Option<std::collections::HashMap<String, String>>,
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub scripts:               std::collections::HashMap<String, serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub version:               Option<String>,
}
impl From<&PackageNpmMetadata> for PackageNpmMetadata {
	fn from(value: &PackageNpmMetadata) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageNugetMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub id:    Option<PackageNugetMetadataId>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:  Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub value: Option<PackageNugetMetadataValue>,
}
impl From<&PackageNugetMetadata> for PackageNugetMetadata {
	fn from(value: &PackageNugetMetadata) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackageNugetMetadataId {
	Variant0(String),
	Variant1(std::collections::HashMap<String, serde_json::Value>),
	Variant2(i64),
}
impl From<&PackageNugetMetadataId> for PackageNugetMetadataId {
	fn from(value: &PackageNugetMetadataId) -> Self {
		value.clone()
	}
}
impl From<std::collections::HashMap<String, serde_json::Value>> for PackageNugetMetadataId {
	fn from(value: std::collections::HashMap<String, serde_json::Value>) -> Self {
		Self::Variant1(value)
	}
}
impl From<i64> for PackageNugetMetadataId {
	fn from(value: i64) -> Self {
		Self::Variant2(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PackageNugetMetadataValue {
	Variant0(bool),
	Variant1(String),
	Variant2(i64),
	Variant3 {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		branch: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		commit: Option<String>,
		#[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
		type_:  Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		url:    Option<String>,
	},
}
impl From<&PackageNugetMetadataValue> for PackageNugetMetadataValue {
	fn from(value: &PackageNugetMetadataValue) -> Self {
		value.clone()
	}
}
impl From<bool> for PackageNugetMetadataValue {
	fn from(value: bool) -> Self {
		Self::Variant0(value)
	}
}
impl From<i64> for PackageNugetMetadataValue {
	fn from(value: i64) -> Self {
		Self::Variant2(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublished {
	pub action:       PackagePublishedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub package:      PackagePublishedPackage,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PackagePublished> for PackagePublished {
	fn from(value: &PackagePublished) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackagePublishedAction {
	#[serde(rename = "published")]
	Published,
}
impl From<&PackagePublishedAction> for PackagePublishedAction {
	fn from(value: &PackagePublishedAction) -> Self {
		value.clone()
	}
}
impl ToString for PackagePublishedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Published => "published".to_string(),
		}
	}
}
impl std::str::FromStr for PackagePublishedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"published" => Ok(Self::Published),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Information about the package.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackage {
	pub created_at:      chrono::DateTime<chrono::offset::Utc>,
	pub description:     Option<String>,
	pub ecosystem:       String,
	pub html_url:        String,
	/// Unique identifier of the package.
	pub id:              i64,
	/// The name of the package.
	pub name:            String,
	pub namespace:       String,
	pub owner:           User,
	/// The type of supported package. Packages in GitHub's Gradle registry have
	/// the type `maven`. Docker images pushed to GitHub's Container registry
	/// (`ghcr.io`) have the type `container`. You can use the type `docker` to
	/// find images that were pushed to GitHub's Docker registry
	/// (`docker.pkg.github.com`), even if these have now been migrated to the
	/// Container registry.
	pub package_type:    PackagePublishedPackagePackageType,
	/// A version of a software package
	pub package_version: Option<PackagePublishedPackagePackageVersion>,
	pub registry:        PackagePublishedPackageRegistry,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
}
impl From<&PackagePublishedPackage> for PackagePublishedPackage {
	fn from(value: &PackagePublishedPackage) -> Self {
		value.clone()
	}
}
/// The type of supported package. Packages in GitHub's Gradle registry have the
/// type `maven`. Docker images pushed to GitHub's Container registry
/// (`ghcr.io`) have the type `container`. You can use the type `docker` to find
/// images that were pushed to GitHub's Docker registry
/// (`docker.pkg.github.com`), even if these have now been migrated to the
/// Container registry.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackagePublishedPackagePackageType {
	#[serde(rename = "npm")]
	Npm,
	#[serde(rename = "maven")]
	Maven,
	#[serde(rename = "rubygems")]
	Rubygems,
	#[serde(rename = "docker")]
	Docker,
	#[serde(rename = "nuget")]
	Nuget,
	#[serde(rename = "CONTAINER")]
	Container,
}
impl From<&PackagePublishedPackagePackageType> for PackagePublishedPackagePackageType {
	fn from(value: &PackagePublishedPackagePackageType) -> Self {
		value.clone()
	}
}
impl ToString for PackagePublishedPackagePackageType {
	fn to_string(&self) -> String {
		match *self {
			Self::Npm => "npm".to_string(),
			Self::Maven => "maven".to_string(),
			Self::Rubygems => "rubygems".to_string(),
			Self::Docker => "docker".to_string(),
			Self::Nuget => "nuget".to_string(),
			Self::Container => "CONTAINER".to_string(),
		}
	}
}
impl std::str::FromStr for PackagePublishedPackagePackageType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"npm" => Ok(Self::Npm),
			"maven" => Ok(Self::Maven),
			"rubygems" => Ok(Self::Rubygems),
			"docker" => Ok(Self::Docker),
			"nuget" => Ok(Self::Nuget),
			"CONTAINER" => Ok(Self::Container),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PackagePublishedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PackagePublishedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PackagePublishedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersion {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub author:               Option<User>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:                 Option<PackagePublishedPackagePackageVersionBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body_html:            Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub container_metadata:   Option<PackagePublishedPackagePackageVersionContainerMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub created_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub description:          String,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub docker_metadata:      Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:                Option<bool>,
	pub html_url:             String,
	/// Unique identifier of the package version.
	pub id:                   i64,
	pub installation_command: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:             Option<String>,
	/// Package Version Metadata
	pub metadata:             Vec<serde_json::Value>,
	/// The name of the package version.
	pub name:                 String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_metadata:         Option<PackageNpmMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub nuget_metadata:       Option<Vec<PackageNugetMetadata>>,
	pub package_files:        Vec<PackagePublishedPackagePackageVersionPackageFilesItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub package_url:          Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub prerelease:           Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub release:              Option<PackagePublishedPackagePackageVersionRelease>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub rubygems_metadata:    Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source_url:           Option<String>,
	pub summary:              String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag_name:             Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_commitish:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_oid:           Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub updated_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub version:              String,
}
impl From<&PackagePublishedPackagePackageVersion> for PackagePublishedPackagePackageVersion {
	fn from(value: &PackagePublishedPackagePackageVersion) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PackagePublishedPackagePackageVersionBody {
	Variant0(String),
	Variant1 {
		attributes: PackagePublishedPackagePackageVersionBodyVariant1Attributes,
		#[serde(rename = "_formatted")]
		formatted:  bool,
		info:       PackagePublishedPackagePackageVersionBodyVariant1Info,
		repository: PackagePublishedPackagePackageVersionBodyVariant1Repository,
	},
}
impl From<&PackagePublishedPackagePackageVersionBody>
	for PackagePublishedPackagePackageVersionBody
{
	fn from(value: &PackagePublishedPackagePackageVersionBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionBodyVariant1Attributes {}
impl From<&PackagePublishedPackagePackageVersionBodyVariant1Attributes>
	for PackagePublishedPackagePackageVersionBodyVariant1Attributes
{
	fn from(value: &PackagePublishedPackagePackageVersionBodyVariant1Attributes) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionBodyVariant1Info {
	pub collection: bool,
	pub mode:       i64,
	pub name:       String,
	pub oid:        String,
	pub path:       String,
	pub size:       Option<i64>,
	#[serde(rename = "type")]
	pub type_:      String,
}
impl From<&PackagePublishedPackagePackageVersionBodyVariant1Info>
	for PackagePublishedPackagePackageVersionBodyVariant1Info
{
	fn from(value: &PackagePublishedPackagePackageVersionBodyVariant1Info) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionBodyVariant1Repository {
	pub repository: Repository,
}
impl From<&PackagePublishedPackagePackageVersionBodyVariant1Repository>
	for PackagePublishedPackagePackageVersionBodyVariant1Repository
{
	fn from(value: &PackagePublishedPackagePackageVersionBodyVariant1Repository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionContainerMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub labels:   Option<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest: Option<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag:      Option<PackagePublishedPackagePackageVersionContainerMetadataTag>,
}
impl From<&PackagePublishedPackagePackageVersionContainerMetadata>
	for PackagePublishedPackagePackageVersionContainerMetadata
{
	fn from(value: &PackagePublishedPackagePackageVersionContainerMetadata) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionContainerMetadataTag {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:   Option<String>,
}
impl From<&PackagePublishedPackagePackageVersionContainerMetadataTag>
	for PackagePublishedPackagePackageVersionContainerMetadataTag
{
	fn from(value: &PackagePublishedPackagePackageVersionContainerMetadataTag) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionPackageFilesItem {
	pub content_type: String,
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	pub download_url: String,
	pub id:           i64,
	pub md5:          String,
	pub name:         String,
	pub sha1:         String,
	pub sha256:       String,
	pub size:         i64,
	pub state:        String,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&PackagePublishedPackagePackageVersionPackageFilesItem>
	for PackagePublishedPackagePackageVersionPackageFilesItem
{
	fn from(value: &PackagePublishedPackagePackageVersionPackageFilesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackagePackageVersionRelease {
	pub author:           User,
	pub created_at:       chrono::DateTime<chrono::offset::Utc>,
	pub draft:            bool,
	pub html_url:         String,
	pub id:               i64,
	pub name:             String,
	pub prerelease:       bool,
	pub published_at:     chrono::DateTime<chrono::offset::Utc>,
	pub tag_name:         String,
	pub target_commitish: String,
	pub url:              String,
}
impl From<&PackagePublishedPackagePackageVersionRelease>
	for PackagePublishedPackagePackageVersionRelease
{
	fn from(value: &PackagePublishedPackagePackageVersionRelease) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackagePublishedPackageRegistry {
	pub about_url: String,
	pub name:      String,
	#[serde(rename = "type")]
	pub type_:     String,
	pub url:       String,
	pub vendor:    String,
}
impl From<&PackagePublishedPackageRegistry> for PackagePublishedPackageRegistry {
	fn from(value: &PackagePublishedPackageRegistry) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdated {
	pub action:       PackageUpdatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub package:      PackageUpdatedPackage,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PackageUpdated> for PackageUpdated {
	fn from(value: &PackageUpdated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackageUpdatedAction {
	#[serde(rename = "updated")]
	Updated,
}
impl From<&PackageUpdatedAction> for PackageUpdatedAction {
	fn from(value: &PackageUpdatedAction) -> Self {
		value.clone()
	}
}
impl ToString for PackageUpdatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Updated => "updated".to_string(),
		}
	}
}
impl std::str::FromStr for PackageUpdatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"updated" => Ok(Self::Updated),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Information about the package.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackage {
	pub created_at:      chrono::DateTime<chrono::offset::Utc>,
	pub description:     Option<String>,
	pub ecosystem:       String,
	pub html_url:        String,
	/// Unique identifier of the package.
	pub id:              i64,
	/// The name of the package.
	pub name:            String,
	pub namespace:       String,
	pub owner:           User,
	pub package_type:    PackageUpdatedPackagePackageType,
	/// A version of a software package
	pub package_version: Option<PackageUpdatedPackagePackageVersion>,
	pub registry:        PackageUpdatedPackageRegistry,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
}
impl From<&PackageUpdatedPackage> for PackageUpdatedPackage {
	fn from(value: &PackageUpdatedPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackageUpdatedPackagePackageType {
	#[serde(rename = "npm")]
	Npm,
	#[serde(rename = "maven")]
	Maven,
	#[serde(rename = "rubygems")]
	Rubygems,
	#[serde(rename = "docker")]
	Docker,
	#[serde(rename = "nuget")]
	Nuget,
	#[serde(rename = "CONTAINER")]
	Container,
}
impl From<&PackageUpdatedPackagePackageType> for PackageUpdatedPackagePackageType {
	fn from(value: &PackageUpdatedPackagePackageType) -> Self {
		value.clone()
	}
}
impl ToString for PackageUpdatedPackagePackageType {
	fn to_string(&self) -> String {
		match *self {
			Self::Npm => "npm".to_string(),
			Self::Maven => "maven".to_string(),
			Self::Rubygems => "rubygems".to_string(),
			Self::Docker => "docker".to_string(),
			Self::Nuget => "nuget".to_string(),
			Self::Container => "CONTAINER".to_string(),
		}
	}
}
impl std::str::FromStr for PackageUpdatedPackagePackageType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"npm" => Ok(Self::Npm),
			"maven" => Ok(Self::Maven),
			"rubygems" => Ok(Self::Rubygems),
			"docker" => Ok(Self::Docker),
			"nuget" => Ok(Self::Nuget),
			"CONTAINER" => Ok(Self::Container),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PackageUpdatedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PackageUpdatedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PackageUpdatedPackagePackageType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersion {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub author:               Option<User>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:                 Option<PackageUpdatedPackagePackageVersionBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body_html:            Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub container_metadata:   Option<PackageUpdatedPackagePackageVersionContainerMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub created_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub description:          String,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub docker_metadata:      Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:                Option<bool>,
	pub html_url:             String,
	/// Unique identifier of the package version.
	pub id:                   i64,
	pub installation_command: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:             Option<String>,
	/// Package Version Metadata
	pub metadata:             Vec<serde_json::Value>,
	/// The name of the package version.
	pub name:                 String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_metadata:         Option<PackageNpmMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub nuget_metadata:       Option<Vec<PackageNugetMetadata>>,
	pub package_files:        Vec<PackageUpdatedPackagePackageVersionPackageFilesItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub package_url:          Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub prerelease:           Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub release:              Option<PackageUpdatedPackagePackageVersionRelease>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub rubygems_metadata:    Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source_url:           Option<String>,
	pub summary:              String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag_name:             Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_commitish:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_oid:           Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub updated_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub version:              String,
}
impl From<&PackageUpdatedPackagePackageVersion> for PackageUpdatedPackagePackageVersion {
	fn from(value: &PackageUpdatedPackagePackageVersion) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PackageUpdatedPackagePackageVersionBody {
	Variant0(String),
	Variant1 {
		attributes: PackageUpdatedPackagePackageVersionBodyVariant1Attributes,
		#[serde(rename = "_formatted")]
		formatted:  bool,
		info:       PackageUpdatedPackagePackageVersionBodyVariant1Info,
		repository: PackageUpdatedPackagePackageVersionBodyVariant1Repository,
	},
}
impl From<&PackageUpdatedPackagePackageVersionBody> for PackageUpdatedPackagePackageVersionBody {
	fn from(value: &PackageUpdatedPackagePackageVersionBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionBodyVariant1Attributes {}
impl From<&PackageUpdatedPackagePackageVersionBodyVariant1Attributes>
	for PackageUpdatedPackagePackageVersionBodyVariant1Attributes
{
	fn from(value: &PackageUpdatedPackagePackageVersionBodyVariant1Attributes) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionBodyVariant1Info {
	pub collection: bool,
	pub mode:       i64,
	pub name:       String,
	pub oid:        String,
	pub path:       String,
	pub size:       Option<i64>,
	#[serde(rename = "type")]
	pub type_:      String,
}
impl From<&PackageUpdatedPackagePackageVersionBodyVariant1Info>
	for PackageUpdatedPackagePackageVersionBodyVariant1Info
{
	fn from(value: &PackageUpdatedPackagePackageVersionBodyVariant1Info) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionBodyVariant1Repository {
	pub repository: Repository,
}
impl From<&PackageUpdatedPackagePackageVersionBodyVariant1Repository>
	for PackageUpdatedPackagePackageVersionBodyVariant1Repository
{
	fn from(value: &PackageUpdatedPackagePackageVersionBodyVariant1Repository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionContainerMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub labels:   Option<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest: Option<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag:      Option<PackageUpdatedPackagePackageVersionContainerMetadataTag>,
}
impl From<&PackageUpdatedPackagePackageVersionContainerMetadata>
	for PackageUpdatedPackagePackageVersionContainerMetadata
{
	fn from(value: &PackageUpdatedPackagePackageVersionContainerMetadata) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionContainerMetadataTag {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:   Option<String>,
}
impl From<&PackageUpdatedPackagePackageVersionContainerMetadataTag>
	for PackageUpdatedPackagePackageVersionContainerMetadataTag
{
	fn from(value: &PackageUpdatedPackagePackageVersionContainerMetadataTag) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionPackageFilesItem {
	pub content_type: String,
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	pub download_url: String,
	pub id:           i64,
	pub md5:          String,
	pub name:         String,
	pub sha1:         String,
	pub sha256:       String,
	pub size:         i64,
	pub state:        String,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&PackageUpdatedPackagePackageVersionPackageFilesItem>
	for PackageUpdatedPackagePackageVersionPackageFilesItem
{
	fn from(value: &PackageUpdatedPackagePackageVersionPackageFilesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackagePackageVersionRelease {
	pub author:           User,
	pub created_at:       chrono::DateTime<chrono::offset::Utc>,
	pub draft:            bool,
	pub html_url:         String,
	pub id:               i64,
	pub name:             String,
	pub prerelease:       bool,
	pub published_at:     chrono::DateTime<chrono::offset::Utc>,
	pub tag_name:         String,
	pub target_commitish: String,
	pub url:              String,
}
impl From<&PackageUpdatedPackagePackageVersionRelease>
	for PackageUpdatedPackagePackageVersionRelease
{
	fn from(value: &PackageUpdatedPackagePackageVersionRelease) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackageUpdatedPackageRegistry {
	pub about_url: String,
	pub name:      String,
	#[serde(rename = "type")]
	pub type_:     String,
	pub url:       String,
	pub vendor:    String,
}
impl From<&PackageUpdatedPackageRegistry> for PackageUpdatedPackageRegistry {
	fn from(value: &PackageUpdatedPackageRegistry) -> Self {
		value.clone()
	}
}
/// Page Build
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEvent {
	pub build:        PageBuildEventBuild,
	pub id:           i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PageBuildEvent> for PageBuildEvent {
	fn from(value: &PageBuildEvent) -> Self {
		value.clone()
	}
}
/// The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuild {
	pub commit:     String,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub duration:   i64,
	pub error:      PageBuildEventBuildError,
	pub pusher:     User,
	pub status:     String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	pub url:        String,
}
impl From<&PageBuildEventBuild> for PageBuildEventBuild {
	fn from(value: &PageBuildEventBuild) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PageBuildEventBuildError {
	pub message: Option<String>,
}
impl From<&PageBuildEventBuildError> for PageBuildEventBuildError {
	fn from(value: &PageBuildEventBuildError) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEvent {
	pub hook:         PingEventHook,
	/// The ID of the webhook that triggered the ping.
	pub hook_id:      i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub sender:       Option<User>,
	pub zen:          String,
}
impl From<&PingEvent> for PingEvent {
	fn from(value: &PingEvent) -> Self {
		value.clone()
	}
}
/// The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHook {
	pub active:         bool,
	/// When you register a new GitHub App, GitHub sends a ping event to the **webhook URL** you specified during registration. The event contains the `app_id`, which is required for [authenticating](https://docs.github.com/en/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps) an app.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub app_id:         Option<i64>,
	pub config:         PingEventHookConfig,
	pub created_at:     chrono::DateTime<chrono::offset::Utc>,
	pub deliveries_url: String,
	pub events:         WebhookEvents,
	pub id:             i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub last_response:  Option<PingEventHookLastResponse>,
	pub name:           String,
	pub ping_url:       String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub test_url:       Option<String>,
	#[serde(rename = "type")]
	pub type_:          PingEventHookType,
	pub updated_at:     chrono::DateTime<chrono::offset::Utc>,
	pub url:            String,
}
impl From<&PingEventHook> for PingEventHook {
	fn from(value: &PingEventHook) -> Self {
		value.clone()
	}
}
/// Configuration object of the webhook
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookConfig {
	/// The media type used to serialize the payloads. Supported values include
	/// `json` and `form`. The default is `form`.
	pub content_type: PingEventHookConfigContentType,
	/// Determines whether the SSL certificate of the host for `url` will be
	/// verified when delivering payloads. Supported values include `0`
	/// (verification is performed) and `1` (verification is not performed). The
	/// default is `0`.
	pub insecure_ssl: PingEventHookConfigInsecureSsl,
	/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub secret:       Option<String>,
	/// The URL to which the payloads will be delivered.
	pub url:          String,
}
impl From<&PingEventHookConfig> for PingEventHookConfig {
	fn from(value: &PingEventHookConfig) -> Self {
		value.clone()
	}
}
/// The media type used to serialize the payloads. Supported values include
/// `json` and `form`. The default is `form`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PingEventHookConfigContentType {
	#[serde(rename = "json")]
	Json,
	#[serde(rename = "form")]
	Form,
}
impl From<&PingEventHookConfigContentType> for PingEventHookConfigContentType {
	fn from(value: &PingEventHookConfigContentType) -> Self {
		value.clone()
	}
}
impl ToString for PingEventHookConfigContentType {
	fn to_string(&self) -> String {
		match *self {
			Self::Json => "json".to_string(),
			Self::Form => "form".to_string(),
		}
	}
}
impl std::str::FromStr for PingEventHookConfigContentType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"json" => Ok(Self::Json),
			"form" => Ok(Self::Form),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PingEventHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PingEventHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PingEventHookConfigContentType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Determines whether the SSL certificate of the host for `url` will be
/// verified when delivering payloads. Supported values include `0`
/// (verification is performed) and `1` (verification is not performed). The
/// default is `0`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PingEventHookConfigInsecureSsl {
	#[serde(rename = "0")]
	_0,
	#[serde(rename = "1")]
	_1,
}
impl From<&PingEventHookConfigInsecureSsl> for PingEventHookConfigInsecureSsl {
	fn from(value: &PingEventHookConfigInsecureSsl) -> Self {
		value.clone()
	}
}
impl ToString for PingEventHookConfigInsecureSsl {
	fn to_string(&self) -> String {
		match *self {
			Self::_0 => "0".to_string(),
			Self::_1 => "1".to_string(),
		}
	}
}
impl std::str::FromStr for PingEventHookConfigInsecureSsl {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"0" => Ok(Self::_0),
			"1" => Ok(Self::_1),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PingEventHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PingEventHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PingEventHookConfigInsecureSsl {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PingEventHookLastResponse {
	pub code:    (),
	pub message: (),
	pub status:  String,
}
impl From<&PingEventHookLastResponse> for PingEventHookLastResponse {
	fn from(value: &PingEventHookLastResponse) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PingEventHookType {
	Repository,
	Organization,
	App,
}
impl From<&PingEventHookType> for PingEventHookType {
	fn from(value: &PingEventHookType) -> Self {
		value.clone()
	}
}
impl ToString for PingEventHookType {
	fn to_string(&self) -> String {
		match *self {
			Self::Repository => "Repository".to_string(),
			Self::Organization => "Organization".to_string(),
			Self::App => "App".to_string(),
		}
	}
}
impl std::str::FromStr for PingEventHookType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"Repository" => Ok(Self::Repository),
			"Organization" => Ok(Self::Organization),
			"App" => Ok(Self::App),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PingEventHookType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PingEventHookType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PingEventHookType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Project {
	/// Body of the project
	pub body:        Option<String>,
	pub columns_url: String,
	pub created_at:  chrono::DateTime<chrono::offset::Utc>,
	pub creator:     User,
	pub html_url:    String,
	pub id:          i64,
	/// Name of the project
	pub name:        String,
	pub node_id:     String,
	pub number:      i64,
	pub owner_url:   String,
	/// State of the project; either 'open' or 'closed'
	pub state:       ProjectState,
	pub updated_at:  chrono::DateTime<chrono::offset::Utc>,
	pub url:         String,
}
impl From<&Project> for Project {
	fn from(value: &Project) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCard {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub after_id:    Option<ProjectCardAfterId>,
	/// Whether or not the card is archived
	pub archived:    bool,
	pub column_id:   i64,
	pub column_url:  String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub content_url: Option<String>,
	pub created_at:  chrono::DateTime<chrono::offset::Utc>,
	pub creator:     User,
	/// The project card's ID
	pub id:          i64,
	pub node_id:     String,
	pub note:        Option<String>,
	pub project_url: String,
	pub updated_at:  chrono::DateTime<chrono::offset::Utc>,
	pub url:         String,
}
impl From<&ProjectCard> for ProjectCard {
	fn from(value: &ProjectCard) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectCardAfterId {
	Variant0(String),
	Variant1(f64),
	Variant2,
}
impl From<&ProjectCardAfterId> for ProjectCardAfterId {
	fn from(value: &ProjectCardAfterId) -> Self {
		value.clone()
	}
}
impl From<f64> for ProjectCardAfterId {
	fn from(value: f64) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConverted {
	pub action:       ProjectCardConvertedAction,
	pub changes:      ProjectCardConvertedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project_card: ProjectCard,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
}
impl From<&ProjectCardConverted> for ProjectCardConverted {
	fn from(value: &ProjectCardConverted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardConvertedAction {
	#[serde(rename = "converted")]
	Converted,
}
impl From<&ProjectCardConvertedAction> for ProjectCardConvertedAction {
	fn from(value: &ProjectCardConvertedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCardConvertedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Converted => "converted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCardConvertedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"converted" => Ok(Self::Converted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCardConvertedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCardConvertedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCardConvertedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChanges {
	pub note: ProjectCardConvertedChangesNote,
}
impl From<&ProjectCardConvertedChanges> for ProjectCardConvertedChanges {
	fn from(value: &ProjectCardConvertedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardConvertedChangesNote {
	pub from: String,
}
impl From<&ProjectCardConvertedChangesNote> for ProjectCardConvertedChangesNote {
	fn from(value: &ProjectCardConvertedChangesNote) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardCreated {
	pub action:       ProjectCardCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project_card: ProjectCard,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
}
impl From<&ProjectCardCreated> for ProjectCardCreated {
	fn from(value: &ProjectCardCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&ProjectCardCreatedAction> for ProjectCardCreatedAction {
	fn from(value: &ProjectCardCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCardCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCardCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCardCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCardCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCardCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardDeleted {
	pub action:       ProjectCardDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project_card: ProjectCard,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
}
impl From<&ProjectCardDeleted> for ProjectCardDeleted {
	fn from(value: &ProjectCardDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&ProjectCardDeletedAction> for ProjectCardDeletedAction {
	fn from(value: &ProjectCardDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCardDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCardDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCardDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCardDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCardDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEdited {
	pub action:       ProjectCardEditedAction,
	pub changes:      ProjectCardEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project_card: ProjectCard,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
}
impl From<&ProjectCardEdited> for ProjectCardEdited {
	fn from(value: &ProjectCardEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&ProjectCardEditedAction> for ProjectCardEditedAction {
	fn from(value: &ProjectCardEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCardEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCardEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCardEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCardEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCardEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChanges {
	pub note: ProjectCardEditedChangesNote,
}
impl From<&ProjectCardEditedChanges> for ProjectCardEditedChanges {
	fn from(value: &ProjectCardEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardEditedChangesNote {
	pub from: String,
}
impl From<&ProjectCardEditedChangesNote> for ProjectCardEditedChangesNote {
	fn from(value: &ProjectCardEditedChangesNote) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectCardEvent {
	Converted(ProjectCardConverted),
	Created(ProjectCardCreated),
	Deleted(ProjectCardDeleted),
	Edited(ProjectCardEdited),
	Moved(ProjectCardMoved),
}
impl From<&ProjectCardEvent> for ProjectCardEvent {
	fn from(value: &ProjectCardEvent) -> Self {
		value.clone()
	}
}
impl From<ProjectCardConverted> for ProjectCardEvent {
	fn from(value: ProjectCardConverted) -> Self {
		Self::Converted(value)
	}
}
impl From<ProjectCardCreated> for ProjectCardEvent {
	fn from(value: ProjectCardCreated) -> Self {
		Self::Created(value)
	}
}
impl From<ProjectCardDeleted> for ProjectCardEvent {
	fn from(value: ProjectCardDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<ProjectCardEdited> for ProjectCardEvent {
	fn from(value: ProjectCardEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<ProjectCardMoved> for ProjectCardEvent {
	fn from(value: ProjectCardMoved) -> Self {
		Self::Moved(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMoved {
	pub action:       ProjectCardMovedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<ProjectCardMovedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project_card: ProjectCard,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
}
impl From<&ProjectCardMoved> for ProjectCardMoved {
	fn from(value: &ProjectCardMoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCardMovedAction {
	#[serde(rename = "moved")]
	Moved,
}
impl From<&ProjectCardMovedAction> for ProjectCardMovedAction {
	fn from(value: &ProjectCardMovedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCardMovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Moved => "moved".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCardMovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"moved" => Ok(Self::Moved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCardMovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCardMovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCardMovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChanges {
	pub column_id: ProjectCardMovedChangesColumnId,
}
impl From<&ProjectCardMovedChanges> for ProjectCardMovedChanges {
	fn from(value: &ProjectCardMovedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCardMovedChangesColumnId {
	pub from: i64,
}
impl From<&ProjectCardMovedChangesColumnId> for ProjectCardMovedChangesColumnId {
	fn from(value: &ProjectCardMovedChangesColumnId) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectClosed {
	pub action:       ProjectClosedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project:      Project,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ProjectClosed> for ProjectClosed {
	fn from(value: &ProjectClosed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectClosedAction {
	#[serde(rename = "closed")]
	Closed,
}
impl From<&ProjectClosedAction> for ProjectClosedAction {
	fn from(value: &ProjectClosedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectClosedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectClosedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectClosedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectClosedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectClosedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumn {
	pub cards_url:   String,
	pub created_at:  chrono::DateTime<chrono::offset::Utc>,
	/// The unique identifier of the project column
	pub id:          i64,
	/// Name of the project column
	pub name:        String,
	pub node_id:     String,
	pub project_url: String,
	pub updated_at:  chrono::DateTime<chrono::offset::Utc>,
	pub url:         String,
}
impl From<&ProjectColumn> for ProjectColumn {
	fn from(value: &ProjectColumn) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnCreated {
	pub action:         ProjectColumnCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:   Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:   Option<Organization>,
	pub project_column: ProjectColumn,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:     Option<Repository>,
	pub sender:         User,
}
impl From<&ProjectColumnCreated> for ProjectColumnCreated {
	fn from(value: &ProjectColumnCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&ProjectColumnCreatedAction> for ProjectColumnCreatedAction {
	fn from(value: &ProjectColumnCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectColumnCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectColumnCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectColumnCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectColumnCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectColumnCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnDeleted {
	pub action:         ProjectColumnDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:   Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:   Option<Organization>,
	pub project_column: ProjectColumn,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:     Option<Repository>,
	pub sender:         User,
}
impl From<&ProjectColumnDeleted> for ProjectColumnDeleted {
	fn from(value: &ProjectColumnDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&ProjectColumnDeletedAction> for ProjectColumnDeletedAction {
	fn from(value: &ProjectColumnDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectColumnDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectColumnDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectColumnDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectColumnDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectColumnDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEdited {
	pub action:         ProjectColumnEditedAction,
	pub changes:        ProjectColumnEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:   Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:   Option<Organization>,
	pub project_column: ProjectColumn,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:     Option<Repository>,
	pub sender:         User,
}
impl From<&ProjectColumnEdited> for ProjectColumnEdited {
	fn from(value: &ProjectColumnEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&ProjectColumnEditedAction> for ProjectColumnEditedAction {
	fn from(value: &ProjectColumnEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectColumnEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectColumnEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectColumnEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectColumnEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectColumnEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name: Option<ProjectColumnEditedChangesName>,
}
impl From<&ProjectColumnEditedChanges> for ProjectColumnEditedChanges {
	fn from(value: &ProjectColumnEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnEditedChangesName {
	pub from: String,
}
impl From<&ProjectColumnEditedChangesName> for ProjectColumnEditedChangesName {
	fn from(value: &ProjectColumnEditedChangesName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectColumnEvent {
	Created(ProjectColumnCreated),
	Deleted(ProjectColumnDeleted),
	Edited(ProjectColumnEdited),
	Moved(ProjectColumnMoved),
}
impl From<&ProjectColumnEvent> for ProjectColumnEvent {
	fn from(value: &ProjectColumnEvent) -> Self {
		value.clone()
	}
}
impl From<ProjectColumnCreated> for ProjectColumnEvent {
	fn from(value: ProjectColumnCreated) -> Self {
		Self::Created(value)
	}
}
impl From<ProjectColumnDeleted> for ProjectColumnEvent {
	fn from(value: ProjectColumnDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<ProjectColumnEdited> for ProjectColumnEvent {
	fn from(value: ProjectColumnEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<ProjectColumnMoved> for ProjectColumnEvent {
	fn from(value: ProjectColumnMoved) -> Self {
		Self::Moved(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectColumnMoved {
	pub action:         ProjectColumnMovedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:   Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:   Option<Organization>,
	pub project_column: ProjectColumn,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:     Option<Repository>,
	pub sender:         User,
}
impl From<&ProjectColumnMoved> for ProjectColumnMoved {
	fn from(value: &ProjectColumnMoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectColumnMovedAction {
	#[serde(rename = "moved")]
	Moved,
}
impl From<&ProjectColumnMovedAction> for ProjectColumnMovedAction {
	fn from(value: &ProjectColumnMovedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectColumnMovedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Moved => "moved".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectColumnMovedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"moved" => Ok(Self::Moved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectColumnMovedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectColumnMovedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectColumnMovedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectCreated {
	pub action:       ProjectCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project:      Project,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ProjectCreated> for ProjectCreated {
	fn from(value: &ProjectCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&ProjectCreatedAction> for ProjectCreatedAction {
	fn from(value: &ProjectCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectDeleted {
	pub action:       ProjectDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project:      Project,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ProjectDeleted> for ProjectDeleted {
	fn from(value: &ProjectDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&ProjectDeletedAction> for ProjectDeletedAction {
	fn from(value: &ProjectDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEdited {
	pub action:       ProjectEditedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub changes:      Option<ProjectEditedChanges>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project:      Project,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ProjectEdited> for ProjectEdited {
	fn from(value: &ProjectEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&ProjectEditedAction> for ProjectEditedAction {
	fn from(value: &ProjectEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the project if the action was `edited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body: Option<ProjectEditedChangesBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name: Option<ProjectEditedChangesName>,
}
impl From<&ProjectEditedChanges> for ProjectEditedChanges {
	fn from(value: &ProjectEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesBody {
	/// The previous version of the body if the action was `edited`.
	pub from: String,
}
impl From<&ProjectEditedChangesBody> for ProjectEditedChangesBody {
	fn from(value: &ProjectEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectEditedChangesName {
	/// The changes to the project if the action was `edited`.
	pub from: String,
}
impl From<&ProjectEditedChangesName> for ProjectEditedChangesName {
	fn from(value: &ProjectEditedChangesName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectEvent {
	Closed(ProjectClosed),
	Created(ProjectCreated),
	Deleted(ProjectDeleted),
	Edited(ProjectEdited),
	Reopened(ProjectReopened),
}
impl From<&ProjectEvent> for ProjectEvent {
	fn from(value: &ProjectEvent) -> Self {
		value.clone()
	}
}
impl From<ProjectClosed> for ProjectEvent {
	fn from(value: ProjectClosed) -> Self {
		Self::Closed(value)
	}
}
impl From<ProjectCreated> for ProjectEvent {
	fn from(value: ProjectCreated) -> Self {
		Self::Created(value)
	}
}
impl From<ProjectDeleted> for ProjectEvent {
	fn from(value: ProjectDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<ProjectEdited> for ProjectEvent {
	fn from(value: ProjectEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<ProjectReopened> for ProjectEvent {
	fn from(value: ProjectReopened) -> Self {
		Self::Reopened(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectReopened {
	pub action:       ProjectReopenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub project:      Project,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ProjectReopened> for ProjectReopened {
	fn from(value: &ProjectReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&ProjectReopenedAction> for ProjectReopenedAction {
	fn from(value: &ProjectReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// State of the project; either 'open' or 'closed'
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&ProjectState> for ProjectState {
	fn from(value: &ProjectState) -> Self {
		value.clone()
	}
}
impl ToString for ProjectState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The project item itself. To find more information about the project item, you can use `node_id` (the node ID of the project item) and `project_node_id` (the node ID of the project) to query information in the GraphQL API. For more information, see "[Using the API to manage projects](https://docs.github.com/en/issues/trying-out-the-new-projects-experience/using-the-api-to-manage-projects)."
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2Item {
	pub archived_at:     Option<chrono::DateTime<chrono::offset::Utc>>,
	pub content_node_id: String,
	pub content_type:    ProjectsV2ItemContentType,
	pub created_at:      chrono::DateTime<chrono::offset::Utc>,
	pub creator:         User,
	pub id:              f64,
	pub node_id:         String,
	pub project_node_id: String,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
}
impl From<&ProjectsV2Item> for ProjectsV2Item {
	fn from(value: &ProjectsV2Item) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemArchived {
	pub action:           ProjectsV2ItemArchivedAction,
	pub changes:          ProjectsV2ItemArchivedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemArchived> for ProjectsV2ItemArchived {
	fn from(value: &ProjectsV2ItemArchived) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemArchivedAction {
	#[serde(rename = "archived")]
	Archived,
}
impl From<&ProjectsV2ItemArchivedAction> for ProjectsV2ItemArchivedAction {
	fn from(value: &ProjectsV2ItemArchivedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemArchivedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Archived => "archived".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemArchivedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"archived" => Ok(Self::Archived),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemArchivedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemArchivedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemArchivedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemArchivedChanges {
	pub archived_at: ProjectsV2ItemArchivedChangesArchivedAt,
}
impl From<&ProjectsV2ItemArchivedChanges> for ProjectsV2ItemArchivedChanges {
	fn from(value: &ProjectsV2ItemArchivedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemArchivedChangesArchivedAt {
	pub from: (),
	pub to:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&ProjectsV2ItemArchivedChangesArchivedAt> for ProjectsV2ItemArchivedChangesArchivedAt {
	fn from(value: &ProjectsV2ItemArchivedChangesArchivedAt) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemContentType {
	DraftIssue,
	Issue,
	PullRequest,
}
impl From<&ProjectsV2ItemContentType> for ProjectsV2ItemContentType {
	fn from(value: &ProjectsV2ItemContentType) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemContentType {
	fn to_string(&self) -> String {
		match *self {
			Self::DraftIssue => "DraftIssue".to_string(),
			Self::Issue => "Issue".to_string(),
			Self::PullRequest => "PullRequest".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemContentType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"DraftIssue" => Ok(Self::DraftIssue),
			"Issue" => Ok(Self::Issue),
			"PullRequest" => Ok(Self::PullRequest),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemContentType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemContentType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemContentType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemConverted {
	pub action:           ProjectsV2ItemConvertedAction,
	pub changes:          ProjectsV2ItemConvertedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemConverted> for ProjectsV2ItemConverted {
	fn from(value: &ProjectsV2ItemConverted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemConvertedAction {
	#[serde(rename = "converted")]
	Converted,
}
impl From<&ProjectsV2ItemConvertedAction> for ProjectsV2ItemConvertedAction {
	fn from(value: &ProjectsV2ItemConvertedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemConvertedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Converted => "converted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemConvertedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"converted" => Ok(Self::Converted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemConvertedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemConvertedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemConvertedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemConvertedChanges {
	pub content_type: ProjectsV2ItemConvertedChangesContentType,
}
impl From<&ProjectsV2ItemConvertedChanges> for ProjectsV2ItemConvertedChanges {
	fn from(value: &ProjectsV2ItemConvertedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemConvertedChangesContentType {
	pub from: ProjectsV2ItemConvertedChangesContentTypeFrom,
	pub to:   ProjectsV2ItemConvertedChangesContentTypeTo,
}
impl From<&ProjectsV2ItemConvertedChangesContentType>
	for ProjectsV2ItemConvertedChangesContentType
{
	fn from(value: &ProjectsV2ItemConvertedChangesContentType) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemConvertedChangesContentTypeFrom {
	DraftIssue,
}
impl From<&ProjectsV2ItemConvertedChangesContentTypeFrom>
	for ProjectsV2ItemConvertedChangesContentTypeFrom
{
	fn from(value: &ProjectsV2ItemConvertedChangesContentTypeFrom) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemConvertedChangesContentTypeFrom {
	fn to_string(&self) -> String {
		match *self {
			Self::DraftIssue => "DraftIssue".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemConvertedChangesContentTypeFrom {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"DraftIssue" => Ok(Self::DraftIssue),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemConvertedChangesContentTypeFrom {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemConvertedChangesContentTypeFrom {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemConvertedChangesContentTypeFrom {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemConvertedChangesContentTypeTo {
	Issue,
}
impl From<&ProjectsV2ItemConvertedChangesContentTypeTo>
	for ProjectsV2ItemConvertedChangesContentTypeTo
{
	fn from(value: &ProjectsV2ItemConvertedChangesContentTypeTo) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemConvertedChangesContentTypeTo {
	fn to_string(&self) -> String {
		match *self {
			Self::Issue => "Issue".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemConvertedChangesContentTypeTo {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"Issue" => Ok(Self::Issue),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemConvertedChangesContentTypeTo {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemConvertedChangesContentTypeTo {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemConvertedChangesContentTypeTo {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemCreated {
	pub action:           ProjectsV2ItemCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemCreated> for ProjectsV2ItemCreated {
	fn from(value: &ProjectsV2ItemCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&ProjectsV2ItemCreatedAction> for ProjectsV2ItemCreatedAction {
	fn from(value: &ProjectsV2ItemCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemDeleted {
	pub action:           ProjectsV2ItemDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemDeleted> for ProjectsV2ItemDeleted {
	fn from(value: &ProjectsV2ItemDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&ProjectsV2ItemDeletedAction> for ProjectsV2ItemDeletedAction {
	fn from(value: &ProjectsV2ItemDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemEdited {
	pub action:           ProjectsV2ItemEditedAction,
	pub changes:          ProjectsV2ItemEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemEdited> for ProjectsV2ItemEdited {
	fn from(value: &ProjectsV2ItemEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&ProjectsV2ItemEditedAction> for ProjectsV2ItemEditedAction {
	fn from(value: &ProjectsV2ItemEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemEditedChanges {
	pub field_value: ProjectsV2ItemEditedChangesFieldValue,
}
impl From<&ProjectsV2ItemEditedChanges> for ProjectsV2ItemEditedChanges {
	fn from(value: &ProjectsV2ItemEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemEditedChangesFieldValue {
	pub field_node_id: String,
	pub field_type:    ProjectsV2ItemEditedChangesFieldValueFieldType,
}
impl From<&ProjectsV2ItemEditedChangesFieldValue> for ProjectsV2ItemEditedChangesFieldValue {
	fn from(value: &ProjectsV2ItemEditedChangesFieldValue) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemEditedChangesFieldValueFieldType {
	#[serde(rename = "single_select")]
	SingleSelect,
	#[serde(rename = "date")]
	Date,
	#[serde(rename = "number")]
	Number,
	#[serde(rename = "text")]
	Text,
	#[serde(rename = "iteration")]
	Iteration,
}
impl From<&ProjectsV2ItemEditedChangesFieldValueFieldType>
	for ProjectsV2ItemEditedChangesFieldValueFieldType
{
	fn from(value: &ProjectsV2ItemEditedChangesFieldValueFieldType) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemEditedChangesFieldValueFieldType {
	fn to_string(&self) -> String {
		match *self {
			Self::SingleSelect => "single_select".to_string(),
			Self::Date => "date".to_string(),
			Self::Number => "number".to_string(),
			Self::Text => "text".to_string(),
			Self::Iteration => "iteration".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemEditedChangesFieldValueFieldType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"single_select" => Ok(Self::SingleSelect),
			"date" => Ok(Self::Date),
			"number" => Ok(Self::Number),
			"text" => Ok(Self::Text),
			"iteration" => Ok(Self::Iteration),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemEditedChangesFieldValueFieldType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemEditedChangesFieldValueFieldType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemEditedChangesFieldValueFieldType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectsV2ItemEvent {
	Archived(ProjectsV2ItemArchived),
	Converted(ProjectsV2ItemConverted),
	Created(ProjectsV2ItemCreated),
	Deleted(ProjectsV2ItemDeleted),
	Edited(ProjectsV2ItemEdited),
	Reordered(ProjectsV2ItemReordered),
	Restored(ProjectsV2ItemRestored),
}
impl From<&ProjectsV2ItemEvent> for ProjectsV2ItemEvent {
	fn from(value: &ProjectsV2ItemEvent) -> Self {
		value.clone()
	}
}
impl From<ProjectsV2ItemArchived> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemArchived) -> Self {
		Self::Archived(value)
	}
}
impl From<ProjectsV2ItemConverted> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemConverted) -> Self {
		Self::Converted(value)
	}
}
impl From<ProjectsV2ItemCreated> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemCreated) -> Self {
		Self::Created(value)
	}
}
impl From<ProjectsV2ItemDeleted> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<ProjectsV2ItemEdited> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<ProjectsV2ItemReordered> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemReordered) -> Self {
		Self::Reordered(value)
	}
}
impl From<ProjectsV2ItemRestored> for ProjectsV2ItemEvent {
	fn from(value: ProjectsV2ItemRestored) -> Self {
		Self::Restored(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemReordered {
	pub action:           ProjectsV2ItemReorderedAction,
	pub changes:          ProjectsV2ItemReorderedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemReordered> for ProjectsV2ItemReordered {
	fn from(value: &ProjectsV2ItemReordered) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemReorderedAction {
	#[serde(rename = "reordered")]
	Reordered,
}
impl From<&ProjectsV2ItemReorderedAction> for ProjectsV2ItemReorderedAction {
	fn from(value: &ProjectsV2ItemReorderedAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemReorderedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reordered => "reordered".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemReorderedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reordered" => Ok(Self::Reordered),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemReorderedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemReorderedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemReorderedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemReorderedChanges {
	pub previous_projects_v2_item_node_id:
		ProjectsV2ItemReorderedChangesPreviousProjectsV2ItemNodeId,
}
impl From<&ProjectsV2ItemReorderedChanges> for ProjectsV2ItemReorderedChanges {
	fn from(value: &ProjectsV2ItemReorderedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemReorderedChangesPreviousProjectsV2ItemNodeId {
	pub from: String,
	pub to:   Option<String>,
}
impl From<&ProjectsV2ItemReorderedChangesPreviousProjectsV2ItemNodeId>
	for ProjectsV2ItemReorderedChangesPreviousProjectsV2ItemNodeId
{
	fn from(value: &ProjectsV2ItemReorderedChangesPreviousProjectsV2ItemNodeId) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemRestored {
	pub action:           ProjectsV2ItemRestoredAction,
	pub changes:          ProjectsV2ItemRestoredChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation:     Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub projects_v2_item: ProjectsV2Item,
	pub sender:           User,
}
impl From<&ProjectsV2ItemRestored> for ProjectsV2ItemRestored {
	fn from(value: &ProjectsV2ItemRestored) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectsV2ItemRestoredAction {
	#[serde(rename = "restored")]
	Restored,
}
impl From<&ProjectsV2ItemRestoredAction> for ProjectsV2ItemRestoredAction {
	fn from(value: &ProjectsV2ItemRestoredAction) -> Self {
		value.clone()
	}
}
impl ToString for ProjectsV2ItemRestoredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Restored => "restored".to_string(),
		}
	}
}
impl std::str::FromStr for ProjectsV2ItemRestoredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"restored" => Ok(Self::Restored),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ProjectsV2ItemRestoredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ProjectsV2ItemRestoredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ProjectsV2ItemRestoredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemRestoredChanges {
	pub archived_at: ProjectsV2ItemRestoredChangesArchivedAt,
}
impl From<&ProjectsV2ItemRestoredChanges> for ProjectsV2ItemRestoredChanges {
	fn from(value: &ProjectsV2ItemRestoredChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectsV2ItemRestoredChangesArchivedAt {
	pub from: chrono::DateTime<chrono::offset::Utc>,
	pub to:   (),
}
impl From<&ProjectsV2ItemRestoredChangesArchivedAt> for ProjectsV2ItemRestoredChangesArchivedAt {
	fn from(value: &ProjectsV2ItemRestoredChangesArchivedAt) -> Self {
		value.clone()
	}
}
/// When a private repository is made public.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PublicEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PublicEvent> for PublicEvent {
	fn from(value: &PublicEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequest {
	pub active_lock_reason:    Option<PullRequestActiveLockReason>,
	pub additions:             i64,
	pub assignee:              Option<User>,
	pub assignees:             Vec<User>,
	pub author_association:    AuthorAssociation,
	pub auto_merge:            Option<AutoMerge>,
	pub base:                  PullRequestBase,
	pub body:                  Option<String>,
	pub changed_files:         i64,
	pub closed_at:             Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments:              i64,
	pub comments_url:          String,
	pub commits:               i64,
	pub commits_url:           String,
	pub created_at:            chrono::DateTime<chrono::offset::Utc>,
	pub deletions:             i64,
	pub diff_url:              String,
	/// Indicates whether or not the pull request is a draft.
	pub draft:                 bool,
	pub head:                  PullRequestHead,
	pub html_url:              String,
	pub id:                    i64,
	pub issue_url:             String,
	pub labels:                Vec<Label>,
	#[serde(rename = "_links")]
	pub links:                 PullRequestLinks,
	pub locked:                bool,
	/// Indicates whether maintainers can modify the pull request.
	pub maintainer_can_modify: bool,
	pub merge_commit_sha:      Option<String>,
	pub mergeable:             Option<bool>,
	pub mergeable_state:       String,
	pub merged:                Option<bool>,
	pub merged_at:             Option<chrono::DateTime<chrono::offset::Utc>>,
	pub merged_by:             Option<User>,
	pub milestone:             Option<Milestone>,
	pub node_id:               String,
	/// Number uniquely identifying the pull request within its repository.
	pub number:                i64,
	pub patch_url:             String,
	pub rebaseable:            Option<bool>,
	pub requested_reviewers:   Vec<PullRequestRequestedReviewersItem>,
	pub requested_teams:       Vec<Team>,
	pub review_comment_url:    String,
	pub review_comments:       i64,
	pub review_comments_url:   String,
	/// State of this Pull Request. Either `open` or `closed`.
	pub state:                 PullRequestState,
	pub statuses_url:          String,
	/// The title of the pull request.
	pub title:                 String,
	pub updated_at:            chrono::DateTime<chrono::offset::Utc>,
	pub url:                   String,
	pub user:                  User,
}
impl From<&PullRequest> for PullRequest {
	fn from(value: &PullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&PullRequestActiveLockReason> for PullRequestActiveLockReason {
	fn from(value: &PullRequestActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAssigned {
	pub action:       PullRequestAssignedAction,
	pub assignee:     User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestAssigned> for PullRequestAssigned {
	fn from(value: &PullRequestAssigned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAssignedAction {
	#[serde(rename = "assigned")]
	Assigned,
}
impl From<&PullRequestAssignedAction> for PullRequestAssignedAction {
	fn from(value: &PullRequestAssignedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestAssignedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Assigned => "assigned".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestAssignedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"assigned" => Ok(Self::Assigned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestAssignedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestAssignedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestAssignedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeDisabled {
	pub action:       PullRequestAutoMergeDisabledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub reason:       String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestAutoMergeDisabled> for PullRequestAutoMergeDisabled {
	fn from(value: &PullRequestAutoMergeDisabled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeDisabledAction {
	#[serde(rename = "auto_merge_disabled")]
	AutoMergeDisabled,
}
impl From<&PullRequestAutoMergeDisabledAction> for PullRequestAutoMergeDisabledAction {
	fn from(value: &PullRequestAutoMergeDisabledAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestAutoMergeDisabledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::AutoMergeDisabled => "auto_merge_disabled".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestAutoMergeDisabledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"auto_merge_disabled" => Ok(Self::AutoMergeDisabled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeDisabledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeDisabledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeDisabledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestAutoMergeEnabled {
	pub action:       PullRequestAutoMergeEnabledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub reason:       String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestAutoMergeEnabled> for PullRequestAutoMergeEnabled {
	fn from(value: &PullRequestAutoMergeEnabled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestAutoMergeEnabledAction {
	#[serde(rename = "auto_merge_enabled")]
	AutoMergeEnabled,
}
impl From<&PullRequestAutoMergeEnabledAction> for PullRequestAutoMergeEnabledAction {
	fn from(value: &PullRequestAutoMergeEnabledAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestAutoMergeEnabledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::AutoMergeEnabled => "auto_merge_enabled".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestAutoMergeEnabledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"auto_merge_enabled" => Ok(Self::AutoMergeEnabled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestAutoMergeEnabledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestAutoMergeEnabledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestAutoMergeEnabledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestBase {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestBase> for PullRequestBase {
	fn from(value: &PullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestClosed {
	pub action:       PullRequestClosedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestClosed> for PullRequestClosed {
	fn from(value: &PullRequestClosed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestClosedAction {
	#[serde(rename = "closed")]
	Closed,
}
impl From<&PullRequestClosedAction> for PullRequestClosedAction {
	fn from(value: &PullRequestClosedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestClosedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestClosedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestClosedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestClosedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestClosedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestConvertedToDraft {
	pub action:       PullRequestConvertedToDraftAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestConvertedToDraft> for PullRequestConvertedToDraft {
	fn from(value: &PullRequestConvertedToDraft) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestConvertedToDraftAction {
	#[serde(rename = "converted_to_draft")]
	ConvertedToDraft,
}
impl From<&PullRequestConvertedToDraftAction> for PullRequestConvertedToDraftAction {
	fn from(value: &PullRequestConvertedToDraftAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestConvertedToDraftAction {
	fn to_string(&self) -> String {
		match *self {
			Self::ConvertedToDraft => "converted_to_draft".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestConvertedToDraftAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"converted_to_draft" => Ok(Self::ConvertedToDraft),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestConvertedToDraftAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestConvertedToDraftAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestConvertedToDraftAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestDemilestoned {
	pub action:       PullRequestDemilestonedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestDemilestoned> for PullRequestDemilestoned {
	fn from(value: &PullRequestDemilestoned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestDemilestonedAction {
	#[serde(rename = "demilestoned")]
	Demilestoned,
}
impl From<&PullRequestDemilestonedAction> for PullRequestDemilestonedAction {
	fn from(value: &PullRequestDemilestonedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestDemilestonedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Demilestoned => "demilestoned".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestDemilestonedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"demilestoned" => Ok(Self::Demilestoned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestDemilestonedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestDequeued {
	pub action:       PullRequestDequeuedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	/// The reason the pull request was removed from a merge queue.
	pub reason:       String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestDequeued> for PullRequestDequeued {
	fn from(value: &PullRequestDequeued) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestDequeuedAction {
	#[serde(rename = "dequeued")]
	Dequeued,
}
impl From<&PullRequestDequeuedAction> for PullRequestDequeuedAction {
	fn from(value: &PullRequestDequeuedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestDequeuedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Dequeued => "dequeued".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestDequeuedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dequeued" => Ok(Self::Dequeued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestDequeuedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestDequeuedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestDequeuedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEdited {
	pub action:       PullRequestEditedAction,
	pub changes:      PullRequestEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestEdited> for PullRequestEdited {
	fn from(value: &PullRequestEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&PullRequestEditedAction> for PullRequestEditedAction {
	fn from(value: &PullRequestEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the comment if the action was `edited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub base:  Option<PullRequestEditedChangesBase>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:  Option<PullRequestEditedChangesBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub title: Option<PullRequestEditedChangesTitle>,
}
impl From<&PullRequestEditedChanges> for PullRequestEditedChanges {
	fn from(value: &PullRequestEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBase {
	#[serde(rename = "ref")]
	pub ref_: PullRequestEditedChangesBaseRef,
	pub sha:  PullRequestEditedChangesBaseSha,
}
impl From<&PullRequestEditedChangesBase> for PullRequestEditedChangesBase {
	fn from(value: &PullRequestEditedChangesBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBaseRef {
	pub from: String,
}
impl From<&PullRequestEditedChangesBaseRef> for PullRequestEditedChangesBaseRef {
	fn from(value: &PullRequestEditedChangesBaseRef) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBaseSha {
	pub from: String,
}
impl From<&PullRequestEditedChangesBaseSha> for PullRequestEditedChangesBaseSha {
	fn from(value: &PullRequestEditedChangesBaseSha) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesBody {
	/// The previous version of the body if the action was `edited`.
	pub from: String,
}
impl From<&PullRequestEditedChangesBody> for PullRequestEditedChangesBody {
	fn from(value: &PullRequestEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestEditedChangesTitle {
	/// The previous version of the title if the action was `edited`.
	pub from: String,
}
impl From<&PullRequestEditedChangesTitle> for PullRequestEditedChangesTitle {
	fn from(value: &PullRequestEditedChangesTitle) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestEvent {
	Assigned(PullRequestAssigned),
	AutoMergeDisabled(PullRequestAutoMergeDisabled),
	AutoMergeEnabled(PullRequestAutoMergeEnabled),
	Closed(PullRequestClosed),
	ConvertedToDraft(PullRequestConvertedToDraft),
	Demilestoned(PullRequestDemilestoned),
	Dequeued(PullRequestDequeued),
	Edited(PullRequestEdited),
	Labeled(PullRequestLabeled),
	Locked(PullRequestLocked),
	Milestoned(PullRequestMilestoned),
	Opened(PullRequestOpened),
	Queued(PullRequestQueued),
	ReadyForReview(PullRequestReadyForReview),
	Reopened(PullRequestReopened),
	ReviewRequestRemoved(PullRequestReviewRequestRemoved),
	ReviewRequested(PullRequestReviewRequested),
	Synchronize(PullRequestSynchronize),
	Unassigned(PullRequestUnassigned),
	Unlabeled(PullRequestUnlabeled),
	Unlocked(PullRequestUnlocked),
}
impl From<&PullRequestEvent> for PullRequestEvent {
	fn from(value: &PullRequestEvent) -> Self {
		value.clone()
	}
}
impl From<PullRequestAssigned> for PullRequestEvent {
	fn from(value: PullRequestAssigned) -> Self {
		Self::Assigned(value)
	}
}
impl From<PullRequestAutoMergeDisabled> for PullRequestEvent {
	fn from(value: PullRequestAutoMergeDisabled) -> Self {
		Self::AutoMergeDisabled(value)
	}
}
impl From<PullRequestAutoMergeEnabled> for PullRequestEvent {
	fn from(value: PullRequestAutoMergeEnabled) -> Self {
		Self::AutoMergeEnabled(value)
	}
}
impl From<PullRequestClosed> for PullRequestEvent {
	fn from(value: PullRequestClosed) -> Self {
		Self::Closed(value)
	}
}
impl From<PullRequestConvertedToDraft> for PullRequestEvent {
	fn from(value: PullRequestConvertedToDraft) -> Self {
		Self::ConvertedToDraft(value)
	}
}
impl From<PullRequestDemilestoned> for PullRequestEvent {
	fn from(value: PullRequestDemilestoned) -> Self {
		Self::Demilestoned(value)
	}
}
impl From<PullRequestDequeued> for PullRequestEvent {
	fn from(value: PullRequestDequeued) -> Self {
		Self::Dequeued(value)
	}
}
impl From<PullRequestEdited> for PullRequestEvent {
	fn from(value: PullRequestEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<PullRequestLabeled> for PullRequestEvent {
	fn from(value: PullRequestLabeled) -> Self {
		Self::Labeled(value)
	}
}
impl From<PullRequestLocked> for PullRequestEvent {
	fn from(value: PullRequestLocked) -> Self {
		Self::Locked(value)
	}
}
impl From<PullRequestMilestoned> for PullRequestEvent {
	fn from(value: PullRequestMilestoned) -> Self {
		Self::Milestoned(value)
	}
}
impl From<PullRequestOpened> for PullRequestEvent {
	fn from(value: PullRequestOpened) -> Self {
		Self::Opened(value)
	}
}
impl From<PullRequestQueued> for PullRequestEvent {
	fn from(value: PullRequestQueued) -> Self {
		Self::Queued(value)
	}
}
impl From<PullRequestReadyForReview> for PullRequestEvent {
	fn from(value: PullRequestReadyForReview) -> Self {
		Self::ReadyForReview(value)
	}
}
impl From<PullRequestReopened> for PullRequestEvent {
	fn from(value: PullRequestReopened) -> Self {
		Self::Reopened(value)
	}
}
impl From<PullRequestReviewRequestRemoved> for PullRequestEvent {
	fn from(value: PullRequestReviewRequestRemoved) -> Self {
		Self::ReviewRequestRemoved(value)
	}
}
impl From<PullRequestReviewRequested> for PullRequestEvent {
	fn from(value: PullRequestReviewRequested) -> Self {
		Self::ReviewRequested(value)
	}
}
impl From<PullRequestSynchronize> for PullRequestEvent {
	fn from(value: PullRequestSynchronize) -> Self {
		Self::Synchronize(value)
	}
}
impl From<PullRequestUnassigned> for PullRequestEvent {
	fn from(value: PullRequestUnassigned) -> Self {
		Self::Unassigned(value)
	}
}
impl From<PullRequestUnlabeled> for PullRequestEvent {
	fn from(value: PullRequestUnlabeled) -> Self {
		Self::Unlabeled(value)
	}
}
impl From<PullRequestUnlocked> for PullRequestEvent {
	fn from(value: PullRequestUnlocked) -> Self {
		Self::Unlocked(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestHead {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Option<Repository>,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestHead> for PullRequestHead {
	fn from(value: &PullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLabeled {
	pub action:       PullRequestLabeledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub label:        Label,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestLabeled> for PullRequestLabeled {
	fn from(value: &PullRequestLabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLabeledAction {
	#[serde(rename = "labeled")]
	Labeled,
}
impl From<&PullRequestLabeledAction> for PullRequestLabeledAction {
	fn from(value: &PullRequestLabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestLabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Labeled => "labeled".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestLabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"labeled" => Ok(Self::Labeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestLabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestLabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestLabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLinks {
	pub comments:        Link,
	pub commits:         Link,
	pub html:            Link,
	pub issue:           Link,
	pub review_comment:  Link,
	pub review_comments: Link,
	#[serde(rename = "self")]
	pub self_:           Link,
	pub statuses:        Link,
}
impl From<&PullRequestLinks> for PullRequestLinks {
	fn from(value: &PullRequestLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestLocked {
	pub action:       PullRequestLockedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestLocked> for PullRequestLocked {
	fn from(value: &PullRequestLocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestLockedAction {
	#[serde(rename = "locked")]
	Locked,
}
impl From<&PullRequestLockedAction> for PullRequestLockedAction {
	fn from(value: &PullRequestLockedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestLockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Locked => "locked".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestLockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"locked" => Ok(Self::Locked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestLockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestLockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestLockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestMilestoned {
	pub action:       PullRequestMilestonedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub milestone:    Milestone,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestMilestoned> for PullRequestMilestoned {
	fn from(value: &PullRequestMilestoned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestMilestonedAction {
	#[serde(rename = "milestoned")]
	Milestoned,
}
impl From<&PullRequestMilestonedAction> for PullRequestMilestonedAction {
	fn from(value: &PullRequestMilestonedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestMilestonedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Milestoned => "milestoned".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestMilestonedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"milestoned" => Ok(Self::Milestoned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestMilestonedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestMilestonedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestMilestonedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestOpened {
	pub action:       PullRequestOpenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestOpened> for PullRequestOpened {
	fn from(value: &PullRequestOpened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestOpenedAction {
	#[serde(rename = "opened")]
	Opened,
}
impl From<&PullRequestOpenedAction> for PullRequestOpenedAction {
	fn from(value: &PullRequestOpenedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestOpenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Opened => "opened".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestOpenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"opened" => Ok(Self::Opened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestOpenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestOpenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestOpenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestQueued {
	pub action:       PullRequestQueuedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestQueued> for PullRequestQueued {
	fn from(value: &PullRequestQueued) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestQueuedAction {
	#[serde(rename = "queued")]
	Queued,
}
impl From<&PullRequestQueuedAction> for PullRequestQueuedAction {
	fn from(value: &PullRequestQueuedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestQueuedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestQueuedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestQueuedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestQueuedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestQueuedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReadyForReview {
	pub action:       PullRequestReadyForReviewAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestReadyForReview> for PullRequestReadyForReview {
	fn from(value: &PullRequestReadyForReview) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReadyForReviewAction {
	#[serde(rename = "ready_for_review")]
	ReadyForReview,
}
impl From<&PullRequestReadyForReviewAction> for PullRequestReadyForReviewAction {
	fn from(value: &PullRequestReadyForReviewAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReadyForReviewAction {
	fn to_string(&self) -> String {
		match *self {
			Self::ReadyForReview => "ready_for_review".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReadyForReviewAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"ready_for_review" => Ok(Self::ReadyForReview),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReadyForReviewAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReadyForReviewAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReadyForReviewAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReopened {
	pub action:       PullRequestReopenedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestReopened> for PullRequestReopened {
	fn from(value: &PullRequestReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&PullRequestReopenedAction> for PullRequestReopenedAction {
	fn from(value: &PullRequestReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestRequestedReviewersItem {
	User(User),
	Team(Team),
}
impl From<&PullRequestRequestedReviewersItem> for PullRequestRequestedReviewersItem {
	fn from(value: &PullRequestRequestedReviewersItem) -> Self {
		value.clone()
	}
}
impl From<User> for PullRequestRequestedReviewersItem {
	fn from(value: User) -> Self {
		Self::User(value)
	}
}
impl From<Team> for PullRequestRequestedReviewersItem {
	fn from(value: Team) -> Self {
		Self::Team(value)
	}
}
/// The review that was affected.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReview {
	pub author_association: AuthorAssociation,
	/// The text of the review.
	pub body:               Option<String>,
	/// A commit SHA for the review.
	pub commit_id:          String,
	pub html_url:           String,
	/// Unique identifier of the review
	pub id:                 i64,
	#[serde(rename = "_links")]
	pub links:              PullRequestReviewLinks,
	pub node_id:            String,
	pub pull_request_url:   String,
	pub state:              PullRequestReviewState,
	pub submitted_at:       Option<chrono::DateTime<chrono::offset::Utc>>,
	pub user:               User,
}
impl From<&PullRequestReview> for PullRequestReview {
	fn from(value: &PullRequestReview) -> Self {
		value.clone()
	}
}
/// The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewComment {
	pub author_association:     AuthorAssociation,
	/// The text of the comment.
	pub body:                   String,
	/// The SHA of the commit to which the comment applies.
	pub commit_id:              String,
	pub created_at:             chrono::DateTime<chrono::offset::Utc>,
	/// The diff of the line that the comment refers to.
	pub diff_hunk:              String,
	/// HTML URL for the pull request review comment.
	pub html_url:               String,
	/// The ID of the pull request review comment.
	pub id:                     i64,
	/// The comment ID to reply to.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub in_reply_to_id:         Option<i64>,
	/// The line of the blob to which the comment applies. The last line of the
	/// range for a multi-line comment
	pub line:                   Option<i64>,
	#[serde(rename = "_links")]
	pub links:                  PullRequestReviewCommentLinks,
	/// The node ID of the pull request review comment.
	pub node_id:                String,
	/// The SHA of the original commit to which the comment applies.
	pub original_commit_id:     String,
	/// The line of the blob to which the comment applies. The last line of the
	/// range for a multi-line comment
	pub original_line:          i64,
	/// The index of the original line in the diff to which the comment applies.
	pub original_position:      i64,
	/// The first line of the range for a multi-line comment.
	pub original_start_line:    Option<i64>,
	/// The relative path of the file to which the comment applies.
	pub path:                   String,
	/// The line index in the diff to which the comment applies.
	pub position:               Option<i64>,
	/// The ID of the pull request review to which the comment belongs.
	pub pull_request_review_id: i64,
	/// URL for the pull request that the review comment belongs to.
	pub pull_request_url:       String,
	pub reactions:              Reactions,
	/// The side of the first line of the range for a multi-line comment.
	pub side:                   PullRequestReviewCommentSide,
	/// The first line of the range for a multi-line comment.
	pub start_line:             Option<i64>,
	/// The side of the first line of the range for a multi-line comment.
	pub start_side:             Option<PullRequestReviewCommentStartSide>,
	/// The level at which the comment is targeted, can be a diff line or a
	/// file.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub subject_type:           Option<PullRequestReviewCommentSubjectType>,
	pub updated_at:             chrono::DateTime<chrono::offset::Utc>,
	/// URL for the pull request review comment
	pub url:                    String,
	pub user:                   User,
}
impl From<&PullRequestReviewComment> for PullRequestReviewComment {
	fn from(value: &PullRequestReviewComment) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreated {
	pub action:       PullRequestReviewCommentCreatedAction,
	pub comment:      PullRequestReviewComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequestReviewCommentCreatedPullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestReviewCommentCreated> for PullRequestReviewCommentCreated {
	fn from(value: &PullRequestReviewCommentCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&PullRequestReviewCommentCreatedAction> for PullRequestReviewCommentCreatedAction {
	fn from(value: &PullRequestReviewCommentCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequest {
	pub active_lock_reason:  Option<PullRequestReviewCommentCreatedPullRequestActiveLockReason>,
	pub assignee:            Option<User>,
	pub assignees:           Vec<User>,
	pub author_association:  AuthorAssociation,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub auto_merge:          Option<AutoMerge>,
	pub base:                PullRequestReviewCommentCreatedPullRequestBase,
	pub body:                Option<String>,
	pub closed_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments_url:        String,
	pub commits_url:         String,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub diff_url:            String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:               Option<bool>,
	pub head:                PullRequestReviewCommentCreatedPullRequestHead,
	pub html_url:            String,
	pub id:                  i64,
	pub issue_url:           String,
	pub labels:              Vec<Label>,
	#[serde(rename = "_links")]
	pub links:               PullRequestReviewCommentCreatedPullRequestLinks,
	pub locked:              bool,
	pub merge_commit_sha:    Option<String>,
	pub merged_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub milestone:           Option<Milestone>,
	pub node_id:             String,
	pub number:              i64,
	pub patch_url:           String,
	pub requested_reviewers: Vec<PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>,
	pub requested_teams:     Vec<Team>,
	pub review_comment_url:  String,
	pub review_comments_url: String,
	pub state:               PullRequestReviewCommentCreatedPullRequestState,
	pub statuses_url:        String,
	pub title:               String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub url:                 String,
	pub user:                User,
}
impl From<&PullRequestReviewCommentCreatedPullRequest>
	for PullRequestReviewCommentCreatedPullRequest
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&PullRequestReviewCommentCreatedPullRequestActiveLockReason>
	for PullRequestReviewCommentCreatedPullRequestActiveLockReason
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestBase {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestBase>
	for PullRequestReviewCommentCreatedPullRequestBase
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestHead {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentCreatedPullRequestHead>
	for PullRequestReviewCommentCreatedPullRequestHead
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentCreatedPullRequestLinks {
	pub comments:        Link,
	pub commits:         Link,
	pub html:            Link,
	pub issue:           Link,
	pub review_comment:  Link,
	pub review_comments: Link,
	#[serde(rename = "self")]
	pub self_:           Link,
	pub statuses:        Link,
}
impl From<&PullRequestReviewCommentCreatedPullRequestLinks>
	for PullRequestReviewCommentCreatedPullRequestLinks
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
	User(User),
	Team(Team),
}
impl From<&PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem>
	for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem) -> Self {
		value.clone()
	}
}
impl From<User> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
	fn from(value: User) -> Self {
		Self::User(value)
	}
}
impl From<Team> for PullRequestReviewCommentCreatedPullRequestRequestedReviewersItem {
	fn from(value: Team) -> Self {
		Self::Team(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentCreatedPullRequestState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&PullRequestReviewCommentCreatedPullRequestState>
	for PullRequestReviewCommentCreatedPullRequestState
{
	fn from(value: &PullRequestReviewCommentCreatedPullRequestState) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentCreatedPullRequestState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentCreatedPullRequestState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentCreatedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentCreatedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentCreatedPullRequestState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeleted {
	pub action:       PullRequestReviewCommentDeletedAction,
	pub comment:      PullRequestReviewComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequestReviewCommentDeletedPullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestReviewCommentDeleted> for PullRequestReviewCommentDeleted {
	fn from(value: &PullRequestReviewCommentDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&PullRequestReviewCommentDeletedAction> for PullRequestReviewCommentDeletedAction {
	fn from(value: &PullRequestReviewCommentDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequest {
	pub active_lock_reason:  Option<PullRequestReviewCommentDeletedPullRequestActiveLockReason>,
	pub assignee:            Option<User>,
	pub assignees:           Vec<User>,
	pub author_association:  AuthorAssociation,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub auto_merge:          Option<AutoMerge>,
	pub base:                PullRequestReviewCommentDeletedPullRequestBase,
	pub body:                Option<String>,
	pub closed_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments_url:        String,
	pub commits_url:         String,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub diff_url:            String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:               Option<bool>,
	pub head:                PullRequestReviewCommentDeletedPullRequestHead,
	pub html_url:            String,
	pub id:                  i64,
	pub issue_url:           String,
	pub labels:              Vec<Label>,
	#[serde(rename = "_links")]
	pub links:               PullRequestReviewCommentDeletedPullRequestLinks,
	pub locked:              bool,
	pub merge_commit_sha:    Option<String>,
	pub merged_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub milestone:           Option<Milestone>,
	pub node_id:             String,
	pub number:              i64,
	pub patch_url:           String,
	pub requested_reviewers: Vec<PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>,
	pub requested_teams:     Vec<Team>,
	pub review_comment_url:  String,
	pub review_comments_url: String,
	pub state:               PullRequestReviewCommentDeletedPullRequestState,
	pub statuses_url:        String,
	pub title:               String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub url:                 String,
	pub user:                User,
}
impl From<&PullRequestReviewCommentDeletedPullRequest>
	for PullRequestReviewCommentDeletedPullRequest
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&PullRequestReviewCommentDeletedPullRequestActiveLockReason>
	for PullRequestReviewCommentDeletedPullRequestActiveLockReason
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestBase {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestBase>
	for PullRequestReviewCommentDeletedPullRequestBase
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestHead {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentDeletedPullRequestHead>
	for PullRequestReviewCommentDeletedPullRequestHead
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentDeletedPullRequestLinks {
	pub comments:        Link,
	pub commits:         Link,
	pub html:            Link,
	pub issue:           Link,
	pub review_comment:  Link,
	pub review_comments: Link,
	#[serde(rename = "self")]
	pub self_:           Link,
	pub statuses:        Link,
}
impl From<&PullRequestReviewCommentDeletedPullRequestLinks>
	for PullRequestReviewCommentDeletedPullRequestLinks
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
	User(User),
	Team(Team),
}
impl From<&PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem>
	for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem) -> Self {
		value.clone()
	}
}
impl From<User> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
	fn from(value: User) -> Self {
		Self::User(value)
	}
}
impl From<Team> for PullRequestReviewCommentDeletedPullRequestRequestedReviewersItem {
	fn from(value: Team) -> Self {
		Self::Team(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentDeletedPullRequestState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&PullRequestReviewCommentDeletedPullRequestState>
	for PullRequestReviewCommentDeletedPullRequestState
{
	fn from(value: &PullRequestReviewCommentDeletedPullRequestState) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentDeletedPullRequestState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentDeletedPullRequestState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentDeletedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentDeletedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentDeletedPullRequestState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEdited {
	pub action:       PullRequestReviewCommentEditedAction,
	pub changes:      PullRequestReviewCommentEditedChanges,
	pub comment:      PullRequestReviewComment,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequestReviewCommentEditedPullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestReviewCommentEdited> for PullRequestReviewCommentEdited {
	fn from(value: &PullRequestReviewCommentEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&PullRequestReviewCommentEditedAction> for PullRequestReviewCommentEditedAction {
	fn from(value: &PullRequestReviewCommentEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the comment.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body: Option<PullRequestReviewCommentEditedChangesBody>,
}
impl From<&PullRequestReviewCommentEditedChanges> for PullRequestReviewCommentEditedChanges {
	fn from(value: &PullRequestReviewCommentEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedChangesBody {
	/// The previous version of the body.
	pub from: String,
}
impl From<&PullRequestReviewCommentEditedChangesBody>
	for PullRequestReviewCommentEditedChangesBody
{
	fn from(value: &PullRequestReviewCommentEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequest {
	pub active_lock_reason:  Option<PullRequestReviewCommentEditedPullRequestActiveLockReason>,
	pub assignee:            Option<User>,
	pub assignees:           Vec<User>,
	pub author_association:  AuthorAssociation,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub auto_merge:          Option<AutoMerge>,
	pub base:                PullRequestReviewCommentEditedPullRequestBase,
	pub body:                Option<String>,
	pub closed_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments_url:        String,
	pub commits_url:         String,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub diff_url:            String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:               Option<bool>,
	pub head:                PullRequestReviewCommentEditedPullRequestHead,
	pub html_url:            String,
	pub id:                  i64,
	pub issue_url:           String,
	pub labels:              Vec<Label>,
	#[serde(rename = "_links")]
	pub links:               PullRequestReviewCommentEditedPullRequestLinks,
	pub locked:              bool,
	pub merge_commit_sha:    Option<String>,
	pub merged_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub milestone:           Option<Milestone>,
	pub node_id:             String,
	pub number:              i64,
	pub patch_url:           String,
	pub requested_reviewers: Vec<PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>,
	pub requested_teams:     Vec<Team>,
	pub review_comment_url:  String,
	pub review_comments_url: String,
	pub state:               PullRequestReviewCommentEditedPullRequestState,
	pub statuses_url:        String,
	pub title:               String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub url:                 String,
	pub user:                User,
}
impl From<&PullRequestReviewCommentEditedPullRequest>
	for PullRequestReviewCommentEditedPullRequest
{
	fn from(value: &PullRequestReviewCommentEditedPullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&PullRequestReviewCommentEditedPullRequestActiveLockReason>
	for PullRequestReviewCommentEditedPullRequestActiveLockReason
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentEditedPullRequestActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestBase {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentEditedPullRequestBase>
	for PullRequestReviewCommentEditedPullRequestBase
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestHead {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&PullRequestReviewCommentEditedPullRequestHead>
	for PullRequestReviewCommentEditedPullRequestHead
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentEditedPullRequestLinks {
	pub comments:        Link,
	pub commits:         Link,
	pub html:            Link,
	pub issue:           Link,
	pub review_comment:  Link,
	pub review_comments: Link,
	#[serde(rename = "self")]
	pub self_:           Link,
	pub statuses:        Link,
}
impl From<&PullRequestReviewCommentEditedPullRequestLinks>
	for PullRequestReviewCommentEditedPullRequestLinks
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
	User(User),
	Team(Team),
}
impl From<&PullRequestReviewCommentEditedPullRequestRequestedReviewersItem>
	for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestRequestedReviewersItem) -> Self {
		value.clone()
	}
}
impl From<User> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
	fn from(value: User) -> Self {
		Self::User(value)
	}
}
impl From<Team> for PullRequestReviewCommentEditedPullRequestRequestedReviewersItem {
	fn from(value: Team) -> Self {
		Self::Team(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentEditedPullRequestState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&PullRequestReviewCommentEditedPullRequestState>
	for PullRequestReviewCommentEditedPullRequestState
{
	fn from(value: &PullRequestReviewCommentEditedPullRequestState) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentEditedPullRequestState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentEditedPullRequestState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentEditedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentEditedPullRequestState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentEditedPullRequestState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewCommentEvent {
	Created(PullRequestReviewCommentCreated),
	Deleted(PullRequestReviewCommentDeleted),
	Edited(PullRequestReviewCommentEdited),
}
impl From<&PullRequestReviewCommentEvent> for PullRequestReviewCommentEvent {
	fn from(value: &PullRequestReviewCommentEvent) -> Self {
		value.clone()
	}
}
impl From<PullRequestReviewCommentCreated> for PullRequestReviewCommentEvent {
	fn from(value: PullRequestReviewCommentCreated) -> Self {
		Self::Created(value)
	}
}
impl From<PullRequestReviewCommentDeleted> for PullRequestReviewCommentEvent {
	fn from(value: PullRequestReviewCommentDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<PullRequestReviewCommentEdited> for PullRequestReviewCommentEvent {
	fn from(value: PullRequestReviewCommentEdited) -> Self {
		Self::Edited(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewCommentLinks {
	pub html:         Link,
	pub pull_request: Link,
	#[serde(rename = "self")]
	pub self_:        Link,
}
impl From<&PullRequestReviewCommentLinks> for PullRequestReviewCommentLinks {
	fn from(value: &PullRequestReviewCommentLinks) -> Self {
		value.clone()
	}
}
/// The side of the first line of the range for a multi-line comment.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentSide {
	#[serde(rename = "LEFT")]
	Left,
	#[serde(rename = "RIGHT")]
	Right,
}
impl From<&PullRequestReviewCommentSide> for PullRequestReviewCommentSide {
	fn from(value: &PullRequestReviewCommentSide) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentSide {
	fn to_string(&self) -> String {
		match *self {
			Self::Left => "LEFT".to_string(),
			Self::Right => "RIGHT".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentSide {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"LEFT" => Ok(Self::Left),
			"RIGHT" => Ok(Self::Right),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentSide {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentSide {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentSide {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The side of the first line of the range for a multi-line comment.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentStartSide {
	#[serde(rename = "LEFT")]
	Left,
	#[serde(rename = "RIGHT")]
	Right,
}
impl From<&PullRequestReviewCommentStartSide> for PullRequestReviewCommentStartSide {
	fn from(value: &PullRequestReviewCommentStartSide) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentStartSide {
	fn to_string(&self) -> String {
		match *self {
			Self::Left => "LEFT".to_string(),
			Self::Right => "RIGHT".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentStartSide {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"LEFT" => Ok(Self::Left),
			"RIGHT" => Ok(Self::Right),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentStartSide {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentStartSide {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentStartSide {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The level at which the comment is targeted, can be a diff line or a file.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewCommentSubjectType {
	#[serde(rename = "line")]
	Line,
	#[serde(rename = "file")]
	File,
}
impl From<&PullRequestReviewCommentSubjectType> for PullRequestReviewCommentSubjectType {
	fn from(value: &PullRequestReviewCommentSubjectType) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewCommentSubjectType {
	fn to_string(&self) -> String {
		match *self {
			Self::Line => "line".to_string(),
			Self::File => "file".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewCommentSubjectType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"line" => Ok(Self::Line),
			"file" => Ok(Self::File),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewCommentSubjectType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewCommentSubjectType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewCommentSubjectType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewDismissed {
	pub action:       PullRequestReviewDismissedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: SimplePullRequest,
	pub repository:   Repository,
	pub review:       PullRequestReview,
	pub sender:       User,
}
impl From<&PullRequestReviewDismissed> for PullRequestReviewDismissed {
	fn from(value: &PullRequestReviewDismissed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewDismissedAction {
	#[serde(rename = "dismissed")]
	Dismissed,
}
impl From<&PullRequestReviewDismissedAction> for PullRequestReviewDismissedAction {
	fn from(value: &PullRequestReviewDismissedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewDismissedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Dismissed => "dismissed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewDismissedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dismissed" => Ok(Self::Dismissed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewDismissedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewDismissedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewDismissedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEdited {
	pub action:       PullRequestReviewEditedAction,
	pub changes:      PullRequestReviewEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: SimplePullRequest,
	pub repository:   Repository,
	pub review:       PullRequestReview,
	pub sender:       User,
}
impl From<&PullRequestReviewEdited> for PullRequestReviewEdited {
	fn from(value: &PullRequestReviewEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&PullRequestReviewEditedAction> for PullRequestReviewEditedAction {
	fn from(value: &PullRequestReviewEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body: Option<PullRequestReviewEditedChangesBody>,
}
impl From<&PullRequestReviewEditedChanges> for PullRequestReviewEditedChanges {
	fn from(value: &PullRequestReviewEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewEditedChangesBody {
	/// The previous version of the body if the action was `edited`.
	pub from: String,
}
impl From<&PullRequestReviewEditedChangesBody> for PullRequestReviewEditedChangesBody {
	fn from(value: &PullRequestReviewEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewEvent {
	Dismissed(PullRequestReviewDismissed),
	Edited(PullRequestReviewEdited),
	Submitted(PullRequestReviewSubmitted),
}
impl From<&PullRequestReviewEvent> for PullRequestReviewEvent {
	fn from(value: &PullRequestReviewEvent) -> Self {
		value.clone()
	}
}
impl From<PullRequestReviewDismissed> for PullRequestReviewEvent {
	fn from(value: PullRequestReviewDismissed) -> Self {
		Self::Dismissed(value)
	}
}
impl From<PullRequestReviewEdited> for PullRequestReviewEvent {
	fn from(value: PullRequestReviewEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<PullRequestReviewSubmitted> for PullRequestReviewEvent {
	fn from(value: PullRequestReviewSubmitted) -> Self {
		Self::Submitted(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewLinks {
	pub html:         Link,
	pub pull_request: Link,
}
impl From<&PullRequestReviewLinks> for PullRequestReviewLinks {
	fn from(value: &PullRequestReviewLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequestRemoved {
	Variant0 {
		action:             PullRequestReviewRequestRemovedVariant0Action,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		installation:       Option<InstallationLite>,
		/// The pull request number.
		number:             i64,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		organization:       Option<Organization>,
		pull_request:       PullRequest,
		repository:         Repository,
		requested_reviewer: User,
		sender:             User,
	},
	Variant1 {
		action:         PullRequestReviewRequestRemovedVariant1Action,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		installation:   Option<InstallationLite>,
		/// The pull request number.
		number:         i64,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		organization:   Option<Organization>,
		pull_request:   PullRequest,
		repository:     Repository,
		requested_team: Team,
		sender:         User,
	},
}
impl From<&PullRequestReviewRequestRemoved> for PullRequestReviewRequestRemoved {
	fn from(value: &PullRequestReviewRequestRemoved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant0Action {
	#[serde(rename = "review_request_removed")]
	ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant0Action>
	for PullRequestReviewRequestRemovedVariant0Action
{
	fn from(value: &PullRequestReviewRequestRemovedVariant0Action) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewRequestRemovedVariant0Action {
	fn to_string(&self) -> String {
		match *self {
			Self::ReviewRequestRemoved => "review_request_removed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant0Action {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"review_request_removed" => Ok(Self::ReviewRequestRemoved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant0Action {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant0Action {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant0Action {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestRemovedVariant1Action {
	#[serde(rename = "review_request_removed")]
	ReviewRequestRemoved,
}
impl From<&PullRequestReviewRequestRemovedVariant1Action>
	for PullRequestReviewRequestRemovedVariant1Action
{
	fn from(value: &PullRequestReviewRequestRemovedVariant1Action) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewRequestRemovedVariant1Action {
	fn to_string(&self) -> String {
		match *self {
			Self::ReviewRequestRemoved => "review_request_removed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewRequestRemovedVariant1Action {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"review_request_removed" => Ok(Self::ReviewRequestRemoved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestRemovedVariant1Action {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestRemovedVariant1Action {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestRemovedVariant1Action {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum PullRequestReviewRequested {
	Variant0 {
		action:             PullRequestReviewRequestedVariant0Action,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		installation:       Option<InstallationLite>,
		/// The pull request number.
		number:             i64,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		organization:       Option<Organization>,
		pull_request:       PullRequest,
		repository:         Repository,
		requested_reviewer: User,
		sender:             User,
	},
	Variant1 {
		action:         PullRequestReviewRequestedVariant1Action,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		installation:   Option<InstallationLite>,
		/// The pull request number.
		number:         i64,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		organization:   Option<Organization>,
		pull_request:   PullRequest,
		repository:     Repository,
		requested_team: Team,
		sender:         User,
	},
}
impl From<&PullRequestReviewRequested> for PullRequestReviewRequested {
	fn from(value: &PullRequestReviewRequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant0Action {
	#[serde(rename = "review_requested")]
	ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant0Action> for PullRequestReviewRequestedVariant0Action {
	fn from(value: &PullRequestReviewRequestedVariant0Action) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewRequestedVariant0Action {
	fn to_string(&self) -> String {
		match *self {
			Self::ReviewRequested => "review_requested".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewRequestedVariant0Action {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"review_requested" => Ok(Self::ReviewRequested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant0Action {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant0Action {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant0Action {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewRequestedVariant1Action {
	#[serde(rename = "review_requested")]
	ReviewRequested,
}
impl From<&PullRequestReviewRequestedVariant1Action> for PullRequestReviewRequestedVariant1Action {
	fn from(value: &PullRequestReviewRequestedVariant1Action) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewRequestedVariant1Action {
	fn to_string(&self) -> String {
		match *self {
			Self::ReviewRequested => "review_requested".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewRequestedVariant1Action {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"review_requested" => Ok(Self::ReviewRequested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewRequestedVariant1Action {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewRequestedVariant1Action {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewRequestedVariant1Action {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewState {
	#[serde(rename = "commented")]
	Commented,
	#[serde(rename = "changes_requested")]
	ChangesRequested,
	#[serde(rename = "approved")]
	Approved,
	#[serde(rename = "dismissed")]
	Dismissed,
}
impl From<&PullRequestReviewState> for PullRequestReviewState {
	fn from(value: &PullRequestReviewState) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewState {
	fn to_string(&self) -> String {
		match *self {
			Self::Commented => "commented".to_string(),
			Self::ChangesRequested => "changes_requested".to_string(),
			Self::Approved => "approved".to_string(),
			Self::Dismissed => "dismissed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"commented" => Ok(Self::Commented),
			"changes_requested" => Ok(Self::ChangesRequested),
			"approved" => Ok(Self::Approved),
			"dismissed" => Ok(Self::Dismissed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewSubmitted {
	pub action:       PullRequestReviewSubmittedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: SimplePullRequest,
	pub repository:   Repository,
	pub review:       PullRequestReview,
	pub sender:       User,
}
impl From<&PullRequestReviewSubmitted> for PullRequestReviewSubmitted {
	fn from(value: &PullRequestReviewSubmitted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewSubmittedAction {
	#[serde(rename = "submitted")]
	Submitted,
}
impl From<&PullRequestReviewSubmittedAction> for PullRequestReviewSubmittedAction {
	fn from(value: &PullRequestReviewSubmittedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewSubmittedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Submitted => "submitted".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewSubmittedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"submitted" => Ok(Self::Submitted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewSubmittedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewSubmittedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewSubmittedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PullRequestReviewThreadEvent {
	Resolved(PullRequestReviewThreadResolved),
	Unresolved(PullRequestReviewThreadUnresolved),
}
impl From<&PullRequestReviewThreadEvent> for PullRequestReviewThreadEvent {
	fn from(value: &PullRequestReviewThreadEvent) -> Self {
		value.clone()
	}
}
impl From<PullRequestReviewThreadResolved> for PullRequestReviewThreadEvent {
	fn from(value: PullRequestReviewThreadResolved) -> Self {
		Self::Resolved(value)
	}
}
impl From<PullRequestReviewThreadUnresolved> for PullRequestReviewThreadEvent {
	fn from(value: PullRequestReviewThreadUnresolved) -> Self {
		Self::Unresolved(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewThreadResolved {
	pub action:       PullRequestReviewThreadResolvedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: SimplePullRequest,
	pub repository:   Repository,
	pub sender:       User,
	pub thread:       PullRequestReviewThreadResolvedThread,
}
impl From<&PullRequestReviewThreadResolved> for PullRequestReviewThreadResolved {
	fn from(value: &PullRequestReviewThreadResolved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewThreadResolvedAction {
	#[serde(rename = "resolved")]
	Resolved,
}
impl From<&PullRequestReviewThreadResolvedAction> for PullRequestReviewThreadResolvedAction {
	fn from(value: &PullRequestReviewThreadResolvedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewThreadResolvedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewThreadResolvedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewThreadResolvedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewThreadResolvedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewThreadResolvedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewThreadResolvedThread {
	pub comments: Vec<PullRequestReviewComment>,
	pub node_id:  String,
}
impl From<&PullRequestReviewThreadResolvedThread> for PullRequestReviewThreadResolvedThread {
	fn from(value: &PullRequestReviewThreadResolvedThread) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewThreadUnresolved {
	pub action:       PullRequestReviewThreadUnresolvedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: SimplePullRequest,
	pub repository:   Repository,
	pub sender:       User,
	pub thread:       PullRequestReviewThreadUnresolvedThread,
}
impl From<&PullRequestReviewThreadUnresolved> for PullRequestReviewThreadUnresolved {
	fn from(value: &PullRequestReviewThreadUnresolved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestReviewThreadUnresolvedAction {
	#[serde(rename = "unresolved")]
	Unresolved,
}
impl From<&PullRequestReviewThreadUnresolvedAction> for PullRequestReviewThreadUnresolvedAction {
	fn from(value: &PullRequestReviewThreadUnresolvedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestReviewThreadUnresolvedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unresolved => "unresolved".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestReviewThreadUnresolvedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unresolved" => Ok(Self::Unresolved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestReviewThreadUnresolvedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestReviewThreadUnresolvedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestReviewThreadUnresolvedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestReviewThreadUnresolvedThread {
	pub comments: Vec<PullRequestReviewComment>,
	pub node_id:  String,
}
impl From<&PullRequestReviewThreadUnresolvedThread> for PullRequestReviewThreadUnresolvedThread {
	fn from(value: &PullRequestReviewThreadUnresolvedThread) -> Self {
		value.clone()
	}
}
/// State of this Pull Request. Either `open` or `closed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&PullRequestState> for PullRequestState {
	fn from(value: &PullRequestState) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestSynchronize {
	pub action:       PullRequestSynchronizeAction,
	pub after:        String,
	pub before:       String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestSynchronize> for PullRequestSynchronize {
	fn from(value: &PullRequestSynchronize) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestSynchronizeAction {
	#[serde(rename = "synchronize")]
	Synchronize,
}
impl From<&PullRequestSynchronizeAction> for PullRequestSynchronizeAction {
	fn from(value: &PullRequestSynchronizeAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestSynchronizeAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Synchronize => "synchronize".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestSynchronizeAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"synchronize" => Ok(Self::Synchronize),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestSynchronizeAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestSynchronizeAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestSynchronizeAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnassigned {
	pub action:       PullRequestUnassignedAction,
	pub assignee:     User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestUnassigned> for PullRequestUnassigned {
	fn from(value: &PullRequestUnassigned) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnassignedAction {
	#[serde(rename = "unassigned")]
	Unassigned,
}
impl From<&PullRequestUnassignedAction> for PullRequestUnassignedAction {
	fn from(value: &PullRequestUnassignedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestUnassignedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unassigned => "unassigned".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestUnassignedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unassigned" => Ok(Self::Unassigned),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestUnassignedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestUnassignedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestUnassignedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlabeled {
	pub action:       PullRequestUnlabeledAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub label:        Label,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestUnlabeled> for PullRequestUnlabeled {
	fn from(value: &PullRequestUnlabeled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlabeledAction {
	#[serde(rename = "unlabeled")]
	Unlabeled,
}
impl From<&PullRequestUnlabeledAction> for PullRequestUnlabeledAction {
	fn from(value: &PullRequestUnlabeledAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestUnlabeledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlabeled => "unlabeled".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestUnlabeledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlabeled" => Ok(Self::Unlabeled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestUnlabeledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PullRequestUnlocked {
	pub action:       PullRequestUnlockedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	/// The pull request number.
	pub number:       i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pull_request: PullRequest,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PullRequestUnlocked> for PullRequestUnlocked {
	fn from(value: &PullRequestUnlocked) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PullRequestUnlockedAction {
	#[serde(rename = "unlocked")]
	Unlocked,
}
impl From<&PullRequestUnlockedAction> for PullRequestUnlockedAction {
	fn from(value: &PullRequestUnlockedAction) -> Self {
		value.clone()
	}
}
impl ToString for PullRequestUnlockedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unlocked => "unlocked".to_string(),
		}
	}
}
impl std::str::FromStr for PullRequestUnlockedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unlocked" => Ok(Self::Unlocked),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for PullRequestUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for PullRequestUnlockedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for PullRequestUnlockedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PushEvent {
	/// The SHA of the most recent commit on `ref` after the push.
	pub after:        String,
	pub base_ref:     Option<String>,
	/// The SHA of the most recent commit on `ref` before the push.
	pub before:       String,
	/// An array of commit objects describing the pushed commits. (Pushed commits are all commits that are included in the `compare` between the `before` commit and the `after` commit.) The array includes a maximum of 20 commits. If necessary, you can use the [Commits API](https://docs.github.com/en/rest/reference/repos#commits) to fetch additional commits. This limit is applied to timeline events only and isn't applied to webhook deliveries.
	pub commits:      Vec<Commit>,
	/// URL that shows the changes in this `ref` update, from the `before`
	/// commit to the `after` commit. For a newly created `ref` that is directly
	/// based on the default branch, this is the comparison between the head of
	/// the default branch and the `after` commit. Otherwise, this shows all
	/// commits until the `after` commit.
	pub compare:      String,
	/// Whether this push created the `ref`.
	pub created:      bool,
	/// Whether this push deleted the `ref`.
	pub deleted:      bool,
	/// Whether this push was a force push of the `ref`.
	pub forced:       bool,
	/// For pushes where `after` is or points to a commit object, an expanded
	/// representation of that commit. For pushes where `after` refers to an
	/// annotated tag object, an expanded representation of the commit pointed
	/// to by the annotated tag.
	pub head_commit:  Option<Commit>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub pusher:       Committer,
	/// The full git ref that was pushed. Example: `refs/heads/main` or
	/// `refs/tags/v3.14.1`.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&PushEvent> for PushEvent {
	fn from(value: &PushEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Reactions {
	pub confused:    i64,
	pub eyes:        i64,
	pub heart:       i64,
	pub hooray:      i64,
	pub laugh:       i64,
	#[serde(rename = "-1")]
	pub minus1:      i64,
	#[serde(rename = "+1")]
	pub plus1:       i64,
	pub rocket:      i64,
	pub total_count: i64,
	pub url:         String,
}
impl From<&Reactions> for Reactions {
	fn from(value: &Reactions) -> Self {
		value.clone()
	}
}
/// A workflow referenced/reused by the initial caller workflow
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReferencedWorkflow {
	pub path: String,
	#[serde(rename = "ref", default, skip_serializing_if = "Option::is_none")]
	pub ref_: Option<String>,
	pub sha:  String,
}
impl From<&ReferencedWorkflow> for ReferencedWorkflow {
	fn from(value: &ReferencedWorkflow) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegistryPackageEvent {
	Published(RegistryPackagePublished),
	Updated(RegistryPackageUpdated),
}
impl From<&RegistryPackageEvent> for RegistryPackageEvent {
	fn from(value: &RegistryPackageEvent) -> Self {
		value.clone()
	}
}
impl From<RegistryPackagePublished> for RegistryPackageEvent {
	fn from(value: RegistryPackagePublished) -> Self {
		Self::Published(value)
	}
}
impl From<RegistryPackageUpdated> for RegistryPackageEvent {
	fn from(value: RegistryPackageUpdated) -> Self {
		Self::Updated(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublished {
	pub action:           RegistryPackagePublishedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub registry_package: RegistryPackagePublishedRegistryPackage,
	pub repository:       Repository,
	pub sender:           User,
}
impl From<&RegistryPackagePublished> for RegistryPackagePublished {
	fn from(value: &RegistryPackagePublished) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegistryPackagePublishedAction {
	#[serde(rename = "published")]
	Published,
}
impl From<&RegistryPackagePublishedAction> for RegistryPackagePublishedAction {
	fn from(value: &RegistryPackagePublishedAction) -> Self {
		value.clone()
	}
}
impl ToString for RegistryPackagePublishedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Published => "published".to_string(),
		}
	}
}
impl std::str::FromStr for RegistryPackagePublishedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"published" => Ok(Self::Published),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RegistryPackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RegistryPackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RegistryPackagePublishedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Information about the package.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackage {
	pub created_at:      chrono::DateTime<chrono::offset::Utc>,
	pub description:     Option<String>,
	pub ecosystem:       String,
	pub html_url:        String,
	/// Unique identifier of the package.
	pub id:              i64,
	/// The name of the package.
	pub name:            String,
	pub namespace:       String,
	pub owner:           User,
	/// The type of supported package. Packages in GitHub's Gradle registry have
	/// the type `maven`. Docker images pushed to GitHub's Container registry
	/// (`ghcr.io`) have the type `container`. You can use the type `docker` to
	/// find images that were pushed to GitHub's Docker registry
	/// (`docker.pkg.github.com`), even if these have now been migrated to the
	/// Container registry.
	pub package_type:    RegistryPackagePublishedRegistryPackagePackageType,
	/// A version of a software package
	pub package_version: Option<RegistryPackagePublishedRegistryPackagePackageVersion>,
	pub registry:        RegistryPackagePublishedRegistryPackageRegistry,
	pub updated_at:      Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&RegistryPackagePublishedRegistryPackage> for RegistryPackagePublishedRegistryPackage {
	fn from(value: &RegistryPackagePublishedRegistryPackage) -> Self {
		value.clone()
	}
}
/// The type of supported package. Packages in GitHub's Gradle registry have the
/// type `maven`. Docker images pushed to GitHub's Container registry
/// (`ghcr.io`) have the type `container`. You can use the type `docker` to find
/// images that were pushed to GitHub's Docker registry
/// (`docker.pkg.github.com`), even if these have now been migrated to the
/// Container registry.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegistryPackagePublishedRegistryPackagePackageType {
	#[serde(rename = "npm")]
	Npm,
	#[serde(rename = "maven")]
	Maven,
	#[serde(rename = "rubygems")]
	Rubygems,
	#[serde(rename = "docker")]
	Docker,
	#[serde(rename = "nuget")]
	Nuget,
	#[serde(rename = "CONTAINER")]
	Container,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageType>
	for RegistryPackagePublishedRegistryPackagePackageType
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageType) -> Self {
		value.clone()
	}
}
impl ToString for RegistryPackagePublishedRegistryPackagePackageType {
	fn to_string(&self) -> String {
		match *self {
			Self::Npm => "npm".to_string(),
			Self::Maven => "maven".to_string(),
			Self::Rubygems => "rubygems".to_string(),
			Self::Docker => "docker".to_string(),
			Self::Nuget => "nuget".to_string(),
			Self::Container => "CONTAINER".to_string(),
		}
	}
}
impl std::str::FromStr for RegistryPackagePublishedRegistryPackagePackageType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"npm" => Ok(Self::Npm),
			"maven" => Ok(Self::Maven),
			"rubygems" => Ok(Self::Rubygems),
			"docker" => Ok(Self::Docker),
			"nuget" => Ok(Self::Nuget),
			"CONTAINER" => Ok(Self::Container),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RegistryPackagePublishedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RegistryPackagePublishedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RegistryPackagePublishedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersion {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub author:               Option<RegistryPackagePublishedRegistryPackagePackageVersionAuthor>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:                 Option<RegistryPackagePublishedRegistryPackagePackageVersionBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body_html:            Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub container_metadata:
		Option<RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub created_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub description:          String,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub docker_metadata:      Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:                Option<bool>,
	pub html_url:             String,
	/// Unique identifier of the package version.
	pub id:                   i64,
	pub installation_command: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:             Option<String>,
	/// Package Version Metadata
	pub metadata:             Vec<serde_json::Value>,
	/// The name of the package version.
	pub name:                 String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_metadata:         Option<PackageNpmMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub nuget_metadata:       Option<Vec<PackageNugetMetadata>>,
	pub package_files: Vec<RegistryPackagePublishedRegistryPackagePackageVersionPackageFilesItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub package_url:          Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub prerelease:           Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub release:              Option<RegistryPackagePublishedRegistryPackagePackageVersionRelease>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub rubygems_metadata:    Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source_url:           Option<String>,
	pub summary:              String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag_name:             Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_commitish:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_oid:           Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub updated_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub version:              String,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersion>
	for RegistryPackagePublishedRegistryPackagePackageVersion
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersion) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionAuthor {
	pub avatar_url:          String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub node_id:             String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionAuthor>
	for RegistryPackagePublishedRegistryPackagePackageVersionAuthor
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersionAuthor) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum RegistryPackagePublishedRegistryPackagePackageVersionBody {
	Variant0(String),
	Variant1 {
		#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
		attributes: std::collections::HashMap<String, serde_json::Value>,
		#[serde(
			rename = "_formatted",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		formatted:  Option<bool>,
		info:       RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Info,
		repository: RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Repository,
	},
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionBody>
	for RegistryPackagePublishedRegistryPackagePackageVersionBody
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersionBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Info {
	pub collection: Option<bool>,
	pub mode:       i64,
	pub name:       String,
	pub oid:        String,
	pub path:       String,
	pub size:       Option<i64>,
	#[serde(rename = "type")]
	pub type_:      String,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Info>
	for RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Info
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Info) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Repository {
	pub repository: Repository,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Repository>
	for RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Repository
{
	fn from(
		value: &RegistryPackagePublishedRegistryPackagePackageVersionBodyVariant1Repository,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub labels:
		Option<RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataLabels>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:
		Option<RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifest>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag:      Option<RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataTag>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadata>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadata
{
	fn from(
		value: &RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadata,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataLabels {
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub all_labels:  std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub image_url:   Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub licenses:    Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub revision:    Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source:      Option<String>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataLabels>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataLabels
{
	fn from(
		value: &RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataLabels,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifest {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub config: Option<
		RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestConfig,
	>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub layers: Vec<
		RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestLayersItem,
	>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub uri:        Option<String>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifest>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifest
{
	fn from(
		value: &RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifest,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestConfig {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestConfig>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestConfig
{
	fn from(
		value : & RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestConfig,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestLayersItem
{
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestLayersItem>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestLayersItem
{
	fn from(
		value : & RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataManifestLayersItem,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataTag {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:   Option<String>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataTag>
	for RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataTag
{
	fn from(
		value: &RegistryPackagePublishedRegistryPackagePackageVersionContainerMetadataTag,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionPackageFilesItem {
	pub content_type: String,
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	pub download_url: String,
	pub id:           i64,
	pub md5:          String,
	pub name:         String,
	pub sha1:         String,
	pub sha256:       String,
	pub size:         i64,
	pub state:        String,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionPackageFilesItem>
	for RegistryPackagePublishedRegistryPackagePackageVersionPackageFilesItem
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersionPackageFilesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackagePackageVersionRelease {
	pub author:           User,
	pub created_at:       chrono::DateTime<chrono::offset::Utc>,
	pub draft:            bool,
	pub html_url:         String,
	pub id:               i64,
	pub name:             String,
	pub prerelease:       bool,
	pub published_at:     chrono::DateTime<chrono::offset::Utc>,
	pub tag_name:         String,
	pub target_commitish: String,
	pub url:              String,
}
impl From<&RegistryPackagePublishedRegistryPackagePackageVersionRelease>
	for RegistryPackagePublishedRegistryPackagePackageVersionRelease
{
	fn from(value: &RegistryPackagePublishedRegistryPackagePackageVersionRelease) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackagePublishedRegistryPackageRegistry {
	pub about_url: String,
	pub name:      String,
	#[serde(rename = "type")]
	pub type_:     String,
	pub url:       String,
	pub vendor:    String,
}
impl From<&RegistryPackagePublishedRegistryPackageRegistry>
	for RegistryPackagePublishedRegistryPackageRegistry
{
	fn from(value: &RegistryPackagePublishedRegistryPackageRegistry) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdated {
	pub action:           RegistryPackageUpdatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:     Option<Organization>,
	pub registry_package: RegistryPackageUpdatedRegistryPackage,
	pub repository:       Repository,
	pub sender:           User,
}
impl From<&RegistryPackageUpdated> for RegistryPackageUpdated {
	fn from(value: &RegistryPackageUpdated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegistryPackageUpdatedAction {
	#[serde(rename = "updated")]
	Updated,
}
impl From<&RegistryPackageUpdatedAction> for RegistryPackageUpdatedAction {
	fn from(value: &RegistryPackageUpdatedAction) -> Self {
		value.clone()
	}
}
impl ToString for RegistryPackageUpdatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Updated => "updated".to_string(),
		}
	}
}
impl std::str::FromStr for RegistryPackageUpdatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"updated" => Ok(Self::Updated),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RegistryPackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RegistryPackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RegistryPackageUpdatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Information about the package.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackage {
	pub created_at:      chrono::DateTime<chrono::offset::Utc>,
	pub description:     Option<String>,
	pub ecosystem:       String,
	pub html_url:        String,
	/// Unique identifier of the package.
	pub id:              i64,
	/// The name of the package.
	pub name:            String,
	pub namespace:       String,
	pub owner:           User,
	/// The type of supported package. Packages in GitHub's Gradle registry have
	/// the type `maven`. Docker images pushed to GitHub's Container registry
	/// (`ghcr.io`) have the type `container`. You can use the type `docker` to
	/// find images that were pushed to GitHub's Docker registry
	/// (`docker.pkg.github.com`), even if these have now been migrated to the
	/// Container registry.
	pub package_type:    RegistryPackageUpdatedRegistryPackagePackageType,
	/// A version of a software package
	pub package_version: Option<RegistryPackageUpdatedRegistryPackagePackageVersion>,
	pub registry:        RegistryPackageUpdatedRegistryPackageRegistry,
	pub updated_at:      Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&RegistryPackageUpdatedRegistryPackage> for RegistryPackageUpdatedRegistryPackage {
	fn from(value: &RegistryPackageUpdatedRegistryPackage) -> Self {
		value.clone()
	}
}
/// The type of supported package. Packages in GitHub's Gradle registry have the
/// type `maven`. Docker images pushed to GitHub's Container registry
/// (`ghcr.io`) have the type `container`. You can use the type `docker` to find
/// images that were pushed to GitHub's Docker registry
/// (`docker.pkg.github.com`), even if these have now been migrated to the
/// Container registry.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegistryPackageUpdatedRegistryPackagePackageType {
	#[serde(rename = "npm")]
	Npm,
	#[serde(rename = "maven")]
	Maven,
	#[serde(rename = "rubygems")]
	Rubygems,
	#[serde(rename = "docker")]
	Docker,
	#[serde(rename = "nuget")]
	Nuget,
	#[serde(rename = "CONTAINER")]
	Container,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageType>
	for RegistryPackageUpdatedRegistryPackagePackageType
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageType) -> Self {
		value.clone()
	}
}
impl ToString for RegistryPackageUpdatedRegistryPackagePackageType {
	fn to_string(&self) -> String {
		match *self {
			Self::Npm => "npm".to_string(),
			Self::Maven => "maven".to_string(),
			Self::Rubygems => "rubygems".to_string(),
			Self::Docker => "docker".to_string(),
			Self::Nuget => "nuget".to_string(),
			Self::Container => "CONTAINER".to_string(),
		}
	}
}
impl std::str::FromStr for RegistryPackageUpdatedRegistryPackagePackageType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"npm" => Ok(Self::Npm),
			"maven" => Ok(Self::Maven),
			"rubygems" => Ok(Self::Rubygems),
			"docker" => Ok(Self::Docker),
			"nuget" => Ok(Self::Nuget),
			"CONTAINER" => Ok(Self::Container),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RegistryPackageUpdatedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RegistryPackageUpdatedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RegistryPackageUpdatedRegistryPackagePackageType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersion {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub author:               Option<RegistryPackageUpdatedRegistryPackagePackageVersionAuthor>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body:                 Option<RegistryPackageUpdatedRegistryPackagePackageVersionBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body_html:            Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub container_metadata:
		Option<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub created_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub description:          String,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub docker_metadata:      Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub draft:                Option<bool>,
	pub html_url:             String,
	/// Unique identifier of the package version.
	pub id:                   i64,
	pub installation_command: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:             Option<String>,
	/// Package Version Metadata
	pub metadata:             Vec<serde_json::Value>,
	/// The name of the package version.
	pub name:                 String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub npm_metadata:         Option<PackageNpmMetadata>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub nuget_metadata:       Option<Vec<PackageNugetMetadata>>,
	pub package_files: Vec<RegistryPackageUpdatedRegistryPackagePackageVersionPackageFilesItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub package_url:          Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub prerelease:           Option<bool>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub release:              Option<RegistryPackageUpdatedRegistryPackagePackageVersionRelease>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub rubygems_metadata:    Vec<serde_json::Value>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source_url:           Option<String>,
	pub summary:              String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag_name:             Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_commitish:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub target_oid:           Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub updated_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub version:              String,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersion>
	for RegistryPackageUpdatedRegistryPackagePackageVersion
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersion) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionAuthor {
	pub avatar_url:          String,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	pub node_id:             String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               String,
	pub url:                 String,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionAuthor>
	for RegistryPackageUpdatedRegistryPackagePackageVersionAuthor
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionAuthor) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum RegistryPackageUpdatedRegistryPackagePackageVersionBody {
	Variant0(String),
	Variant1 {
		#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
		attributes: std::collections::HashMap<String, serde_json::Value>,
		#[serde(
			rename = "_formatted",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		formatted:  Option<bool>,
		info:       RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Info,
		repository: RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Repository,
	},
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionBody>
	for RegistryPackageUpdatedRegistryPackagePackageVersionBody
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Info {
	pub collection: Option<bool>,
	pub mode:       i64,
	pub name:       String,
	pub oid:        String,
	pub path:       String,
	pub size:       Option<i64>,
	#[serde(rename = "type")]
	pub type_:      String,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Info>
	for RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Info
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Info) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Repository {
	pub repository: Repository,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Repository>
	for RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Repository
{
	fn from(
		value: &RegistryPackageUpdatedRegistryPackagePackageVersionBodyVariant1Repository,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadata {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub labels: Option<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataLabels>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub manifest:
		Option<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifest>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub tag:      Option<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataTag>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadata>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadata
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadata) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataLabels {
	#[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
	pub all_labels:  std::collections::HashMap<String, String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub image_url:   Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub licenses:    Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub revision:    Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub source:      Option<String>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataLabels>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataLabels
{
	fn from(
		value: &RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataLabels,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifest {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub config:
		Option<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestConfig>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub layers:
		Vec<RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestLayersItem>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub uri:        Option<String>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifest>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifest
{
	fn from(
		value: &RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifest,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestConfig {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestConfig>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestConfig
{
	fn from(
		value: &RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestConfig,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestLayersItem {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest:     Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub media_type: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub size:       Option<i64>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestLayersItem>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestLayersItem
{
	fn from(
		value : & RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataManifestLayersItem,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataTag {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub digest: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:   Option<String>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataTag>
	for RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataTag
{
	fn from(
		value: &RegistryPackageUpdatedRegistryPackagePackageVersionContainerMetadataTag,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionPackageFilesItem {
	pub content_type: String,
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	pub download_url: String,
	pub id:           i64,
	pub md5:          String,
	pub name:         String,
	pub sha1:         String,
	pub sha256:       String,
	pub size:         i64,
	pub state:        String,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionPackageFilesItem>
	for RegistryPackageUpdatedRegistryPackagePackageVersionPackageFilesItem
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionPackageFilesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackagePackageVersionRelease {
	pub author:           User,
	pub created_at:       chrono::DateTime<chrono::offset::Utc>,
	pub draft:            bool,
	pub html_url:         String,
	pub id:               i64,
	pub name:             String,
	pub prerelease:       bool,
	pub published_at:     chrono::DateTime<chrono::offset::Utc>,
	pub tag_name:         String,
	pub target_commitish: String,
	pub url:              String,
}
impl From<&RegistryPackageUpdatedRegistryPackagePackageVersionRelease>
	for RegistryPackageUpdatedRegistryPackagePackageVersionRelease
{
	fn from(value: &RegistryPackageUpdatedRegistryPackagePackageVersionRelease) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegistryPackageUpdatedRegistryPackageRegistry {
	pub about_url: String,
	pub name:      String,
	#[serde(rename = "type")]
	pub type_:     String,
	pub url:       String,
	pub vendor:    String,
}
impl From<&RegistryPackageUpdatedRegistryPackageRegistry>
	for RegistryPackageUpdatedRegistryPackageRegistry
{
	fn from(value: &RegistryPackageUpdatedRegistryPackageRegistry) -> Self {
		value.clone()
	}
}
/// The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Release {
	pub assets:           Vec<ReleaseAsset>,
	pub assets_url:       String,
	pub author:           User,
	pub body:             String,
	pub created_at:       Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub discussion_url:   Option<String>,
	/// Wether the release is a draft or published
	pub draft:            bool,
	pub html_url:         String,
	pub id:               i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub mentions_count:   Option<i64>,
	pub name:             String,
	pub node_id:          String,
	/// Whether the release is identified as a prerelease or a full release.
	pub prerelease:       bool,
	pub published_at:     Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub reactions:        Option<Reactions>,
	/// The name of the tag.
	pub tag_name:         String,
	pub tarball_url:      Option<String>,
	/// Specifies the commitish value that determines where the Git tag is
	/// created from.
	pub target_commitish: String,
	pub upload_url:       String,
	pub url:              String,
	pub zipball_url:      Option<String>,
}
impl From<&Release> for Release {
	fn from(value: &Release) -> Self {
		value.clone()
	}
}
/// Data related to a release.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseAsset {
	pub browser_download_url: String,
	pub content_type:         String,
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	pub download_count:       i64,
	pub id:                   i64,
	pub label:                Option<String>,
	/// The file name of the asset.
	pub name:                 String,
	pub node_id:              String,
	pub size:                 i64,
	/// State of the release asset.
	pub state:                ReleaseAssetState,
	pub updated_at:           chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub uploader:             Option<User>,
	pub url:                  String,
}
impl From<&ReleaseAsset> for ReleaseAsset {
	fn from(value: &ReleaseAsset) -> Self {
		value.clone()
	}
}
/// State of the release asset.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseAssetState {
	#[serde(rename = "uploaded")]
	Uploaded,
}
impl From<&ReleaseAssetState> for ReleaseAssetState {
	fn from(value: &ReleaseAssetState) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseAssetState {
	fn to_string(&self) -> String {
		match *self {
			Self::Uploaded => "uploaded".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseAssetState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"uploaded" => Ok(Self::Uploaded),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseAssetState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseAssetState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseAssetState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseCreated {
	pub action:       ReleaseCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleaseCreated> for ReleaseCreated {
	fn from(value: &ReleaseCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&ReleaseCreatedAction> for ReleaseCreatedAction {
	fn from(value: &ReleaseCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseDeleted {
	pub action:       ReleaseDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleaseDeleted> for ReleaseDeleted {
	fn from(value: &ReleaseDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&ReleaseDeletedAction> for ReleaseDeletedAction {
	fn from(value: &ReleaseDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEdited {
	pub action:       ReleaseEditedAction,
	pub changes:      ReleaseEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleaseEdited> for ReleaseEdited {
	fn from(value: &ReleaseEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&ReleaseEditedAction> for ReleaseEditedAction {
	fn from(value: &ReleaseEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub body: Option<ReleaseEditedChangesBody>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name: Option<ReleaseEditedChangesName>,
}
impl From<&ReleaseEditedChanges> for ReleaseEditedChanges {
	fn from(value: &ReleaseEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesBody {
	/// The previous version of the body if the action was `edited`.
	pub from: String,
}
impl From<&ReleaseEditedChangesBody> for ReleaseEditedChangesBody {
	fn from(value: &ReleaseEditedChangesBody) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseEditedChangesName {
	/// The previous version of the name if the action was `edited`.
	pub from: String,
}
impl From<&ReleaseEditedChangesName> for ReleaseEditedChangesName {
	fn from(value: &ReleaseEditedChangesName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ReleaseEvent {
	Created(ReleaseCreated),
	Deleted(ReleaseDeleted),
	Edited(ReleaseEdited),
	Prereleased(ReleasePrereleased),
	Published(ReleasePublished),
	Released(ReleaseReleased),
	Unpublished(ReleaseUnpublished),
}
impl From<&ReleaseEvent> for ReleaseEvent {
	fn from(value: &ReleaseEvent) -> Self {
		value.clone()
	}
}
impl From<ReleaseCreated> for ReleaseEvent {
	fn from(value: ReleaseCreated) -> Self {
		Self::Created(value)
	}
}
impl From<ReleaseDeleted> for ReleaseEvent {
	fn from(value: ReleaseDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<ReleaseEdited> for ReleaseEvent {
	fn from(value: ReleaseEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<ReleasePrereleased> for ReleaseEvent {
	fn from(value: ReleasePrereleased) -> Self {
		Self::Prereleased(value)
	}
}
impl From<ReleasePublished> for ReleaseEvent {
	fn from(value: ReleasePublished) -> Self {
		Self::Published(value)
	}
}
impl From<ReleaseReleased> for ReleaseEvent {
	fn from(value: ReleaseReleased) -> Self {
		Self::Released(value)
	}
}
impl From<ReleaseUnpublished> for ReleaseEvent {
	fn from(value: ReleaseUnpublished) -> Self {
		Self::Unpublished(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePrereleased {
	pub action:       ReleasePrereleasedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleasePrereleased> for ReleasePrereleased {
	fn from(value: &ReleasePrereleased) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePrereleasedAction {
	#[serde(rename = "prereleased")]
	Prereleased,
}
impl From<&ReleasePrereleasedAction> for ReleasePrereleasedAction {
	fn from(value: &ReleasePrereleasedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleasePrereleasedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Prereleased => "prereleased".to_string(),
		}
	}
}
impl std::str::FromStr for ReleasePrereleasedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"prereleased" => Ok(Self::Prereleased),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleasePrereleasedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleasePrereleasedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleasePrereleasedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleasePublished {
	pub action:       ReleasePublishedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleasePublished> for ReleasePublished {
	fn from(value: &ReleasePublished) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleasePublishedAction {
	#[serde(rename = "published")]
	Published,
}
impl From<&ReleasePublishedAction> for ReleasePublishedAction {
	fn from(value: &ReleasePublishedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleasePublishedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Published => "published".to_string(),
		}
	}
}
impl std::str::FromStr for ReleasePublishedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"published" => Ok(Self::Published),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleasePublishedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleasePublishedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleasePublishedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseReleased {
	pub action:       ReleaseReleasedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleaseReleased> for ReleaseReleased {
	fn from(value: &ReleaseReleased) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseReleasedAction {
	#[serde(rename = "released")]
	Released,
}
impl From<&ReleaseReleasedAction> for ReleaseReleasedAction {
	fn from(value: &ReleaseReleasedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseReleasedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Released => "released".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseReleasedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"released" => Ok(Self::Released),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseReleasedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseReleasedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseReleasedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReleaseUnpublished {
	pub action:       ReleaseUnpublishedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub release:      Release,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&ReleaseUnpublished> for ReleaseUnpublished {
	fn from(value: &ReleaseUnpublished) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReleaseUnpublishedAction {
	#[serde(rename = "unpublished")]
	Unpublished,
}
impl From<&ReleaseUnpublishedAction> for ReleaseUnpublishedAction {
	fn from(value: &ReleaseUnpublishedAction) -> Self {
		value.clone()
	}
}
impl ToString for ReleaseUnpublishedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unpublished => "unpublished".to_string(),
		}
	}
}
impl std::str::FromStr for ReleaseUnpublishedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unpublished" => Ok(Self::Unpublished),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for ReleaseUnpublishedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for ReleaseUnpublishedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for ReleaseUnpublishedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepoRef {
	pub id:   i64,
	pub name: String,
	pub url:  String,
}
impl From<&RepoRef> for RepoRef {
	fn from(value: &RepoRef) -> Self {
		value.clone()
	}
}
/// A git repository
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Repository {
	/// Whether to allow auto-merge for pull requests.
	#[serde(default)]
	pub allow_auto_merge: bool,
	/// Whether to allow private forks
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub allow_forking: Option<bool>,
	/// Whether to allow merge commits for pull requests.
	#[serde(default = "defaults::default_bool::<true>")]
	pub allow_merge_commit: bool,
	/// Whether to allow rebase merges for pull requests.
	#[serde(default = "defaults::default_bool::<true>")]
	pub allow_rebase_merge: bool,
	/// Whether to allow squash merges for pull requests.
	#[serde(default = "defaults::default_bool::<true>")]
	pub allow_squash_merge: bool,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub allow_update_branch: Option<bool>,
	/// A template for the API URL to download the repository as an archive.
	pub archive_url: String,
	/// Whether the repository is archived.
	pub archived: bool,
	/// A template for the API URL to list the available assignees for issues in
	/// the repository.
	pub assignees_url: String,
	/// A template for the API URL to create or retrieve a raw Git blob in the
	/// repository.
	pub blobs_url: String,
	/// A template for the API URL to get information about branches in the
	/// repository.
	pub branches_url: String,
	pub clone_url: String,
	/// A template for the API URL to get information about collaborators of the
	/// repository.
	pub collaborators_url: String,
	/// A template for the API URL to get information about comments on the
	/// repository.
	pub comments_url: String,
	/// A template for the API URL to get information about commits on the
	/// repository.
	pub commits_url: String,
	/// A template for the API URL to compare two commits or refs.
	pub compare_url: String,
	/// A template for the API URL to get the contents of the repository.
	pub contents_url: String,
	/// A template for the API URL to list the contributors to the repository.
	pub contributors_url: String,
	pub created_at: RepositoryCreatedAt,
	/// The default branch of the repository.
	pub default_branch: String,
	/// Whether to delete head branches when pull requests are merged
	#[serde(default)]
	pub delete_branch_on_merge: bool,
	/// The API URL to list the deployments of the repository.
	pub deployments_url: String,
	/// The repository description.
	pub description: Option<String>,
	/// Returns whether or not this repository is disabled.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub disabled: Option<bool>,
	/// The API URL to list the downloads on the repository.
	pub downloads_url: String,
	/// The API URL to list the events of the repository.
	pub events_url: String,
	/// Whether the repository is a fork.
	pub fork: bool,
	pub forks: i64,
	pub forks_count: i64,
	/// The API URL to list the forks of the repository.
	pub forks_url: String,
	/// The full, globally unique, name of the repository.
	pub full_name: String,
	/// A template for the API URL to get information about Git commits of the
	/// repository.
	pub git_commits_url: String,
	/// A template for the API URL to get information about Git refs of the
	/// repository.
	pub git_refs_url: String,
	/// A template for the API URL to get information about Git tags of the
	/// repository.
	pub git_tags_url: String,
	pub git_url: String,
	/// Whether discussions are enabled.
	#[serde(default = "defaults::default_bool::<true>")]
	pub has_discussions: bool,
	/// Whether downloads are enabled.
	pub has_downloads: bool,
	/// Whether issues are enabled.
	pub has_issues: bool,
	pub has_pages: bool,
	/// Whether projects are enabled.
	pub has_projects: bool,
	/// Whether the wiki is enabled.
	pub has_wiki: bool,
	pub homepage: Option<String>,
	/// The API URL to list the hooks on the repository.
	pub hooks_url: String,
	/// The URL to view the repository on GitHub.com.
	pub html_url: String,
	/// Unique identifier of the repository
	pub id: i64,
	pub is_template: bool,
	/// A template for the API URL to get information about issue comments on
	/// the repository.
	pub issue_comment_url: String,
	/// A template for the API URL to get information about issue events on the
	/// repository.
	pub issue_events_url: String,
	/// A template for the API URL to get information about issues on the
	/// repository.
	pub issues_url: String,
	/// A template for the API URL to get information about deploy keys on the
	/// repository.
	pub keys_url: String,
	/// A template for the API URL to get information about labels of the
	/// repository.
	pub labels_url: String,
	pub language: Option<String>,
	/// The API URL to get information about the languages of the repository.
	pub languages_url: String,
	pub license: Option<License>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub master_branch: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub merge_commit_message: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub merge_commit_title: Option<String>,
	/// The API URL to merge branches in the repository.
	pub merges_url: String,
	/// A template for the API URL to get information about milestones of the
	/// repository.
	pub milestones_url: String,
	pub mirror_url: Option<String>,
	/// The name of the repository.
	pub name: String,
	/// The GraphQL identifier of the repository.
	pub node_id: String,
	/// A template for the API URL to get information about notifications on the
	/// repository.
	pub notifications_url: String,
	pub open_issues: i64,
	pub open_issues_count: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<String>,
	pub owner: User,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub permissions: Option<RepositoryPermissions>,
	/// Whether the repository is private or public.
	pub private: bool,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub public: Option<bool>,
	/// A template for the API URL to get information about pull requests on the
	/// repository.
	pub pulls_url: String,
	pub pushed_at: RepositoryPushedAt,
	/// A template for the API URL to get information about releases on the
	/// repository.
	pub releases_url: String,
	pub size: i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub squash_merge_commit_message: Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub squash_merge_commit_title: Option<String>,
	pub ssh_url: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub stargazers: Option<i64>,
	pub stargazers_count: i64,
	/// The API URL to list the stargazers on the repository.
	pub stargazers_url: String,
	/// A template for the API URL to get information about statuses of a
	/// commit.
	pub statuses_url: String,
	/// The API URL to list the subscribers on the repository.
	pub subscribers_url: String,
	/// The API URL to subscribe to notifications for this repository.
	pub subscription_url: String,
	pub svn_url: String,
	/// The API URL to get information about tags on the repository.
	pub tags_url: String,
	/// The API URL to list the teams on the repository.
	pub teams_url: String,
	pub topics: Vec<String>,
	/// A template for the API URL to create or retrieve a raw Git tree of the
	/// repository.
	pub trees_url: String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	/// The URL to get more information about the repository from the GitHub
	/// API.
	pub url: String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub use_squash_pr_title_as_default: Option<bool>,
	pub visibility: RepositoryVisibility,
	pub watchers: i64,
	pub watchers_count: i64,
	pub web_commit_signoff_required: bool,
}
impl From<&Repository> for Repository {
	fn from(value: &Repository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryArchived {
	pub action:       RepositoryArchivedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryArchived> for RepositoryArchived {
	fn from(value: &RepositoryArchived) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryArchivedAction {
	#[serde(rename = "archived")]
	Archived,
}
impl From<&RepositoryArchivedAction> for RepositoryArchivedAction {
	fn from(value: &RepositoryArchivedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryArchivedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Archived => "archived".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryArchivedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"archived" => Ok(Self::Archived),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryArchivedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryArchivedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryArchivedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryCreated {
	pub action:       RepositoryCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryCreated> for RepositoryCreated {
	fn from(value: &RepositoryCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&RepositoryCreatedAction> for RepositoryCreatedAction {
	fn from(value: &RepositoryCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryCreatedAt {
	Variant0(i64),
	Variant1(chrono::DateTime<chrono::offset::Utc>),
}
impl From<&RepositoryCreatedAt> for RepositoryCreatedAt {
	fn from(value: &RepositoryCreatedAt) -> Self {
		value.clone()
	}
}
impl std::str::FromStr for RepositoryCreatedAt {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		if let Ok(v) = value.parse() {
			Ok(Self::Variant0(v))
		} else if let Ok(v) = value.parse() {
			Ok(Self::Variant1(v))
		} else {
			Err("string conversion failed for all variants")
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryCreatedAt {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryCreatedAt {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryCreatedAt {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl ToString for RepositoryCreatedAt {
	fn to_string(&self) -> String {
		match self {
			Self::Variant0(x) => x.to_string(),
			Self::Variant1(x) => x.to_string(),
		}
	}
}
impl From<i64> for RepositoryCreatedAt {
	fn from(value: i64) -> Self {
		Self::Variant0(value)
	}
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryCreatedAt {
	fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDeleted {
	pub action:       RepositoryDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryDeleted> for RepositoryDeleted {
	fn from(value: &RepositoryDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&RepositoryDeletedAction> for RepositoryDeletedAction {
	fn from(value: &RepositoryDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryDispatchEvent {
	pub action:         String,
	pub branch:         String,
	pub client_payload: std::collections::HashMap<String, serde_json::Value>,
	pub installation:   InstallationLite,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization:   Option<Organization>,
	pub repository:     Repository,
	pub sender:         User,
}
impl From<&RepositoryDispatchEvent> for RepositoryDispatchEvent {
	fn from(value: &RepositoryDispatchEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEdited {
	pub action:       RepositoryEditedAction,
	pub changes:      RepositoryEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryEdited> for RepositoryEdited {
	fn from(value: &RepositoryEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&RepositoryEditedAction> for RepositoryEditedAction {
	fn from(value: &RepositoryEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub default_branch: Option<RepositoryEditedChangesDefaultBranch>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description:    Option<RepositoryEditedChangesDescription>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub homepage:       Option<RepositoryEditedChangesHomepage>,
}
impl From<&RepositoryEditedChanges> for RepositoryEditedChanges {
	fn from(value: &RepositoryEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDefaultBranch {
	pub from: String,
}
impl From<&RepositoryEditedChangesDefaultBranch> for RepositoryEditedChangesDefaultBranch {
	fn from(value: &RepositoryEditedChangesDefaultBranch) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesDescription {
	pub from: Option<String>,
}
impl From<&RepositoryEditedChangesDescription> for RepositoryEditedChangesDescription {
	fn from(value: &RepositoryEditedChangesDescription) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryEditedChangesHomepage {
	pub from: Option<String>,
}
impl From<&RepositoryEditedChangesHomepage> for RepositoryEditedChangesHomepage {
	fn from(value: &RepositoryEditedChangesHomepage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryEvent {
	Archived(RepositoryArchived),
	Created(RepositoryCreated),
	Deleted(RepositoryDeleted),
	Edited(RepositoryEdited),
	Privatized(RepositoryPrivatized),
	Publicized(RepositoryPublicized),
	Renamed(RepositoryRenamed),
	Transferred(RepositoryTransferred),
	Unarchived(RepositoryUnarchived),
}
impl From<&RepositoryEvent> for RepositoryEvent {
	fn from(value: &RepositoryEvent) -> Self {
		value.clone()
	}
}
impl From<RepositoryArchived> for RepositoryEvent {
	fn from(value: RepositoryArchived) -> Self {
		Self::Archived(value)
	}
}
impl From<RepositoryCreated> for RepositoryEvent {
	fn from(value: RepositoryCreated) -> Self {
		Self::Created(value)
	}
}
impl From<RepositoryDeleted> for RepositoryEvent {
	fn from(value: RepositoryDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<RepositoryEdited> for RepositoryEvent {
	fn from(value: RepositoryEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<RepositoryPrivatized> for RepositoryEvent {
	fn from(value: RepositoryPrivatized) -> Self {
		Self::Privatized(value)
	}
}
impl From<RepositoryPublicized> for RepositoryEvent {
	fn from(value: RepositoryPublicized) -> Self {
		Self::Publicized(value)
	}
}
impl From<RepositoryRenamed> for RepositoryEvent {
	fn from(value: RepositoryRenamed) -> Self {
		Self::Renamed(value)
	}
}
impl From<RepositoryTransferred> for RepositoryEvent {
	fn from(value: RepositoryTransferred) -> Self {
		Self::Transferred(value)
	}
}
impl From<RepositoryUnarchived> for RepositoryEvent {
	fn from(value: RepositoryUnarchived) -> Self {
		Self::Unarchived(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryImportEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub status:       RepositoryImportEventStatus,
}
impl From<&RepositoryImportEvent> for RepositoryImportEvent {
	fn from(value: &RepositoryImportEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryImportEventStatus {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "failure")]
	Failure,
}
impl From<&RepositoryImportEventStatus> for RepositoryImportEventStatus {
	fn from(value: &RepositoryImportEventStatus) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryImportEventStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::Failure => "failure".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryImportEventStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"cancelled" => Ok(Self::Cancelled),
			"failure" => Ok(Self::Failure),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryImportEventStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryImportEventStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryImportEventStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryLite {
	/// A template for the API URL to download the repository as an archive.
	pub archive_url:       String,
	/// A template for the API URL to list the available assignees for issues in
	/// the repository.
	pub assignees_url:     String,
	/// A template for the API URL to create or retrieve a raw Git blob in the
	/// repository.
	pub blobs_url:         String,
	/// A template for the API URL to get information about branches in the
	/// repository.
	pub branches_url:      String,
	/// A template for the API URL to get information about collaborators of the
	/// repository.
	pub collaborators_url: String,
	/// A template for the API URL to get information about comments on the
	/// repository.
	pub comments_url:      String,
	/// A template for the API URL to get information about commits on the
	/// repository.
	pub commits_url:       String,
	/// A template for the API URL to compare two commits or refs.
	pub compare_url:       String,
	/// A template for the API URL to get the contents of the repository.
	pub contents_url:      String,
	/// A template for the API URL to list the contributors to the repository.
	pub contributors_url:  String,
	/// The API URL to list the deployments of the repository.
	pub deployments_url:   String,
	/// The repository description.
	pub description:       Option<String>,
	/// The API URL to list the downloads on the repository.
	pub downloads_url:     String,
	/// The API URL to list the events of the repository.
	pub events_url:        String,
	/// Whether the repository is a fork.
	pub fork:              bool,
	/// The API URL to list the forks of the repository.
	pub forks_url:         String,
	/// The full, globally unique, name of the repository.
	pub full_name:         String,
	/// A template for the API URL to get information about Git commits of the
	/// repository.
	pub git_commits_url:   String,
	/// A template for the API URL to get information about Git refs of the
	/// repository.
	pub git_refs_url:      String,
	/// A template for the API URL to get information about Git tags of the
	/// repository.
	pub git_tags_url:      String,
	/// The API URL to list the hooks on the repository.
	pub hooks_url:         String,
	/// The URL to view the repository on GitHub.com.
	pub html_url:          String,
	/// Unique identifier of the repository
	pub id:                i64,
	/// A template for the API URL to get information about issue comments on
	/// the repository.
	pub issue_comment_url: String,
	/// A template for the API URL to get information about issue events on the
	/// repository.
	pub issue_events_url:  String,
	/// A template for the API URL to get information about issues on the
	/// repository.
	pub issues_url:        String,
	/// A template for the API URL to get information about deploy keys on the
	/// repository.
	pub keys_url:          String,
	/// A template for the API URL to get information about labels of the
	/// repository.
	pub labels_url:        String,
	/// The API URL to get information about the languages of the repository.
	pub languages_url:     String,
	/// The API URL to merge branches in the repository.
	pub merges_url:        String,
	/// A template for the API URL to get information about milestones of the
	/// repository.
	pub milestones_url:    String,
	/// The name of the repository.
	pub name:              String,
	/// The GraphQL identifier of the repository.
	pub node_id:           String,
	/// A template for the API URL to get information about notifications on the
	/// repository.
	pub notifications_url: String,
	pub owner:             User,
	/// Whether the repository is private or public.
	pub private:           bool,
	/// A template for the API URL to get information about pull requests on the
	/// repository.
	pub pulls_url:         String,
	/// A template for the API URL to get information about releases on the
	/// repository.
	pub releases_url:      String,
	/// The API URL to list the stargazers on the repository.
	pub stargazers_url:    String,
	/// A template for the API URL to get information about statuses of a
	/// commit.
	pub statuses_url:      String,
	/// The API URL to list the subscribers on the repository.
	pub subscribers_url:   String,
	/// The API URL to subscribe to notifications for this repository.
	pub subscription_url:  String,
	/// The API URL to get information about tags on the repository.
	pub tags_url:          String,
	/// The API URL to list the teams on the repository.
	pub teams_url:         String,
	/// A template for the API URL to create or retrieve a raw Git tree of the
	/// repository.
	pub trees_url:         String,
	/// The URL to get more information about the repository from the GitHub
	/// API.
	pub url:               String,
}
impl From<&RepositoryLite> for RepositoryLite {
	fn from(value: &RepositoryLite) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPermissions {
	pub admin:    bool,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub maintain: Option<bool>,
	pub pull:     bool,
	pub push:     bool,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub triage:   Option<bool>,
}
impl From<&RepositoryPermissions> for RepositoryPermissions {
	fn from(value: &RepositoryPermissions) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPrivatized {
	pub action:       RepositoryPrivatizedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryPrivatized> for RepositoryPrivatized {
	fn from(value: &RepositoryPrivatized) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPrivatizedAction {
	#[serde(rename = "privatized")]
	Privatized,
}
impl From<&RepositoryPrivatizedAction> for RepositoryPrivatizedAction {
	fn from(value: &RepositoryPrivatizedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryPrivatizedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Privatized => "privatized".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryPrivatizedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"privatized" => Ok(Self::Privatized),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryPrivatizedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryPrivatizedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryPrivatizedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryPublicized {
	pub action:       RepositoryPublicizedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryPublicized> for RepositoryPublicized {
	fn from(value: &RepositoryPublicized) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryPublicizedAction {
	#[serde(rename = "publicized")]
	Publicized,
}
impl From<&RepositoryPublicizedAction> for RepositoryPublicizedAction {
	fn from(value: &RepositoryPublicizedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryPublicizedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Publicized => "publicized".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryPublicizedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"publicized" => Ok(Self::Publicized),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryPublicizedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryPublicizedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryPublicizedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryPushedAt {
	Variant0(i64),
	Variant1(chrono::DateTime<chrono::offset::Utc>),
	Variant2,
}
impl From<&RepositoryPushedAt> for RepositoryPushedAt {
	fn from(value: &RepositoryPushedAt) -> Self {
		value.clone()
	}
}
impl From<i64> for RepositoryPushedAt {
	fn from(value: i64) -> Self {
		Self::Variant0(value)
	}
}
impl From<chrono::DateTime<chrono::offset::Utc>> for RepositoryPushedAt {
	fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamed {
	pub action:       RepositoryRenamedAction,
	pub changes:      RepositoryRenamedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryRenamed> for RepositoryRenamed {
	fn from(value: &RepositoryRenamed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryRenamedAction {
	#[serde(rename = "renamed")]
	Renamed,
}
impl From<&RepositoryRenamedAction> for RepositoryRenamedAction {
	fn from(value: &RepositoryRenamedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryRenamedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Renamed => "renamed".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryRenamedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"renamed" => Ok(Self::Renamed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryRenamedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryRenamedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryRenamedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChanges {
	pub repository: RepositoryRenamedChangesRepository,
}
impl From<&RepositoryRenamedChanges> for RepositoryRenamedChanges {
	fn from(value: &RepositoryRenamedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepository {
	pub name: RepositoryRenamedChangesRepositoryName,
}
impl From<&RepositoryRenamedChangesRepository> for RepositoryRenamedChangesRepository {
	fn from(value: &RepositoryRenamedChangesRepository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryRenamedChangesRepositoryName {
	pub from: String,
}
impl From<&RepositoryRenamedChangesRepositoryName> for RepositoryRenamedChangesRepositoryName {
	fn from(value: &RepositoryRenamedChangesRepositoryName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferred {
	pub action:       RepositoryTransferredAction,
	pub changes:      RepositoryTransferredChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryTransferred> for RepositoryTransferred {
	fn from(value: &RepositoryTransferred) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryTransferredAction {
	#[serde(rename = "transferred")]
	Transferred,
}
impl From<&RepositoryTransferredAction> for RepositoryTransferredAction {
	fn from(value: &RepositoryTransferredAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryTransferredAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Transferred => "transferred".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryTransferredAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"transferred" => Ok(Self::Transferred),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryTransferredAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryTransferredAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryTransferredAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChanges {
	pub owner: RepositoryTransferredChangesOwner,
}
impl From<&RepositoryTransferredChanges> for RepositoryTransferredChanges {
	fn from(value: &RepositoryTransferredChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwner {
	pub from: RepositoryTransferredChangesOwnerFrom,
}
impl From<&RepositoryTransferredChangesOwner> for RepositoryTransferredChangesOwner {
	fn from(value: &RepositoryTransferredChangesOwner) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryTransferredChangesOwnerFrom {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub user: Option<User>,
}
impl From<&RepositoryTransferredChangesOwnerFrom> for RepositoryTransferredChangesOwnerFrom {
	fn from(value: &RepositoryTransferredChangesOwnerFrom) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryUnarchived {
	pub action:       RepositoryUnarchivedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&RepositoryUnarchived> for RepositoryUnarchived {
	fn from(value: &RepositoryUnarchived) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryUnarchivedAction {
	#[serde(rename = "unarchived")]
	Unarchived,
}
impl From<&RepositoryUnarchivedAction> for RepositoryUnarchivedAction {
	fn from(value: &RepositoryUnarchivedAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryUnarchivedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Unarchived => "unarchived".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryUnarchivedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"unarchived" => Ok(Self::Unarchived),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryUnarchivedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryUnarchivedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryUnarchivedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVisibility {
	#[serde(rename = "public")]
	Public,
	#[serde(rename = "private")]
	Private,
	#[serde(rename = "internal")]
	Internal,
}
impl From<&RepositoryVisibility> for RepositoryVisibility {
	fn from(value: &RepositoryVisibility) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVisibility {
	fn to_string(&self) -> String {
		match *self {
			Self::Public => "public".to_string(),
			Self::Private => "private".to_string(),
			Self::Internal => "internal".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVisibility {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"public" => Ok(Self::Public),
			"private" => Ok(Self::Private),
			"internal" => Ok(Self::Internal),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVisibility {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVisibility {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVisibility {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The security alert of the vulnerable dependency.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertAlert {
	pub affected_package_name: String,
	pub affected_range:        String,
	pub created_at:            chrono::DateTime<chrono::offset::Utc>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub dismiss_reason:        Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub dismissed_at:          Option<chrono::DateTime<chrono::offset::Utc>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub dismisser:             Option<User>,
	pub external_identifier:   String,
	pub external_reference:    String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub fix_reason:            Option<String>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub fixed_at:              Option<chrono::DateTime<chrono::offset::Utc>>,
	pub fixed_in:              String,
	pub ghsa_id:               String,
	pub id:                    i64,
	pub node_id:               String,
	pub number:                i64,
	pub severity:              String,
	pub state:                 RepositoryVulnerabilityAlertAlertState,
}
impl From<&RepositoryVulnerabilityAlertAlert> for RepositoryVulnerabilityAlertAlert {
	fn from(value: &RepositoryVulnerabilityAlertAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertAlertState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "dismissed")]
	Dismissed,
	#[serde(rename = "fixed")]
	Fixed,
}
impl From<&RepositoryVulnerabilityAlertAlertState> for RepositoryVulnerabilityAlertAlertState {
	fn from(value: &RepositoryVulnerabilityAlertAlertState) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVulnerabilityAlertAlertState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Dismissed => "dismissed".to_string(),
			Self::Fixed => "fixed".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVulnerabilityAlertAlertState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"dismissed" => Ok(Self::Dismissed),
			"fixed" => Ok(Self::Fixed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertAlertState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertAlertState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertAlertState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertCreate {
	pub action:       RepositoryVulnerabilityAlertCreateAction,
	pub alert:        RepositoryVulnerabilityAlertAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertCreate {
	fn from(value: &RepositoryVulnerabilityAlertCreate) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertCreateAction {
	#[serde(rename = "create")]
	Create,
}
impl From<&RepositoryVulnerabilityAlertCreateAction> for RepositoryVulnerabilityAlertCreateAction {
	fn from(value: &RepositoryVulnerabilityAlertCreateAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVulnerabilityAlertCreateAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Create => "create".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVulnerabilityAlertCreateAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"create" => Ok(Self::Create),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertCreateAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertCreateAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertCreateAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertDismiss {
	pub action:       RepositoryVulnerabilityAlertDismissAction,
	pub alert:        RepositoryVulnerabilityAlertAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertDismiss {
	fn from(value: &RepositoryVulnerabilityAlertDismiss) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertDismissAction {
	#[serde(rename = "dismiss")]
	Dismiss,
}
impl From<&RepositoryVulnerabilityAlertDismissAction>
	for RepositoryVulnerabilityAlertDismissAction
{
	fn from(value: &RepositoryVulnerabilityAlertDismissAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVulnerabilityAlertDismissAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Dismiss => "dismiss".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVulnerabilityAlertDismissAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"dismiss" => Ok(Self::Dismiss),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertDismissAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertDismissAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertDismissAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RepositoryVulnerabilityAlertEvent {
	Create(RepositoryVulnerabilityAlertCreate),
	Dismiss(RepositoryVulnerabilityAlertDismiss),
	Reopen(RepositoryVulnerabilityAlertReopen),
	Resolve(RepositoryVulnerabilityAlertResolve),
}
impl From<&RepositoryVulnerabilityAlertEvent> for RepositoryVulnerabilityAlertEvent {
	fn from(value: &RepositoryVulnerabilityAlertEvent) -> Self {
		value.clone()
	}
}
impl From<RepositoryVulnerabilityAlertCreate> for RepositoryVulnerabilityAlertEvent {
	fn from(value: RepositoryVulnerabilityAlertCreate) -> Self {
		Self::Create(value)
	}
}
impl From<RepositoryVulnerabilityAlertDismiss> for RepositoryVulnerabilityAlertEvent {
	fn from(value: RepositoryVulnerabilityAlertDismiss) -> Self {
		Self::Dismiss(value)
	}
}
impl From<RepositoryVulnerabilityAlertReopen> for RepositoryVulnerabilityAlertEvent {
	fn from(value: RepositoryVulnerabilityAlertReopen) -> Self {
		Self::Reopen(value)
	}
}
impl From<RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertEvent {
	fn from(value: RepositoryVulnerabilityAlertResolve) -> Self {
		Self::Resolve(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertReopen {
	pub action:       RepositoryVulnerabilityAlertReopenAction,
	pub alert:        RepositoryVulnerabilityAlertAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&RepositoryVulnerabilityAlertReopen> for RepositoryVulnerabilityAlertReopen {
	fn from(value: &RepositoryVulnerabilityAlertReopen) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertReopenAction {
	#[serde(rename = "reopen")]
	Reopen,
}
impl From<&RepositoryVulnerabilityAlertReopenAction> for RepositoryVulnerabilityAlertReopenAction {
	fn from(value: &RepositoryVulnerabilityAlertReopenAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVulnerabilityAlertReopenAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopen => "reopen".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVulnerabilityAlertReopenAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopen" => Ok(Self::Reopen),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertReopenAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertReopenAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertReopenAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RepositoryVulnerabilityAlertResolve {
	pub action:       RepositoryVulnerabilityAlertResolveAction,
	pub alert:        RepositoryVulnerabilityAlertAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       GithubOrg,
}
impl From<&RepositoryVulnerabilityAlertResolve> for RepositoryVulnerabilityAlertResolve {
	fn from(value: &RepositoryVulnerabilityAlertResolve) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RepositoryVulnerabilityAlertResolveAction {
	#[serde(rename = "resolve")]
	Resolve,
}
impl From<&RepositoryVulnerabilityAlertResolveAction>
	for RepositoryVulnerabilityAlertResolveAction
{
	fn from(value: &RepositoryVulnerabilityAlertResolveAction) -> Self {
		value.clone()
	}
}
impl ToString for RepositoryVulnerabilityAlertResolveAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolve => "resolve".to_string(),
		}
	}
}
impl std::str::FromStr for RepositoryVulnerabilityAlertResolveAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolve" => Ok(Self::Resolve),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for RepositoryVulnerabilityAlertResolveAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for RepositoryVulnerabilityAlertResolveAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for RepositoryVulnerabilityAlertResolveAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreated {
	pub action:       SecretScanningAlertCreatedAction,
	pub alert:        SecretScanningAlertCreatedAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
}
impl From<&SecretScanningAlertCreated> for SecretScanningAlertCreated {
	fn from(value: &SecretScanningAlertCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&SecretScanningAlertCreatedAction> for SecretScanningAlertCreatedAction {
	fn from(value: &SecretScanningAlertCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecretScanningAlertCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for SecretScanningAlertCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecretScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecretScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecretScanningAlertCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The secret scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertCreatedAlert {
	pub number:      i64,
	pub resolution:  (),
	pub resolved_at: (),
	pub resolved_by: (),
	pub secret_type: String,
}
impl From<&SecretScanningAlertCreatedAlert> for SecretScanningAlertCreatedAlert {
	fn from(value: &SecretScanningAlertCreatedAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecretScanningAlertEvent {
	Created(SecretScanningAlertCreated),
	Reopened(SecretScanningAlertReopened),
	Resolved(SecretScanningAlertResolved),
}
impl From<&SecretScanningAlertEvent> for SecretScanningAlertEvent {
	fn from(value: &SecretScanningAlertEvent) -> Self {
		value.clone()
	}
}
impl From<SecretScanningAlertCreated> for SecretScanningAlertEvent {
	fn from(value: SecretScanningAlertCreated) -> Self {
		Self::Created(value)
	}
}
impl From<SecretScanningAlertReopened> for SecretScanningAlertEvent {
	fn from(value: SecretScanningAlertReopened) -> Self {
		Self::Reopened(value)
	}
}
impl From<SecretScanningAlertResolved> for SecretScanningAlertEvent {
	fn from(value: SecretScanningAlertResolved) -> Self {
		Self::Resolved(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopened {
	pub action:       SecretScanningAlertReopenedAction,
	pub alert:        SecretScanningAlertReopenedAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&SecretScanningAlertReopened> for SecretScanningAlertReopened {
	fn from(value: &SecretScanningAlertReopened) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertReopenedAction {
	#[serde(rename = "reopened")]
	Reopened,
}
impl From<&SecretScanningAlertReopenedAction> for SecretScanningAlertReopenedAction {
	fn from(value: &SecretScanningAlertReopenedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecretScanningAlertReopenedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Reopened => "reopened".to_string(),
		}
	}
}
impl std::str::FromStr for SecretScanningAlertReopenedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"reopened" => Ok(Self::Reopened),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecretScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecretScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecretScanningAlertReopenedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The secret scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertReopenedAlert {
	pub number:      i64,
	pub resolution:  (),
	pub resolved_at: (),
	pub resolved_by: (),
	pub secret_type: String,
}
impl From<&SecretScanningAlertReopenedAlert> for SecretScanningAlertReopenedAlert {
	fn from(value: &SecretScanningAlertReopenedAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolved {
	pub action:       SecretScanningAlertResolvedAction,
	pub alert:        SecretScanningAlertResolvedAlert,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&SecretScanningAlertResolved> for SecretScanningAlertResolved {
	fn from(value: &SecretScanningAlertResolved) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAction {
	#[serde(rename = "resolved")]
	Resolved,
}
impl From<&SecretScanningAlertResolvedAction> for SecretScanningAlertResolvedAction {
	fn from(value: &SecretScanningAlertResolvedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecretScanningAlertResolvedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
		}
	}
}
impl std::str::FromStr for SecretScanningAlertResolvedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The secret scanning alert involved in the event.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecretScanningAlertResolvedAlert {
	pub number:      i64,
	pub resolution:  SecretScanningAlertResolvedAlertResolution,
	pub resolved_at: chrono::DateTime<chrono::offset::Utc>,
	pub resolved_by: User,
	pub secret_type: String,
}
impl From<&SecretScanningAlertResolvedAlert> for SecretScanningAlertResolvedAlert {
	fn from(value: &SecretScanningAlertResolvedAlert) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecretScanningAlertResolvedAlertResolution {
	#[serde(rename = "false_positive")]
	FalsePositive,
	#[serde(rename = "wontfix")]
	Wontfix,
	#[serde(rename = "revoked")]
	Revoked,
	#[serde(rename = "used_in_tests")]
	UsedInTests,
}
impl From<&SecretScanningAlertResolvedAlertResolution>
	for SecretScanningAlertResolvedAlertResolution
{
	fn from(value: &SecretScanningAlertResolvedAlertResolution) -> Self {
		value.clone()
	}
}
impl ToString for SecretScanningAlertResolvedAlertResolution {
	fn to_string(&self) -> String {
		match *self {
			Self::FalsePositive => "false_positive".to_string(),
			Self::Wontfix => "wontfix".to_string(),
			Self::Revoked => "revoked".to_string(),
			Self::UsedInTests => "used_in_tests".to_string(),
		}
	}
}
impl std::str::FromStr for SecretScanningAlertResolvedAlertResolution {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"false_positive" => Ok(Self::FalsePositive),
			"wontfix" => Ok(Self::Wontfix),
			"revoked" => Ok(Self::Revoked),
			"used_in_tests" => Ok(Self::UsedInTests),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecretScanningAlertResolvedAlertResolution {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecretScanningAlertResolvedAlertResolution {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecretScanningAlertResolvedAlertResolution {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Details for the advisory pertaining to the Common Vulnerability Scoring
/// System.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryCvss {
	pub score:         f64,
	/// The full CVSS vector string for the advisory.
	pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryCvss> for SecurityAdvisoryCvss {
	fn from(value: &SecurityAdvisoryCvss) -> Self {
		value.clone()
	}
}
/// A CWE weakness assigned to the advisory.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryCwes {
	/// The unique CWE ID.
	pub cwe_id: String,
	/// The short, plain text name of the CWE.
	pub name:   String,
}
impl From<&SecurityAdvisoryCwes> for SecurityAdvisoryCwes {
	fn from(value: &SecurityAdvisoryCwes) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SecurityAdvisoryEvent {
	Performed(SecurityAdvisoryPerformed),
	Published(SecurityAdvisoryPublished),
	Updated(SecurityAdvisoryUpdated),
	Withdrawn(SecurityAdvisoryWithdrawn),
}
impl From<&SecurityAdvisoryEvent> for SecurityAdvisoryEvent {
	fn from(value: &SecurityAdvisoryEvent) -> Self {
		value.clone()
	}
}
impl From<SecurityAdvisoryPerformed> for SecurityAdvisoryEvent {
	fn from(value: SecurityAdvisoryPerformed) -> Self {
		Self::Performed(value)
	}
}
impl From<SecurityAdvisoryPublished> for SecurityAdvisoryEvent {
	fn from(value: SecurityAdvisoryPublished) -> Self {
		Self::Published(value)
	}
}
impl From<SecurityAdvisoryUpdated> for SecurityAdvisoryEvent {
	fn from(value: SecurityAdvisoryUpdated) -> Self {
		Self::Updated(value)
	}
}
impl From<SecurityAdvisoryWithdrawn> for SecurityAdvisoryEvent {
	fn from(value: SecurityAdvisoryWithdrawn) -> Self {
		Self::Withdrawn(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformed {
	pub action:            SecurityAdvisoryPerformedAction,
	pub security_advisory: SecurityAdvisoryPerformedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPerformed> for SecurityAdvisoryPerformed {
	fn from(value: &SecurityAdvisoryPerformed) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPerformedAction {
	#[serde(rename = "performed")]
	Performed,
}
impl From<&SecurityAdvisoryPerformedAction> for SecurityAdvisoryPerformedAction {
	fn from(value: &SecurityAdvisoryPerformedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecurityAdvisoryPerformedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Performed => "performed".to_string(),
		}
	}
}
impl std::str::FromStr for SecurityAdvisoryPerformedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"performed" => Ok(Self::Performed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPerformedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPerformedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPerformedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The details of the security advisory, including summary, description, and
/// severity.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisory {
	pub cve_id:          Option<String>,
	pub cvss:            SecurityAdvisoryPerformedSecurityAdvisoryCvss,
	pub cwes:            Vec<SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>,
	pub description:     String,
	pub ghsa_id:         String,
	pub identifiers:     Vec<SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>,
	pub published_at:    chrono::DateTime<chrono::offset::Utc>,
	pub references:      Vec<SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>,
	pub severity:        String,
	pub summary:         String,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
	pub vulnerabilities: Vec<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>,
	pub withdrawn_at:    Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisory>
	for SecurityAdvisoryPerformedSecurityAdvisory
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCvss {
	pub score:         f64,
	pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCvss>
	for SecurityAdvisoryPerformedSecurityAdvisoryCvss
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCvss) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryCwesItem {
	pub cwe_id: String,
	pub name:   String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryCwesItem>
	for SecurityAdvisoryPerformedSecurityAdvisoryCwesItem
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryCwesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem {
	#[serde(rename = "type")]
	pub type_: String,
	pub value: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem>
	for SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryIdentifiersItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem {
	pub url: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem>
	for SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryReferencesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem {
	pub first_patched_version:
		Option<SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
	pub package: SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage,
	pub severity:                 String,
	pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem>
	for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
	pub identifier: String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
	for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
	fn from(
		value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage {
	pub ecosystem: String,
	pub name:      String,
}
impl From<&SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage>
	for SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage
{
	fn from(value: &SecurityAdvisoryPerformedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublished {
	pub action:            SecurityAdvisoryPublishedAction,
	pub security_advisory: SecurityAdvisoryPublishedSecurityAdvisory,
}
impl From<&SecurityAdvisoryPublished> for SecurityAdvisoryPublished {
	fn from(value: &SecurityAdvisoryPublished) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryPublishedAction {
	#[serde(rename = "published")]
	Published,
}
impl From<&SecurityAdvisoryPublishedAction> for SecurityAdvisoryPublishedAction {
	fn from(value: &SecurityAdvisoryPublishedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecurityAdvisoryPublishedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Published => "published".to_string(),
		}
	}
}
impl std::str::FromStr for SecurityAdvisoryPublishedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"published" => Ok(Self::Published),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryPublishedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryPublishedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecurityAdvisoryPublishedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The details of the security advisory, including summary, description, and
/// severity.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisory {
	pub cve_id:          Option<String>,
	pub cvss:            SecurityAdvisoryPublishedSecurityAdvisoryCvss,
	pub cwes:            Vec<SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>,
	pub description:     String,
	pub ghsa_id:         String,
	pub identifiers:     Vec<SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>,
	pub published_at:    chrono::DateTime<chrono::offset::Utc>,
	pub references:      Vec<SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>,
	pub severity:        String,
	pub summary:         String,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
	pub vulnerabilities: Vec<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>,
	pub withdrawn_at:    Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisory>
	for SecurityAdvisoryPublishedSecurityAdvisory
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCvss {
	pub score:         f64,
	pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCvss>
	for SecurityAdvisoryPublishedSecurityAdvisoryCvss
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCvss) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryCwesItem {
	pub cwe_id: String,
	pub name:   String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryCwesItem>
	for SecurityAdvisoryPublishedSecurityAdvisoryCwesItem
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryCwesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem {
	#[serde(rename = "type")]
	pub type_: String,
	pub value: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem>
	for SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryIdentifiersItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem {
	pub url: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem>
	for SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryReferencesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem {
	pub first_patched_version:
		Option<SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
	pub package: SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage,
	pub severity:                 String,
	pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem>
	for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
	pub identifier: String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
	for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
	fn from(
		value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage {
	pub ecosystem: String,
	pub name:      String,
}
impl From<&SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage>
	for SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage
{
	fn from(value: &SecurityAdvisoryPublishedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdated {
	pub action:            SecurityAdvisoryUpdatedAction,
	pub security_advisory: SecurityAdvisoryUpdatedSecurityAdvisory,
}
impl From<&SecurityAdvisoryUpdated> for SecurityAdvisoryUpdated {
	fn from(value: &SecurityAdvisoryUpdated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryUpdatedAction {
	#[serde(rename = "updated")]
	Updated,
}
impl From<&SecurityAdvisoryUpdatedAction> for SecurityAdvisoryUpdatedAction {
	fn from(value: &SecurityAdvisoryUpdatedAction) -> Self {
		value.clone()
	}
}
impl ToString for SecurityAdvisoryUpdatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Updated => "updated".to_string(),
		}
	}
}
impl std::str::FromStr for SecurityAdvisoryUpdatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"updated" => Ok(Self::Updated),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryUpdatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecurityAdvisoryUpdatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The details of the security advisory, including summary, description, and
/// severity.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisory {
	pub cve_id:          Option<String>,
	pub cvss:            SecurityAdvisoryUpdatedSecurityAdvisoryCvss,
	pub cwes:            Vec<SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>,
	pub description:     String,
	pub ghsa_id:         String,
	pub identifiers:     Vec<SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>,
	pub published_at:    chrono::DateTime<chrono::offset::Utc>,
	pub references:      Vec<SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>,
	pub severity:        String,
	pub summary:         String,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
	pub vulnerabilities: Vec<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>,
	pub withdrawn_at:    Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisory> for SecurityAdvisoryUpdatedSecurityAdvisory {
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCvss {
	pub score:         f64,
	pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCvss>
	for SecurityAdvisoryUpdatedSecurityAdvisoryCvss
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCvss) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem {
	pub cwe_id: String,
	pub name:   String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem>
	for SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryCwesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem {
	#[serde(rename = "type")]
	pub type_: String,
	pub value: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem>
	for SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryIdentifiersItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem {
	pub url: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem>
	for SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryReferencesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem {
	pub first_patched_version:
		Option<SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
	pub package:                  SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage,
	pub severity:                 String,
	pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem>
	for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
	pub identifier: String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
	for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
	fn from(
		value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage {
	pub ecosystem: String,
	pub name:      String,
}
impl From<&SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage>
	for SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage
{
	fn from(value: &SecurityAdvisoryUpdatedSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawn {
	pub action:            SecurityAdvisoryWithdrawnAction,
	pub security_advisory: SecurityAdvisoryWithdrawnSecurityAdvisory,
}
impl From<&SecurityAdvisoryWithdrawn> for SecurityAdvisoryWithdrawn {
	fn from(value: &SecurityAdvisoryWithdrawn) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SecurityAdvisoryWithdrawnAction {
	#[serde(rename = "withdrawn")]
	Withdrawn,
}
impl From<&SecurityAdvisoryWithdrawnAction> for SecurityAdvisoryWithdrawnAction {
	fn from(value: &SecurityAdvisoryWithdrawnAction) -> Self {
		value.clone()
	}
}
impl ToString for SecurityAdvisoryWithdrawnAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Withdrawn => "withdrawn".to_string(),
		}
	}
}
impl std::str::FromStr for SecurityAdvisoryWithdrawnAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"withdrawn" => Ok(Self::Withdrawn),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SecurityAdvisoryWithdrawnAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SecurityAdvisoryWithdrawnAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SecurityAdvisoryWithdrawnAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The details of the security advisory, including summary, description, and
/// severity.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisory {
	pub cve_id:          Option<String>,
	pub cvss:            SecurityAdvisoryWithdrawnSecurityAdvisoryCvss,
	pub cwes:            Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>,
	pub description:     String,
	pub ghsa_id:         String,
	pub identifiers:     Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>,
	pub published_at:    chrono::DateTime<chrono::offset::Utc>,
	pub references:      Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>,
	pub severity:        String,
	pub summary:         String,
	pub updated_at:      chrono::DateTime<chrono::offset::Utc>,
	pub vulnerabilities: Vec<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>,
	pub withdrawn_at:    chrono::DateTime<chrono::offset::Utc>,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisory>
	for SecurityAdvisoryWithdrawnSecurityAdvisory
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisory) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCvss {
	pub score:         f64,
	pub vector_string: Option<String>,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCvss>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryCvss
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCvss) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem {
	pub cwe_id: String,
	pub name:   String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryCwesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem {
	#[serde(rename = "type")]
	pub type_: String,
	pub value: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryIdentifiersItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem {
	pub url: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryReferencesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem {
	pub first_patched_version:
		Option<SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>,
	pub package: SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage,
	pub severity:                 String,
	pub vulnerable_version_range: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion {
	pub identifier: String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion
{
	fn from(
		value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemFirstPatchedVersion,
	) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage {
	pub ecosystem: String,
	pub name:      String,
}
impl From<&SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage>
	for SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage
{
	fn from(value: &SecurityAdvisoryWithdrawnSecurityAdvisoryVulnerabilitiesItemPackage) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequest {
	pub active_lock_reason:  Option<SimplePullRequestActiveLockReason>,
	pub assignee:            Option<User>,
	pub assignees:           Vec<User>,
	pub author_association:  AuthorAssociation,
	pub auto_merge:          Option<AutoMerge>,
	pub base:                SimplePullRequestBase,
	pub body:                Option<String>,
	pub closed_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub comments_url:        String,
	pub commits_url:         String,
	pub created_at:          chrono::DateTime<chrono::offset::Utc>,
	pub diff_url:            String,
	pub draft:               bool,
	pub head:                SimplePullRequestHead,
	pub html_url:            String,
	pub id:                  i64,
	pub issue_url:           String,
	pub labels:              Vec<Label>,
	#[serde(rename = "_links")]
	pub links:               SimplePullRequestLinks,
	pub locked:              bool,
	pub merge_commit_sha:    Option<String>,
	pub merged_at:           Option<chrono::DateTime<chrono::offset::Utc>>,
	pub milestone:           Option<Milestone>,
	pub node_id:             String,
	pub number:              i64,
	pub patch_url:           String,
	pub requested_reviewers: Vec<SimplePullRequestRequestedReviewersItem>,
	pub requested_teams:     Vec<Team>,
	pub review_comment_url:  String,
	pub review_comments_url: String,
	pub state:               SimplePullRequestState,
	pub statuses_url:        String,
	pub title:               String,
	pub updated_at:          chrono::DateTime<chrono::offset::Utc>,
	pub url:                 String,
	pub user:                User,
}
impl From<&SimplePullRequest> for SimplePullRequest {
	fn from(value: &SimplePullRequest) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestActiveLockReason {
	#[serde(rename = "resolved")]
	Resolved,
	#[serde(rename = "off-topic")]
	OffTopic,
	#[serde(rename = "too heated")]
	TooHeated,
	#[serde(rename = "spam")]
	Spam,
}
impl From<&SimplePullRequestActiveLockReason> for SimplePullRequestActiveLockReason {
	fn from(value: &SimplePullRequestActiveLockReason) -> Self {
		value.clone()
	}
}
impl ToString for SimplePullRequestActiveLockReason {
	fn to_string(&self) -> String {
		match *self {
			Self::Resolved => "resolved".to_string(),
			Self::OffTopic => "off-topic".to_string(),
			Self::TooHeated => "too heated".to_string(),
			Self::Spam => "spam".to_string(),
		}
	}
}
impl std::str::FromStr for SimplePullRequestActiveLockReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"resolved" => Ok(Self::Resolved),
			"off-topic" => Ok(Self::OffTopic),
			"too heated" => Ok(Self::TooHeated),
			"spam" => Ok(Self::Spam),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SimplePullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SimplePullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SimplePullRequestActiveLockReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestBase {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&SimplePullRequestBase> for SimplePullRequestBase {
	fn from(value: &SimplePullRequestBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestHead {
	pub label: String,
	#[serde(rename = "ref")]
	pub ref_:  String,
	pub repo:  Repository,
	pub sha:   String,
	pub user:  User,
}
impl From<&SimplePullRequestHead> for SimplePullRequestHead {
	fn from(value: &SimplePullRequestHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SimplePullRequestLinks {
	pub comments:        Link,
	pub commits:         Link,
	pub html:            Link,
	pub issue:           Link,
	pub review_comment:  Link,
	pub review_comments: Link,
	#[serde(rename = "self")]
	pub self_:           Link,
	pub statuses:        Link,
}
impl From<&SimplePullRequestLinks> for SimplePullRequestLinks {
	fn from(value: &SimplePullRequestLinks) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SimplePullRequestRequestedReviewersItem {
	User(User),
	Team(Team),
}
impl From<&SimplePullRequestRequestedReviewersItem> for SimplePullRequestRequestedReviewersItem {
	fn from(value: &SimplePullRequestRequestedReviewersItem) -> Self {
		value.clone()
	}
}
impl From<User> for SimplePullRequestRequestedReviewersItem {
	fn from(value: User) -> Self {
		Self::User(value)
	}
}
impl From<Team> for SimplePullRequestRequestedReviewersItem {
	fn from(value: Team) -> Self {
		Self::Team(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SimplePullRequestState {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
}
impl From<&SimplePullRequestState> for SimplePullRequestState {
	fn from(value: &SimplePullRequestState) -> Self {
		value.clone()
	}
}
impl ToString for SimplePullRequestState {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
		}
	}
}
impl std::str::FromStr for SimplePullRequestState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SimplePullRequestState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SimplePullRequestState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SimplePullRequestState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelled {
	pub action:      SponsorshipCancelledAction,
	pub sender:      User,
	pub sponsorship: SponsorshipCancelledSponsorship,
}
impl From<&SponsorshipCancelled> for SponsorshipCancelled {
	fn from(value: &SponsorshipCancelled) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCancelledAction {
	#[serde(rename = "cancelled")]
	Cancelled,
}
impl From<&SponsorshipCancelledAction> for SponsorshipCancelledAction {
	fn from(value: &SponsorshipCancelledAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipCancelledAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Cancelled => "cancelled".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipCancelledAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"cancelled" => Ok(Self::Cancelled),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipCancelledAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipCancelledAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipCancelledAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCancelledSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipCancelledSponsorship> for SponsorshipCancelledSponsorship {
	fn from(value: &SponsorshipCancelledSponsorship) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreated {
	pub action:      SponsorshipCreatedAction,
	pub sender:      User,
	pub sponsorship: SponsorshipCreatedSponsorship,
}
impl From<&SponsorshipCreated> for SponsorshipCreated {
	fn from(value: &SponsorshipCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&SponsorshipCreatedAction> for SponsorshipCreatedAction {
	fn from(value: &SponsorshipCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipCreatedSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipCreatedSponsorship> for SponsorshipCreatedSponsorship {
	fn from(value: &SponsorshipCreatedSponsorship) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEdited {
	pub action:      SponsorshipEditedAction,
	pub changes:     SponsorshipEditedChanges,
	pub sender:      User,
	pub sponsorship: SponsorshipEditedSponsorship,
}
impl From<&SponsorshipEdited> for SponsorshipEdited {
	fn from(value: &SponsorshipEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&SponsorshipEditedAction> for SponsorshipEditedAction {
	fn from(value: &SponsorshipEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub privacy_level: Option<SponsorshipEditedChangesPrivacyLevel>,
}
impl From<&SponsorshipEditedChanges> for SponsorshipEditedChanges {
	fn from(value: &SponsorshipEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedChangesPrivacyLevel {
	/// The `edited` event types include the details about the change when
	/// someone edits a sponsorship to change the privacy.
	pub from: String,
}
impl From<&SponsorshipEditedChangesPrivacyLevel> for SponsorshipEditedChangesPrivacyLevel {
	fn from(value: &SponsorshipEditedChangesPrivacyLevel) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipEditedSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipEditedSponsorship> for SponsorshipEditedSponsorship {
	fn from(value: &SponsorshipEditedSponsorship) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SponsorshipEvent {
	Cancelled(SponsorshipCancelled),
	Created(SponsorshipCreated),
	Edited(SponsorshipEdited),
	PendingCancellation(SponsorshipPendingCancellation),
	PendingTierChange(SponsorshipPendingTierChange),
	TierChanged(SponsorshipTierChanged),
}
impl From<&SponsorshipEvent> for SponsorshipEvent {
	fn from(value: &SponsorshipEvent) -> Self {
		value.clone()
	}
}
impl From<SponsorshipCancelled> for SponsorshipEvent {
	fn from(value: SponsorshipCancelled) -> Self {
		Self::Cancelled(value)
	}
}
impl From<SponsorshipCreated> for SponsorshipEvent {
	fn from(value: SponsorshipCreated) -> Self {
		Self::Created(value)
	}
}
impl From<SponsorshipEdited> for SponsorshipEvent {
	fn from(value: SponsorshipEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<SponsorshipPendingCancellation> for SponsorshipEvent {
	fn from(value: SponsorshipPendingCancellation) -> Self {
		Self::PendingCancellation(value)
	}
}
impl From<SponsorshipPendingTierChange> for SponsorshipEvent {
	fn from(value: SponsorshipPendingTierChange) -> Self {
		Self::PendingTierChange(value)
	}
}
impl From<SponsorshipTierChanged> for SponsorshipEvent {
	fn from(value: SponsorshipTierChanged) -> Self {
		Self::TierChanged(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellation {
	pub action:         SponsorshipPendingCancellationAction,
	/// The `pending_cancellation` and `pending_tier_change` event types will
	/// include the date the cancellation or tier change will take effect.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub effective_date: Option<String>,
	pub sender:         User,
	pub sponsorship:    SponsorshipPendingCancellationSponsorship,
}
impl From<&SponsorshipPendingCancellation> for SponsorshipPendingCancellation {
	fn from(value: &SponsorshipPendingCancellation) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingCancellationAction {
	#[serde(rename = "pending_cancellation")]
	PendingCancellation,
}
impl From<&SponsorshipPendingCancellationAction> for SponsorshipPendingCancellationAction {
	fn from(value: &SponsorshipPendingCancellationAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipPendingCancellationAction {
	fn to_string(&self) -> String {
		match *self {
			Self::PendingCancellation => "pending_cancellation".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipPendingCancellationAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pending_cancellation" => Ok(Self::PendingCancellation),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipPendingCancellationAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipPendingCancellationAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipPendingCancellationAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingCancellationSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipPendingCancellationSponsorship>
	for SponsorshipPendingCancellationSponsorship
{
	fn from(value: &SponsorshipPendingCancellationSponsorship) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChange {
	pub action:         SponsorshipPendingTierChangeAction,
	pub changes:        SponsorshipPendingTierChangeChanges,
	/// The `pending_cancellation` and `pending_tier_change` event types will
	/// include the date the cancellation or tier change will take effect.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub effective_date: Option<String>,
	pub sender:         User,
	pub sponsorship:    SponsorshipPendingTierChangeSponsorship,
}
impl From<&SponsorshipPendingTierChange> for SponsorshipPendingTierChange {
	fn from(value: &SponsorshipPendingTierChange) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipPendingTierChangeAction {
	#[serde(rename = "pending_tier_change")]
	PendingTierChange,
}
impl From<&SponsorshipPendingTierChangeAction> for SponsorshipPendingTierChangeAction {
	fn from(value: &SponsorshipPendingTierChangeAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipPendingTierChangeAction {
	fn to_string(&self) -> String {
		match *self {
			Self::PendingTierChange => "pending_tier_change".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipPendingTierChangeAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pending_tier_change" => Ok(Self::PendingTierChange),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipPendingTierChangeAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipPendingTierChangeAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipPendingTierChangeAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChanges {
	pub tier: SponsorshipPendingTierChangeChangesTier,
}
impl From<&SponsorshipPendingTierChangeChanges> for SponsorshipPendingTierChangeChanges {
	fn from(value: &SponsorshipPendingTierChangeChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeChangesTier {
	pub from: SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeChangesTier> for SponsorshipPendingTierChangeChangesTier {
	fn from(value: &SponsorshipPendingTierChangeChangesTier) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipPendingTierChangeSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipPendingTierChangeSponsorship> for SponsorshipPendingTierChangeSponsorship {
	fn from(value: &SponsorshipPendingTierChangeSponsorship) -> Self {
		value.clone()
	}
}
/// The `tier_changed` and `pending_tier_change` will include the original tier
/// before the change or pending change. For more information, see the pending
/// tier change payload.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTier {
	pub created_at:               chrono::DateTime<chrono::offset::Utc>,
	pub description:              String,
	pub is_custom_ammount:        bool,
	pub is_one_time:              bool,
	pub monthly_price_in_cents:   i64,
	pub monthly_price_in_dollars: i64,
	pub name:                     String,
	pub node_id:                  String,
}
impl From<&SponsorshipTier> for SponsorshipTier {
	fn from(value: &SponsorshipTier) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChanged {
	pub action:      SponsorshipTierChangedAction,
	pub changes:     SponsorshipTierChangedChanges,
	pub sender:      User,
	pub sponsorship: SponsorshipTierChangedSponsorship,
}
impl From<&SponsorshipTierChanged> for SponsorshipTierChanged {
	fn from(value: &SponsorshipTierChanged) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SponsorshipTierChangedAction {
	#[serde(rename = "tier_changed")]
	TierChanged,
}
impl From<&SponsorshipTierChangedAction> for SponsorshipTierChangedAction {
	fn from(value: &SponsorshipTierChangedAction) -> Self {
		value.clone()
	}
}
impl ToString for SponsorshipTierChangedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::TierChanged => "tier_changed".to_string(),
		}
	}
}
impl std::str::FromStr for SponsorshipTierChangedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"tier_changed" => Ok(Self::TierChanged),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for SponsorshipTierChangedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for SponsorshipTierChangedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for SponsorshipTierChangedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChanges {
	pub tier: SponsorshipTierChangedChangesTier,
}
impl From<&SponsorshipTierChangedChanges> for SponsorshipTierChangedChanges {
	fn from(value: &SponsorshipTierChangedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedChangesTier {
	pub from: SponsorshipTier,
}
impl From<&SponsorshipTierChangedChangesTier> for SponsorshipTierChangedChangesTier {
	fn from(value: &SponsorshipTierChangedChangesTier) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SponsorshipTierChangedSponsorship {
	pub created_at:    chrono::DateTime<chrono::offset::Utc>,
	pub node_id:       String,
	pub privacy_level: String,
	pub sponsor:       User,
	pub sponsorable:   User,
	pub tier:          SponsorshipTier,
}
impl From<&SponsorshipTierChangedSponsorship> for SponsorshipTierChangedSponsorship {
	fn from(value: &SponsorshipTierChangedSponsorship) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarCreated {
	pub action:       StarCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	/// The time the star was created. This is a timestamp in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
	pub starred_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&StarCreated> for StarCreated {
	fn from(value: &StarCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&StarCreatedAction> for StarCreatedAction {
	fn from(value: &StarCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for StarCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for StarCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for StarCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for StarCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for StarCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StarDeleted {
	pub action:       StarDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	/// The time the star was created. This is a timestamp in ISO 8601 format:
	/// `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
	pub starred_at:   (),
}
impl From<&StarDeleted> for StarDeleted {
	fn from(value: &StarDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StarDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&StarDeletedAction> for StarDeletedAction {
	fn from(value: &StarDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for StarDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for StarDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for StarDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for StarDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for StarDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StarEvent {
	Created(StarCreated),
	Deleted(StarDeleted),
}
impl From<&StarEvent> for StarEvent {
	fn from(value: &StarEvent) -> Self {
		value.clone()
	}
}
impl From<StarCreated> for StarEvent {
	fn from(value: StarCreated) -> Self {
		Self::Created(value)
	}
}
impl From<StarDeleted> for StarEvent {
	fn from(value: StarDeleted) -> Self {
		Self::Deleted(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub avatar_url:   Option<String>,
	/// An array of branch objects containing the status' SHA. Each branch
	/// contains the given SHA, but the SHA may or may not be the head of the
	/// branch. The array includes a maximum of 10 branches.
	pub branches:     Vec<StatusEventBranchesItem>,
	pub commit:       StatusEventCommit,
	pub context:      String,
	pub created_at:   chrono::DateTime<chrono::offset::Utc>,
	/// The optional human-readable description added to the status.
	pub description:  Option<String>,
	/// The unique identifier of the status.
	pub id:           i64,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub name:         String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	/// The Commit SHA.
	pub sha:          String,
	/// The new state. Can be `pending`, `success`, `failure`, or `error`.
	pub state:        StatusEventState,
	/// The optional link added to the status.
	pub target_url:   Option<String>,
	pub updated_at:   chrono::DateTime<chrono::offset::Utc>,
}
impl From<&StatusEvent> for StatusEvent {
	fn from(value: &StatusEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItem {
	pub commit:    StatusEventBranchesItemCommit,
	pub name:      String,
	pub protected: bool,
}
impl From<&StatusEventBranchesItem> for StatusEventBranchesItem {
	fn from(value: &StatusEventBranchesItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventBranchesItemCommit {
	pub sha: String,
	pub url: String,
}
impl From<&StatusEventBranchesItemCommit> for StatusEventBranchesItemCommit {
	fn from(value: &StatusEventBranchesItemCommit) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommit {
	pub author:       Option<User>,
	pub comments_url: String,
	pub commit:       StatusEventCommitCommit,
	pub committer:    Option<User>,
	pub html_url:     String,
	pub node_id:      String,
	pub parents:      Vec<StatusEventCommitParentsItem>,
	pub sha:          String,
	pub url:          String,
}
impl From<&StatusEventCommit> for StatusEventCommit {
	fn from(value: &StatusEventCommit) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommit {
	pub author:        Committer,
	pub comment_count: i64,
	pub committer:     Committer,
	pub message:       String,
	pub tree:          StatusEventCommitCommitTree,
	pub url:           String,
	pub verification:  StatusEventCommitCommitVerification,
}
impl From<&StatusEventCommitCommit> for StatusEventCommitCommit {
	fn from(value: &StatusEventCommitCommit) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitTree {
	pub sha: String,
	pub url: String,
}
impl From<&StatusEventCommitCommitTree> for StatusEventCommitCommitTree {
	fn from(value: &StatusEventCommitCommitTree) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitCommitVerification {
	pub payload:   Option<String>,
	pub reason:    StatusEventCommitCommitVerificationReason,
	pub signature: Option<String>,
	pub verified:  bool,
}
impl From<&StatusEventCommitCommitVerification> for StatusEventCommitCommitVerification {
	fn from(value: &StatusEventCommitCommitVerification) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventCommitCommitVerificationReason {
	#[serde(rename = "expired_key")]
	ExpiredKey,
	#[serde(rename = "not_signing_key")]
	NotSigningKey,
	#[serde(rename = "gpgverify_error")]
	GpgverifyError,
	#[serde(rename = "gpgverify_unavailable")]
	GpgverifyUnavailable,
	#[serde(rename = "unsigned")]
	Unsigned,
	#[serde(rename = "unknown_signature_type")]
	UnknownSignatureType,
	#[serde(rename = "no_user")]
	NoUser,
	#[serde(rename = "unverified_email")]
	UnverifiedEmail,
	#[serde(rename = "bad_email")]
	BadEmail,
	#[serde(rename = "unknown_key")]
	UnknownKey,
	#[serde(rename = "malformed_signature")]
	MalformedSignature,
	#[serde(rename = "invalid")]
	Invalid,
	#[serde(rename = "valid")]
	Valid,
}
impl From<&StatusEventCommitCommitVerificationReason>
	for StatusEventCommitCommitVerificationReason
{
	fn from(value: &StatusEventCommitCommitVerificationReason) -> Self {
		value.clone()
	}
}
impl ToString for StatusEventCommitCommitVerificationReason {
	fn to_string(&self) -> String {
		match *self {
			Self::ExpiredKey => "expired_key".to_string(),
			Self::NotSigningKey => "not_signing_key".to_string(),
			Self::GpgverifyError => "gpgverify_error".to_string(),
			Self::GpgverifyUnavailable => "gpgverify_unavailable".to_string(),
			Self::Unsigned => "unsigned".to_string(),
			Self::UnknownSignatureType => "unknown_signature_type".to_string(),
			Self::NoUser => "no_user".to_string(),
			Self::UnverifiedEmail => "unverified_email".to_string(),
			Self::BadEmail => "bad_email".to_string(),
			Self::UnknownKey => "unknown_key".to_string(),
			Self::MalformedSignature => "malformed_signature".to_string(),
			Self::Invalid => "invalid".to_string(),
			Self::Valid => "valid".to_string(),
		}
	}
}
impl std::str::FromStr for StatusEventCommitCommitVerificationReason {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"expired_key" => Ok(Self::ExpiredKey),
			"not_signing_key" => Ok(Self::NotSigningKey),
			"gpgverify_error" => Ok(Self::GpgverifyError),
			"gpgverify_unavailable" => Ok(Self::GpgverifyUnavailable),
			"unsigned" => Ok(Self::Unsigned),
			"unknown_signature_type" => Ok(Self::UnknownSignatureType),
			"no_user" => Ok(Self::NoUser),
			"unverified_email" => Ok(Self::UnverifiedEmail),
			"bad_email" => Ok(Self::BadEmail),
			"unknown_key" => Ok(Self::UnknownKey),
			"malformed_signature" => Ok(Self::MalformedSignature),
			"invalid" => Ok(Self::Invalid),
			"valid" => Ok(Self::Valid),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for StatusEventCommitCommitVerificationReason {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for StatusEventCommitCommitVerificationReason {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for StatusEventCommitCommitVerificationReason {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StatusEventCommitParentsItem {
	pub html_url: String,
	pub sha:      String,
	pub url:      String,
}
impl From<&StatusEventCommitParentsItem> for StatusEventCommitParentsItem {
	fn from(value: &StatusEventCommitParentsItem) -> Self {
		value.clone()
	}
}
/// The new state. Can be `pending`, `success`, `failure`, or `error`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StatusEventState {
	#[serde(rename = "pending")]
	Pending,
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "error")]
	Error,
}
impl From<&StatusEventState> for StatusEventState {
	fn from(value: &StatusEventState) -> Self {
		value.clone()
	}
}
impl ToString for StatusEventState {
	fn to_string(&self) -> String {
		match *self {
			Self::Pending => "pending".to_string(),
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Error => "error".to_string(),
		}
	}
}
impl std::str::FromStr for StatusEventState {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"pending" => Ok(Self::Pending),
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"error" => Ok(Self::Error),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for StatusEventState {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for StatusEventState {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for StatusEventState {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// Groups of organization members that gives permissions on specified
/// repositories.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Team {
	/// Description of the team
	pub description:      Option<String>,
	pub html_url:         String,
	/// Unique identifier of the team
	pub id:               i64,
	pub members_url:      String,
	/// Name of the team
	pub name:             String,
	pub node_id:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub parent:           Option<TeamParent>,
	/// Permission that the team will have for its repositories
	pub permission:       String,
	pub privacy:          TeamPrivacy,
	pub repositories_url: String,
	pub slug:             String,
	/// URL for the team
	pub url:              String,
}
impl From<&Team> for Team {
	fn from(value: &Team) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddEvent {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	pub repository:   Repository,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamAddEvent> for TeamAddEvent {
	fn from(value: &TeamAddEvent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamAddedToRepository {
	pub action:       TeamAddedToRepositoryAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamAddedToRepository> for TeamAddedToRepository {
	fn from(value: &TeamAddedToRepository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamAddedToRepositoryAction {
	#[serde(rename = "added_to_repository")]
	AddedToRepository,
}
impl From<&TeamAddedToRepositoryAction> for TeamAddedToRepositoryAction {
	fn from(value: &TeamAddedToRepositoryAction) -> Self {
		value.clone()
	}
}
impl ToString for TeamAddedToRepositoryAction {
	fn to_string(&self) -> String {
		match *self {
			Self::AddedToRepository => "added_to_repository".to_string(),
		}
	}
}
impl std::str::FromStr for TeamAddedToRepositoryAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"added_to_repository" => Ok(Self::AddedToRepository),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamAddedToRepositoryAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamAddedToRepositoryAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamAddedToRepositoryAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamCreated {
	pub action:       TeamCreatedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamCreated> for TeamCreated {
	fn from(value: &TeamCreated) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamCreatedAction {
	#[serde(rename = "created")]
	Created,
}
impl From<&TeamCreatedAction> for TeamCreatedAction {
	fn from(value: &TeamCreatedAction) -> Self {
		value.clone()
	}
}
impl ToString for TeamCreatedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Created => "created".to_string(),
		}
	}
}
impl std::str::FromStr for TeamCreatedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"created" => Ok(Self::Created),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamCreatedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamCreatedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamCreatedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamDeleted {
	pub action:       TeamDeletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamDeleted> for TeamDeleted {
	fn from(value: &TeamDeleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamDeletedAction {
	#[serde(rename = "deleted")]
	Deleted,
}
impl From<&TeamDeletedAction> for TeamDeletedAction {
	fn from(value: &TeamDeletedAction) -> Self {
		value.clone()
	}
}
impl ToString for TeamDeletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Deleted => "deleted".to_string(),
		}
	}
}
impl std::str::FromStr for TeamDeletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"deleted" => Ok(Self::Deleted),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamDeletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamDeletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamDeletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEdited {
	pub action:       TeamEditedAction,
	pub changes:      TeamEditedChanges,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamEdited> for TeamEdited {
	fn from(value: &TeamEdited) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamEditedAction {
	#[serde(rename = "edited")]
	Edited,
}
impl From<&TeamEditedAction> for TeamEditedAction {
	fn from(value: &TeamEditedAction) -> Self {
		value.clone()
	}
}
impl ToString for TeamEditedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Edited => "edited".to_string(),
		}
	}
}
impl std::str::FromStr for TeamEditedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"edited" => Ok(Self::Edited),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamEditedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamEditedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamEditedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The changes to the team if the action was `edited`.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChanges {
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub description: Option<TeamEditedChangesDescription>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:        Option<TeamEditedChangesName>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub privacy:     Option<TeamEditedChangesPrivacy>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:  Option<TeamEditedChangesRepository>,
}
impl From<&TeamEditedChanges> for TeamEditedChanges {
	fn from(value: &TeamEditedChanges) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesDescription {
	/// The previous version of the description if the action was `edited`.
	pub from: String,
}
impl From<&TeamEditedChangesDescription> for TeamEditedChangesDescription {
	fn from(value: &TeamEditedChangesDescription) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesName {
	/// The previous version of the name if the action was `edited`.
	pub from: String,
}
impl From<&TeamEditedChangesName> for TeamEditedChangesName {
	fn from(value: &TeamEditedChangesName) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesPrivacy {
	/// The previous version of the team's privacy if the action was `edited`.
	pub from: String,
}
impl From<&TeamEditedChangesPrivacy> for TeamEditedChangesPrivacy {
	fn from(value: &TeamEditedChangesPrivacy) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepository {
	pub permissions: TeamEditedChangesRepositoryPermissions,
}
impl From<&TeamEditedChangesRepository> for TeamEditedChangesRepository {
	fn from(value: &TeamEditedChangesRepository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissions {
	pub from: TeamEditedChangesRepositoryPermissionsFrom,
}
impl From<&TeamEditedChangesRepositoryPermissions> for TeamEditedChangesRepositoryPermissions {
	fn from(value: &TeamEditedChangesRepositoryPermissions) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamEditedChangesRepositoryPermissionsFrom {
	/// The previous version of the team member's `admin` permission on a
	/// repository, if the action was `edited`.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub admin: Option<bool>,
	/// The previous version of the team member's `pull` permission on a
	/// repository, if the action was `edited`.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub pull:  Option<bool>,
	/// The previous version of the team member's `push` permission on a
	/// repository, if the action was `edited`.
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub push:  Option<bool>,
}
impl From<&TeamEditedChangesRepositoryPermissionsFrom>
	for TeamEditedChangesRepositoryPermissionsFrom
{
	fn from(value: &TeamEditedChangesRepositoryPermissionsFrom) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TeamEvent {
	AddedToRepository(TeamAddedToRepository),
	Created(TeamCreated),
	Deleted(TeamDeleted),
	Edited(TeamEdited),
	RemovedFromRepository(TeamRemovedFromRepository),
}
impl From<&TeamEvent> for TeamEvent {
	fn from(value: &TeamEvent) -> Self {
		value.clone()
	}
}
impl From<TeamAddedToRepository> for TeamEvent {
	fn from(value: TeamAddedToRepository) -> Self {
		Self::AddedToRepository(value)
	}
}
impl From<TeamCreated> for TeamEvent {
	fn from(value: TeamCreated) -> Self {
		Self::Created(value)
	}
}
impl From<TeamDeleted> for TeamEvent {
	fn from(value: TeamDeleted) -> Self {
		Self::Deleted(value)
	}
}
impl From<TeamEdited> for TeamEvent {
	fn from(value: TeamEdited) -> Self {
		Self::Edited(value)
	}
}
impl From<TeamRemovedFromRepository> for TeamEvent {
	fn from(value: TeamRemovedFromRepository) -> Self {
		Self::RemovedFromRepository(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamParent {
	/// Description of the team
	pub description:      Option<String>,
	pub html_url:         String,
	/// Unique identifier of the team
	pub id:               i64,
	pub members_url:      String,
	/// Name of the team
	pub name:             String,
	pub node_id:          String,
	/// Permission that the team will have for its repositories
	pub permission:       String,
	pub privacy:          TeamParentPrivacy,
	pub repositories_url: String,
	pub slug:             String,
	/// URL for the team
	pub url:              String,
}
impl From<&TeamParent> for TeamParent {
	fn from(value: &TeamParent) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamParentPrivacy {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
	#[serde(rename = "secret")]
	Secret,
}
impl From<&TeamParentPrivacy> for TeamParentPrivacy {
	fn from(value: &TeamParentPrivacy) -> Self {
		value.clone()
	}
}
impl ToString for TeamParentPrivacy {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
			Self::Secret => "secret".to_string(),
		}
	}
}
impl std::str::FromStr for TeamParentPrivacy {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			"secret" => Ok(Self::Secret),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamParentPrivacy {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamParentPrivacy {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamParentPrivacy {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamPrivacy {
	#[serde(rename = "open")]
	Open,
	#[serde(rename = "closed")]
	Closed,
	#[serde(rename = "secret")]
	Secret,
}
impl From<&TeamPrivacy> for TeamPrivacy {
	fn from(value: &TeamPrivacy) -> Self {
		value.clone()
	}
}
impl ToString for TeamPrivacy {
	fn to_string(&self) -> String {
		match *self {
			Self::Open => "open".to_string(),
			Self::Closed => "closed".to_string(),
			Self::Secret => "secret".to_string(),
		}
	}
}
impl std::str::FromStr for TeamPrivacy {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"open" => Ok(Self::Open),
			"closed" => Ok(Self::Closed),
			"secret" => Ok(Self::Secret),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamPrivacy {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamPrivacy {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamPrivacy {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TeamRemovedFromRepository {
	pub action:       TeamRemovedFromRepositoryAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	pub organization: Organization,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub repository:   Option<Repository>,
	pub sender:       User,
	pub team:         Team,
}
impl From<&TeamRemovedFromRepository> for TeamRemovedFromRepository {
	fn from(value: &TeamRemovedFromRepository) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TeamRemovedFromRepositoryAction {
	#[serde(rename = "removed_from_repository")]
	RemovedFromRepository,
}
impl From<&TeamRemovedFromRepositoryAction> for TeamRemovedFromRepositoryAction {
	fn from(value: &TeamRemovedFromRepositoryAction) -> Self {
		value.clone()
	}
}
impl ToString for TeamRemovedFromRepositoryAction {
	fn to_string(&self) -> String {
		match *self {
			Self::RemovedFromRepository => "removed_from_repository".to_string(),
		}
	}
}
impl std::str::FromStr for TeamRemovedFromRepositoryAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"removed_from_repository" => Ok(Self::RemovedFromRepository),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for TeamRemovedFromRepositoryAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for TeamRemovedFromRepositoryAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for TeamRemovedFromRepositoryAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct User {
	pub avatar_url:          String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub email:               Option<String>,
	pub events_url:          String,
	pub followers_url:       String,
	pub following_url:       String,
	pub gists_url:           String,
	pub gravatar_id:         String,
	pub html_url:            String,
	pub id:                  i64,
	pub login:               String,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub name:                Option<String>,
	pub node_id:             String,
	pub organizations_url:   String,
	pub received_events_url: String,
	pub repos_url:           String,
	pub site_admin:          bool,
	pub starred_url:         String,
	pub subscriptions_url:   String,
	#[serde(rename = "type")]
	pub type_:               UserType,
	pub url:                 String,
}
impl From<&User> for User {
	fn from(value: &User) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum UserType {
	Bot,
	User,
	Organization,
}
impl From<&UserType> for UserType {
	fn from(value: &UserType) -> Self {
		value.clone()
	}
}
impl ToString for UserType {
	fn to_string(&self) -> String {
		match *self {
			Self::Bot => "Bot".to_string(),
			Self::User => "User".to_string(),
			Self::Organization => "Organization".to_string(),
		}
	}
}
impl std::str::FromStr for UserType {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"Bot" => Ok(Self::Bot),
			"User" => Ok(Self::User),
			"Organization" => Ok(Self::Organization),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for UserType {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for UserType {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for UserType {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct WatchEvent(pub WatchStarted);
impl std::ops::Deref for WatchEvent {
	type Target = WatchStarted;

	fn deref(&self) -> &WatchStarted {
		&self.0
	}
}
impl From<WatchEvent> for WatchStarted {
	fn from(value: WatchEvent) -> Self {
		value.0
	}
}
impl From<&WatchEvent> for WatchEvent {
	fn from(value: &WatchEvent) -> Self {
		value.clone()
	}
}
impl From<WatchStarted> for WatchEvent {
	fn from(value: WatchStarted) -> Self {
		Self(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WatchStarted {
	pub action:       WatchStartedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
}
impl From<&WatchStarted> for WatchStarted {
	fn from(value: &WatchStarted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WatchStartedAction {
	#[serde(rename = "started")]
	Started,
}
impl From<&WatchStartedAction> for WatchStartedAction {
	fn from(value: &WatchStartedAction) -> Self {
		value.clone()
	}
}
impl ToString for WatchStartedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Started => "started".to_string(),
		}
	}
}
impl std::str::FromStr for WatchStartedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"started" => Ok(Self::Started),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WatchStartedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WatchStartedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WatchStartedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WebhookEvents {
	Variant0(Vec<WebhookEventsVariant0Item>),
	Variant1(Vec<String>),
}
impl From<&WebhookEvents> for WebhookEvents {
	fn from(value: &WebhookEvents) -> Self {
		value.clone()
	}
}
impl From<Vec<WebhookEventsVariant0Item>> for WebhookEvents {
	fn from(value: Vec<WebhookEventsVariant0Item>) -> Self {
		Self::Variant0(value)
	}
}
impl From<Vec<String>> for WebhookEvents {
	fn from(value: Vec<String>) -> Self {
		Self::Variant1(value)
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WebhookEventsVariant0Item {
	#[serde(rename = "branch_protection_rule")]
	BranchProtectionRule,
	#[serde(rename = "check_run")]
	CheckRun,
	#[serde(rename = "check_suite")]
	CheckSuite,
	#[serde(rename = "code_scanning_alert")]
	CodeScanningAlert,
	#[serde(rename = "commit_comment")]
	CommitComment,
	#[serde(rename = "create")]
	Create,
	#[serde(rename = "delete")]
	Delete,
	#[serde(rename = "deployment")]
	Deployment,
	#[serde(rename = "deployment_status")]
	DeploymentStatus,
	#[serde(rename = "deploy_key")]
	DeployKey,
	#[serde(rename = "discussion")]
	Discussion,
	#[serde(rename = "discussion_comment")]
	DiscussionComment,
	#[serde(rename = "fork")]
	Fork,
	#[serde(rename = "gollum")]
	Gollum,
	#[serde(rename = "issues")]
	Issues,
	#[serde(rename = "issue_comment")]
	IssueComment,
	#[serde(rename = "label")]
	Label,
	#[serde(rename = "member")]
	Member,
	#[serde(rename = "membership")]
	Membership,
	#[serde(rename = "meta")]
	Meta,
	#[serde(rename = "milestone")]
	Milestone,
	#[serde(rename = "organization")]
	Organization,
	#[serde(rename = "org_block")]
	OrgBlock,
	#[serde(rename = "package")]
	Package,
	#[serde(rename = "page_build")]
	PageBuild,
	#[serde(rename = "project")]
	Project,
	#[serde(rename = "projects_v2_item")]
	ProjectsV2Item,
	#[serde(rename = "project_card")]
	ProjectCard,
	#[serde(rename = "project_column")]
	ProjectColumn,
	#[serde(rename = "public")]
	Public,
	#[serde(rename = "pull_request")]
	PullRequest,
	#[serde(rename = "pull_request_review")]
	PullRequestReview,
	#[serde(rename = "pull_request_review_comment")]
	PullRequestReviewComment,
	#[serde(rename = "pull_request_review_thread")]
	PullRequestReviewThread,
	#[serde(rename = "push")]
	Push,
	#[serde(rename = "registry_package")]
	RegistryPackage,
	#[serde(rename = "release")]
	Release,
	#[serde(rename = "repository")]
	Repository,
	#[serde(rename = "repository_import")]
	RepositoryImport,
	#[serde(rename = "repository_vulnerability_alert")]
	RepositoryVulnerabilityAlert,
	#[serde(rename = "secret_scanning_alert")]
	SecretScanningAlert,
	#[serde(rename = "secret_scanning_alert_location")]
	SecretScanningAlertLocation,
	#[serde(rename = "security_and_analysis")]
	SecurityAndAnalysis,
	#[serde(rename = "star")]
	Star,
	#[serde(rename = "status")]
	Status,
	#[serde(rename = "team")]
	Team,
	#[serde(rename = "team_add")]
	TeamAdd,
	#[serde(rename = "watch")]
	Watch,
	#[serde(rename = "workflow_job")]
	WorkflowJob,
	#[serde(rename = "workflow_run")]
	WorkflowRun,
}
impl From<&WebhookEventsVariant0Item> for WebhookEventsVariant0Item {
	fn from(value: &WebhookEventsVariant0Item) -> Self {
		value.clone()
	}
}
impl ToString for WebhookEventsVariant0Item {
	fn to_string(&self) -> String {
		match *self {
			Self::BranchProtectionRule => "branch_protection_rule".to_string(),
			Self::CheckRun => "check_run".to_string(),
			Self::CheckSuite => "check_suite".to_string(),
			Self::CodeScanningAlert => "code_scanning_alert".to_string(),
			Self::CommitComment => "commit_comment".to_string(),
			Self::Create => "create".to_string(),
			Self::Delete => "delete".to_string(),
			Self::Deployment => "deployment".to_string(),
			Self::DeploymentStatus => "deployment_status".to_string(),
			Self::DeployKey => "deploy_key".to_string(),
			Self::Discussion => "discussion".to_string(),
			Self::DiscussionComment => "discussion_comment".to_string(),
			Self::Fork => "fork".to_string(),
			Self::Gollum => "gollum".to_string(),
			Self::Issues => "issues".to_string(),
			Self::IssueComment => "issue_comment".to_string(),
			Self::Label => "label".to_string(),
			Self::Member => "member".to_string(),
			Self::Membership => "membership".to_string(),
			Self::Meta => "meta".to_string(),
			Self::Milestone => "milestone".to_string(),
			Self::Organization => "organization".to_string(),
			Self::OrgBlock => "org_block".to_string(),
			Self::Package => "package".to_string(),
			Self::PageBuild => "page_build".to_string(),
			Self::Project => "project".to_string(),
			Self::ProjectsV2Item => "projects_v2_item".to_string(),
			Self::ProjectCard => "project_card".to_string(),
			Self::ProjectColumn => "project_column".to_string(),
			Self::Public => "public".to_string(),
			Self::PullRequest => "pull_request".to_string(),
			Self::PullRequestReview => "pull_request_review".to_string(),
			Self::PullRequestReviewComment => "pull_request_review_comment".to_string(),
			Self::PullRequestReviewThread => "pull_request_review_thread".to_string(),
			Self::Push => "push".to_string(),
			Self::RegistryPackage => "registry_package".to_string(),
			Self::Release => "release".to_string(),
			Self::Repository => "repository".to_string(),
			Self::RepositoryImport => "repository_import".to_string(),
			Self::RepositoryVulnerabilityAlert => "repository_vulnerability_alert".to_string(),
			Self::SecretScanningAlert => "secret_scanning_alert".to_string(),
			Self::SecretScanningAlertLocation => "secret_scanning_alert_location".to_string(),
			Self::SecurityAndAnalysis => "security_and_analysis".to_string(),
			Self::Star => "star".to_string(),
			Self::Status => "status".to_string(),
			Self::Team => "team".to_string(),
			Self::TeamAdd => "team_add".to_string(),
			Self::Watch => "watch".to_string(),
			Self::WorkflowJob => "workflow_job".to_string(),
			Self::WorkflowRun => "workflow_run".to_string(),
		}
	}
}
impl std::str::FromStr for WebhookEventsVariant0Item {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"branch_protection_rule" => Ok(Self::BranchProtectionRule),
			"check_run" => Ok(Self::CheckRun),
			"check_suite" => Ok(Self::CheckSuite),
			"code_scanning_alert" => Ok(Self::CodeScanningAlert),
			"commit_comment" => Ok(Self::CommitComment),
			"create" => Ok(Self::Create),
			"delete" => Ok(Self::Delete),
			"deployment" => Ok(Self::Deployment),
			"deployment_status" => Ok(Self::DeploymentStatus),
			"deploy_key" => Ok(Self::DeployKey),
			"discussion" => Ok(Self::Discussion),
			"discussion_comment" => Ok(Self::DiscussionComment),
			"fork" => Ok(Self::Fork),
			"gollum" => Ok(Self::Gollum),
			"issues" => Ok(Self::Issues),
			"issue_comment" => Ok(Self::IssueComment),
			"label" => Ok(Self::Label),
			"member" => Ok(Self::Member),
			"membership" => Ok(Self::Membership),
			"meta" => Ok(Self::Meta),
			"milestone" => Ok(Self::Milestone),
			"organization" => Ok(Self::Organization),
			"org_block" => Ok(Self::OrgBlock),
			"package" => Ok(Self::Package),
			"page_build" => Ok(Self::PageBuild),
			"project" => Ok(Self::Project),
			"projects_v2_item" => Ok(Self::ProjectsV2Item),
			"project_card" => Ok(Self::ProjectCard),
			"project_column" => Ok(Self::ProjectColumn),
			"public" => Ok(Self::Public),
			"pull_request" => Ok(Self::PullRequest),
			"pull_request_review" => Ok(Self::PullRequestReview),
			"pull_request_review_comment" => Ok(Self::PullRequestReviewComment),
			"pull_request_review_thread" => Ok(Self::PullRequestReviewThread),
			"push" => Ok(Self::Push),
			"registry_package" => Ok(Self::RegistryPackage),
			"release" => Ok(Self::Release),
			"repository" => Ok(Self::Repository),
			"repository_import" => Ok(Self::RepositoryImport),
			"repository_vulnerability_alert" => Ok(Self::RepositoryVulnerabilityAlert),
			"secret_scanning_alert" => Ok(Self::SecretScanningAlert),
			"secret_scanning_alert_location" => Ok(Self::SecretScanningAlertLocation),
			"security_and_analysis" => Ok(Self::SecurityAndAnalysis),
			"star" => Ok(Self::Star),
			"status" => Ok(Self::Status),
			"team" => Ok(Self::Team),
			"team_add" => Ok(Self::TeamAdd),
			"watch" => Ok(Self::Watch),
			"workflow_job" => Ok(Self::WorkflowJob),
			"workflow_run" => Ok(Self::WorkflowRun),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WebhookEventsVariant0Item {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WebhookEventsVariant0Item {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WebhookEventsVariant0Item {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WebhookPayload {
	BranchProtectionRuleEvent(BranchProtectionRuleEvent),
	CheckRunEvent(CheckRunEvent),
	CheckSuiteEvent(CheckSuiteEvent),
	CodeScanningAlertEvent(CodeScanningAlertEvent),
	CommitCommentEvent(CommitCommentEvent),
	CreateEvent(CreateEvent),
	DeleteEvent(DeleteEvent),
	DependabotAlertEvent(DependabotAlertEvent),
	DeployKeyEvent(DeployKeyEvent),
	DeploymentEvent(DeploymentEvent),
	DeploymentStatusEvent(DeploymentStatusEvent),
	DiscussionEvent(DiscussionEvent),
	DiscussionCommentEvent(DiscussionCommentEvent),
	ForkEvent(ForkEvent),
	GithubAppAuthorizationEvent(GithubAppAuthorizationEvent),
	GollumEvent(GollumEvent),
	InstallationEvent(InstallationEvent),
	InstallationRepositoriesEvent(InstallationRepositoriesEvent),
	InstallationTargetEvent(InstallationTargetEvent),
	IssueCommentEvent(IssueCommentEvent),
	IssuesEvent(IssuesEvent),
	LabelEvent(LabelEvent),
	MarketplacePurchaseEvent(MarketplacePurchaseEvent),
	MemberEvent(MemberEvent),
	MembershipEvent(MembershipEvent),
	MergeGroupEvent(MergeGroupEvent),
	MetaEvent(MetaEvent),
	MilestoneEvent(MilestoneEvent),
	OrgBlockEvent(OrgBlockEvent),
	OrganizationEvent(OrganizationEvent),
	PackageEvent(PackageEvent),
	PageBuildEvent(PageBuildEvent),
	PingEvent(PingEvent),
	ProjectEvent(ProjectEvent),
	ProjectCardEvent(ProjectCardEvent),
	ProjectColumnEvent(ProjectColumnEvent),
	ProjectsV2ItemEvent(ProjectsV2ItemEvent),
	PublicEvent(PublicEvent),
	PullRequestEvent(PullRequestEvent),
	PullRequestReviewEvent(PullRequestReviewEvent),
	PullRequestReviewCommentEvent(PullRequestReviewCommentEvent),
	PullRequestReviewThreadEvent(PullRequestReviewThreadEvent),
	PushEvent(PushEvent),
	RegistryPackageEvent(RegistryPackageEvent),
	ReleaseEvent(ReleaseEvent),
	RepositoryEvent(RepositoryEvent),
	RepositoryDispatchEvent(RepositoryDispatchEvent),
	RepositoryImportEvent(RepositoryImportEvent),
	RepositoryVulnerabilityAlertEvent(RepositoryVulnerabilityAlertEvent),
	SecretScanningAlertEvent(SecretScanningAlertEvent),
	SecurityAdvisoryEvent(SecurityAdvisoryEvent),
	SponsorshipEvent(SponsorshipEvent),
	StarEvent(StarEvent),
	StatusEvent(StatusEvent),
	TeamEvent(TeamEvent),
	TeamAddEvent(TeamAddEvent),
	WatchEvent(WatchEvent),
	WorkflowDispatchEvent(WorkflowDispatchEvent),
	WorkflowJobEvent(WorkflowJobEvent),
	WorkflowRunEvent(WorkflowRunEvent),
}
impl From<&WebhookPayload> for WebhookPayload {
	fn from(value: &WebhookPayload) -> Self {
		value.clone()
	}
}
impl From<BranchProtectionRuleEvent> for WebhookPayload {
	fn from(value: BranchProtectionRuleEvent) -> Self {
		Self::BranchProtectionRuleEvent(value)
	}
}
impl From<CheckRunEvent> for WebhookPayload {
	fn from(value: CheckRunEvent) -> Self {
		Self::CheckRunEvent(value)
	}
}
impl From<CheckSuiteEvent> for WebhookPayload {
	fn from(value: CheckSuiteEvent) -> Self {
		Self::CheckSuiteEvent(value)
	}
}
impl From<CodeScanningAlertEvent> for WebhookPayload {
	fn from(value: CodeScanningAlertEvent) -> Self {
		Self::CodeScanningAlertEvent(value)
	}
}
impl From<CommitCommentEvent> for WebhookPayload {
	fn from(value: CommitCommentEvent) -> Self {
		Self::CommitCommentEvent(value)
	}
}
impl From<CreateEvent> for WebhookPayload {
	fn from(value: CreateEvent) -> Self {
		Self::CreateEvent(value)
	}
}
impl From<DeleteEvent> for WebhookPayload {
	fn from(value: DeleteEvent) -> Self {
		Self::DeleteEvent(value)
	}
}
impl From<DependabotAlertEvent> for WebhookPayload {
	fn from(value: DependabotAlertEvent) -> Self {
		Self::DependabotAlertEvent(value)
	}
}
impl From<DeployKeyEvent> for WebhookPayload {
	fn from(value: DeployKeyEvent) -> Self {
		Self::DeployKeyEvent(value)
	}
}
impl From<DeploymentEvent> for WebhookPayload {
	fn from(value: DeploymentEvent) -> Self {
		Self::DeploymentEvent(value)
	}
}
impl From<DeploymentStatusEvent> for WebhookPayload {
	fn from(value: DeploymentStatusEvent) -> Self {
		Self::DeploymentStatusEvent(value)
	}
}
impl From<DiscussionEvent> for WebhookPayload {
	fn from(value: DiscussionEvent) -> Self {
		Self::DiscussionEvent(value)
	}
}
impl From<DiscussionCommentEvent> for WebhookPayload {
	fn from(value: DiscussionCommentEvent) -> Self {
		Self::DiscussionCommentEvent(value)
	}
}
impl From<ForkEvent> for WebhookPayload {
	fn from(value: ForkEvent) -> Self {
		Self::ForkEvent(value)
	}
}
impl From<GithubAppAuthorizationEvent> for WebhookPayload {
	fn from(value: GithubAppAuthorizationEvent) -> Self {
		Self::GithubAppAuthorizationEvent(value)
	}
}
impl From<GollumEvent> for WebhookPayload {
	fn from(value: GollumEvent) -> Self {
		Self::GollumEvent(value)
	}
}
impl From<InstallationEvent> for WebhookPayload {
	fn from(value: InstallationEvent) -> Self {
		Self::InstallationEvent(value)
	}
}
impl From<InstallationRepositoriesEvent> for WebhookPayload {
	fn from(value: InstallationRepositoriesEvent) -> Self {
		Self::InstallationRepositoriesEvent(value)
	}
}
impl From<InstallationTargetEvent> for WebhookPayload {
	fn from(value: InstallationTargetEvent) -> Self {
		Self::InstallationTargetEvent(value)
	}
}
impl From<IssueCommentEvent> for WebhookPayload {
	fn from(value: IssueCommentEvent) -> Self {
		Self::IssueCommentEvent(value)
	}
}
impl From<IssuesEvent> for WebhookPayload {
	fn from(value: IssuesEvent) -> Self {
		Self::IssuesEvent(value)
	}
}
impl From<LabelEvent> for WebhookPayload {
	fn from(value: LabelEvent) -> Self {
		Self::LabelEvent(value)
	}
}
impl From<MarketplacePurchaseEvent> for WebhookPayload {
	fn from(value: MarketplacePurchaseEvent) -> Self {
		Self::MarketplacePurchaseEvent(value)
	}
}
impl From<MemberEvent> for WebhookPayload {
	fn from(value: MemberEvent) -> Self {
		Self::MemberEvent(value)
	}
}
impl From<MembershipEvent> for WebhookPayload {
	fn from(value: MembershipEvent) -> Self {
		Self::MembershipEvent(value)
	}
}
impl From<MergeGroupEvent> for WebhookPayload {
	fn from(value: MergeGroupEvent) -> Self {
		Self::MergeGroupEvent(value)
	}
}
impl From<MetaEvent> for WebhookPayload {
	fn from(value: MetaEvent) -> Self {
		Self::MetaEvent(value)
	}
}
impl From<MilestoneEvent> for WebhookPayload {
	fn from(value: MilestoneEvent) -> Self {
		Self::MilestoneEvent(value)
	}
}
impl From<OrgBlockEvent> for WebhookPayload {
	fn from(value: OrgBlockEvent) -> Self {
		Self::OrgBlockEvent(value)
	}
}
impl From<OrganizationEvent> for WebhookPayload {
	fn from(value: OrganizationEvent) -> Self {
		Self::OrganizationEvent(value)
	}
}
impl From<PackageEvent> for WebhookPayload {
	fn from(value: PackageEvent) -> Self {
		Self::PackageEvent(value)
	}
}
impl From<PageBuildEvent> for WebhookPayload {
	fn from(value: PageBuildEvent) -> Self {
		Self::PageBuildEvent(value)
	}
}
impl From<PingEvent> for WebhookPayload {
	fn from(value: PingEvent) -> Self {
		Self::PingEvent(value)
	}
}
impl From<ProjectEvent> for WebhookPayload {
	fn from(value: ProjectEvent) -> Self {
		Self::ProjectEvent(value)
	}
}
impl From<ProjectCardEvent> for WebhookPayload {
	fn from(value: ProjectCardEvent) -> Self {
		Self::ProjectCardEvent(value)
	}
}
impl From<ProjectColumnEvent> for WebhookPayload {
	fn from(value: ProjectColumnEvent) -> Self {
		Self::ProjectColumnEvent(value)
	}
}
impl From<ProjectsV2ItemEvent> for WebhookPayload {
	fn from(value: ProjectsV2ItemEvent) -> Self {
		Self::ProjectsV2ItemEvent(value)
	}
}
impl From<PublicEvent> for WebhookPayload {
	fn from(value: PublicEvent) -> Self {
		Self::PublicEvent(value)
	}
}
impl From<PullRequestEvent> for WebhookPayload {
	fn from(value: PullRequestEvent) -> Self {
		Self::PullRequestEvent(value)
	}
}
impl From<PullRequestReviewEvent> for WebhookPayload {
	fn from(value: PullRequestReviewEvent) -> Self {
		Self::PullRequestReviewEvent(value)
	}
}
impl From<PullRequestReviewCommentEvent> for WebhookPayload {
	fn from(value: PullRequestReviewCommentEvent) -> Self {
		Self::PullRequestReviewCommentEvent(value)
	}
}
impl From<PullRequestReviewThreadEvent> for WebhookPayload {
	fn from(value: PullRequestReviewThreadEvent) -> Self {
		Self::PullRequestReviewThreadEvent(value)
	}
}
impl From<PushEvent> for WebhookPayload {
	fn from(value: PushEvent) -> Self {
		Self::PushEvent(value)
	}
}
impl From<RegistryPackageEvent> for WebhookPayload {
	fn from(value: RegistryPackageEvent) -> Self {
		Self::RegistryPackageEvent(value)
	}
}
impl From<ReleaseEvent> for WebhookPayload {
	fn from(value: ReleaseEvent) -> Self {
		Self::ReleaseEvent(value)
	}
}
impl From<RepositoryEvent> for WebhookPayload {
	fn from(value: RepositoryEvent) -> Self {
		Self::RepositoryEvent(value)
	}
}
impl From<RepositoryDispatchEvent> for WebhookPayload {
	fn from(value: RepositoryDispatchEvent) -> Self {
		Self::RepositoryDispatchEvent(value)
	}
}
impl From<RepositoryImportEvent> for WebhookPayload {
	fn from(value: RepositoryImportEvent) -> Self {
		Self::RepositoryImportEvent(value)
	}
}
impl From<RepositoryVulnerabilityAlertEvent> for WebhookPayload {
	fn from(value: RepositoryVulnerabilityAlertEvent) -> Self {
		Self::RepositoryVulnerabilityAlertEvent(value)
	}
}
impl From<SecretScanningAlertEvent> for WebhookPayload {
	fn from(value: SecretScanningAlertEvent) -> Self {
		Self::SecretScanningAlertEvent(value)
	}
}
impl From<SecurityAdvisoryEvent> for WebhookPayload {
	fn from(value: SecurityAdvisoryEvent) -> Self {
		Self::SecurityAdvisoryEvent(value)
	}
}
impl From<SponsorshipEvent> for WebhookPayload {
	fn from(value: SponsorshipEvent) -> Self {
		Self::SponsorshipEvent(value)
	}
}
impl From<StarEvent> for WebhookPayload {
	fn from(value: StarEvent) -> Self {
		Self::StarEvent(value)
	}
}
impl From<StatusEvent> for WebhookPayload {
	fn from(value: StatusEvent) -> Self {
		Self::StatusEvent(value)
	}
}
impl From<TeamEvent> for WebhookPayload {
	fn from(value: TeamEvent) -> Self {
		Self::TeamEvent(value)
	}
}
impl From<TeamAddEvent> for WebhookPayload {
	fn from(value: TeamAddEvent) -> Self {
		Self::TeamAddEvent(value)
	}
}
impl From<WatchEvent> for WebhookPayload {
	fn from(value: WatchEvent) -> Self {
		Self::WatchEvent(value)
	}
}
impl From<WorkflowDispatchEvent> for WebhookPayload {
	fn from(value: WorkflowDispatchEvent) -> Self {
		Self::WorkflowDispatchEvent(value)
	}
}
impl From<WorkflowJobEvent> for WebhookPayload {
	fn from(value: WorkflowJobEvent) -> Self {
		Self::WorkflowJobEvent(value)
	}
}
impl From<WorkflowRunEvent> for WebhookPayload {
	fn from(value: WorkflowRunEvent) -> Self {
		Self::WorkflowRunEvent(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Workflow {
	pub badge_url:  String,
	pub created_at: chrono::DateTime<chrono::offset::Utc>,
	pub html_url:   String,
	pub id:         i64,
	pub name:       String,
	pub node_id:    String,
	pub path:       String,
	pub state:      String,
	pub updated_at: chrono::DateTime<chrono::offset::Utc>,
	pub url:        String,
}
impl From<&Workflow> for Workflow {
	fn from(value: &Workflow) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowDispatchEvent {
	/// Inputs to the workflow. Each key represents the name of the input while
	/// it's value represents the value of that input.
	pub inputs:       Option<std::collections::HashMap<String, serde_json::Value>>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	/// The branch ref from which the workflow was run.
	#[serde(rename = "ref")]
	pub ref_:         String,
	pub repository:   Repository,
	pub sender:       User,
	/// Relative path to the workflow file which contains the workflow.
	pub workflow:     String,
}
impl From<&WorkflowDispatchEvent> for WorkflowDispatchEvent {
	fn from(value: &WorkflowDispatchEvent) -> Self {
		value.clone()
	}
}
/// The workflow job. Many `workflow_job` keys, such as `head_sha`,
/// `conclusion`, and `started_at` are the same as those in a
/// [`check_run`](#check_run) object.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJob {
	pub check_run_url:     String,
	pub completed_at:      Option<chrono::DateTime<chrono::offset::Utc>>,
	pub conclusion:        Option<WorkflowJobConclusion>,
	pub created_at:        chrono::DateTime<chrono::offset::Utc>,
	/// The name of the current branch.
	pub head_branch:       Option<String>,
	pub head_sha:          String,
	pub html_url:          String,
	pub id:                i64,
	/// Custom labels for the job. Specified by the [`"runs-on"` attribute](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on) in the workflow YAML.
	pub labels:            Vec<String>,
	pub name:              String,
	pub node_id:           String,
	pub run_attempt:       i64,
	pub run_id:            f64,
	pub run_url:           String,
	/// The ID of the runner group that is running this job. This will be `null`
	/// as long as `workflow_job[status]` is `queued`.
	pub runner_group_id:   Option<i64>,
	/// The name of the runner group that is running this job. This will be
	/// `null` as long as `workflow_job[status]` is `queued`.
	pub runner_group_name: Option<String>,
	/// The ID of the runner that is running this job. This will be `null` as
	/// long as `workflow_job[status]` is `queued`.
	pub runner_id:         Option<i64>,
	/// The name of the runner that is running this job. This will be `null` as
	/// long as `workflow_job[status]` is `queued`.
	pub runner_name:       Option<String>,
	pub started_at:        chrono::DateTime<chrono::offset::Utc>,
	/// The current status of the job. Can be `queued`, `in_progress`, or
	/// `completed`.
	pub status:            WorkflowJobStatus,
	pub steps:             Vec<WorkflowStep>,
	pub url:               String,
	/// The name of the workflow.
	pub workflow_name:     Option<String>,
}
impl From<&WorkflowJob> for WorkflowJob {
	fn from(value: &WorkflowJob) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobCompleted {
	pub action:       WorkflowJobCompletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow_job: WorkflowJob,
}
impl From<&WorkflowJobCompleted> for WorkflowJobCompleted {
	fn from(value: &WorkflowJobCompleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobCompletedAction {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&WorkflowJobCompletedAction> for WorkflowJobCompletedAction {
	fn from(value: &WorkflowJobCompletedAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowJobCompletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowJobCompletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowJobCompletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowJobCompletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowJobCompletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&WorkflowJobConclusion> for WorkflowJobConclusion {
	fn from(value: &WorkflowJobConclusion) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowJobConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowJobConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"cancelled" => Ok(Self::Cancelled),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowJobConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowJobConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowJobConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowJobEvent {
	Completed(WorkflowJobCompleted),
	InProgress(WorkflowJobInProgress),
	Queued(WorkflowJobQueued),
}
impl From<&WorkflowJobEvent> for WorkflowJobEvent {
	fn from(value: &WorkflowJobEvent) -> Self {
		value.clone()
	}
}
impl From<WorkflowJobCompleted> for WorkflowJobEvent {
	fn from(value: WorkflowJobCompleted) -> Self {
		Self::Completed(value)
	}
}
impl From<WorkflowJobInProgress> for WorkflowJobEvent {
	fn from(value: WorkflowJobInProgress) -> Self {
		Self::InProgress(value)
	}
}
impl From<WorkflowJobQueued> for WorkflowJobEvent {
	fn from(value: WorkflowJobQueued) -> Self {
		Self::Queued(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobInProgress {
	pub action:       WorkflowJobInProgressAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow_job: WorkflowJob,
}
impl From<&WorkflowJobInProgress> for WorkflowJobInProgress {
	fn from(value: &WorkflowJobInProgress) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobInProgressAction {
	#[serde(rename = "in_progress")]
	InProgress,
}
impl From<&WorkflowJobInProgressAction> for WorkflowJobInProgressAction {
	fn from(value: &WorkflowJobInProgressAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowJobInProgressAction {
	fn to_string(&self) -> String {
		match *self {
			Self::InProgress => "in_progress".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowJobInProgressAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"in_progress" => Ok(Self::InProgress),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowJobInProgressAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowJobInProgressAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowJobInProgressAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowJobQueued {
	pub action:       WorkflowJobQueuedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow_job: WorkflowJob,
}
impl From<&WorkflowJobQueued> for WorkflowJobQueued {
	fn from(value: &WorkflowJobQueued) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobQueuedAction {
	#[serde(rename = "queued")]
	Queued,
}
impl From<&WorkflowJobQueuedAction> for WorkflowJobQueuedAction {
	fn from(value: &WorkflowJobQueuedAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowJobQueuedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowJobQueuedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowJobQueuedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowJobQueuedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowJobQueuedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
/// The current status of the job. Can be `queued`, `in_progress`, or
/// `completed`.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowJobStatus {
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
}
impl From<&WorkflowJobStatus> for WorkflowJobStatus {
	fn from(value: &WorkflowJobStatus) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowJobStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Queued => "queued".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowJobStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"queued" => Ok(Self::Queued),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowJobStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowJobStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowJobStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRun {
	pub actor:                User,
	/// The URL to the artifacts for the workflow run.
	pub artifacts_url:        String,
	/// The URL to cancel the workflow run.
	pub cancel_url:           String,
	/// The ID of the associated check suite.
	pub check_suite_id:       i64,
	/// The node ID of the associated check suite.
	pub check_suite_node_id:  String,
	/// The URL to the associated check suite.
	pub check_suite_url:      String,
	pub conclusion:           Option<WorkflowRunConclusion>,
	pub created_at:           chrono::DateTime<chrono::offset::Utc>,
	pub display_title:        String,
	pub event:                String,
	pub head_branch:          String,
	pub head_commit:          CommitSimple,
	pub head_repository:      RepositoryLite,
	/// The SHA of the head commit that points to the version of the workflow
	/// being run.
	pub head_sha:             String,
	pub html_url:             String,
	/// The ID of the workflow run.
	pub id:                   i64,
	/// The URL to the jobs for the workflow run.
	pub jobs_url:             String,
	/// The URL to download the logs for the workflow run.
	pub logs_url:             String,
	/// The name of the workflow run.
	pub name:                 String,
	pub node_id:              String,
	/// The full path of the workflow
	pub path:                 String,
	/// The URL to the previous attempted run of this workflow, if one exists.
	pub previous_attempt_url: Option<String>,
	pub pull_requests:        Vec<WorkflowRunPullRequestsItem>,
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub referenced_workflows: Vec<ReferencedWorkflow>,
	pub repository:           RepositoryLite,
	/// The URL to rerun the workflow run.
	pub rerun_url:            String,
	/// Attempt number of the run, 1 for first attempt and higher if the
	/// workflow was re-run.
	pub run_attempt:          i64,
	/// The auto incrementing run number for the workflow run.
	pub run_number:           i64,
	/// The start time of the latest run. Resets on re-run.
	pub run_started_at:       chrono::DateTime<chrono::offset::Utc>,
	pub status:               WorkflowRunStatus,
	pub triggering_actor:     User,
	pub updated_at:           chrono::DateTime<chrono::offset::Utc>,
	/// The URL to the workflow run.
	pub url:                  String,
	/// The ID of the parent workflow.
	pub workflow_id:          i64,
	/// The URL to the workflow.
	pub workflow_url:         String,
}
impl From<&WorkflowRun> for WorkflowRun {
	fn from(value: &WorkflowRun) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunCompleted {
	pub action:       WorkflowRunCompletedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow:     Workflow,
	pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunCompleted> for WorkflowRunCompleted {
	fn from(value: &WorkflowRunCompleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunCompletedAction {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&WorkflowRunCompletedAction> for WorkflowRunCompletedAction {
	fn from(value: &WorkflowRunCompletedAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowRunCompletedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowRunCompletedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowRunCompletedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunConclusion {
	#[serde(rename = "success")]
	Success,
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "neutral")]
	Neutral,
	#[serde(rename = "cancelled")]
	Cancelled,
	#[serde(rename = "timed_out")]
	TimedOut,
	#[serde(rename = "action_required")]
	ActionRequired,
	#[serde(rename = "stale")]
	Stale,
	#[serde(rename = "skipped")]
	Skipped,
}
impl From<&WorkflowRunConclusion> for WorkflowRunConclusion {
	fn from(value: &WorkflowRunConclusion) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowRunConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Success => "success".to_string(),
			Self::Failure => "failure".to_string(),
			Self::Neutral => "neutral".to_string(),
			Self::Cancelled => "cancelled".to_string(),
			Self::TimedOut => "timed_out".to_string(),
			Self::ActionRequired => "action_required".to_string(),
			Self::Stale => "stale".to_string(),
			Self::Skipped => "skipped".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowRunConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"success" => Ok(Self::Success),
			"failure" => Ok(Self::Failure),
			"neutral" => Ok(Self::Neutral),
			"cancelled" => Ok(Self::Cancelled),
			"timed_out" => Ok(Self::TimedOut),
			"action_required" => Ok(Self::ActionRequired),
			"stale" => Ok(Self::Stale),
			"skipped" => Ok(Self::Skipped),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowRunConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowRunEvent {
	Completed(WorkflowRunCompleted),
	InProgress(WorkflowRunInProgress),
	Requested(WorkflowRunRequested),
}
impl From<&WorkflowRunEvent> for WorkflowRunEvent {
	fn from(value: &WorkflowRunEvent) -> Self {
		value.clone()
	}
}
impl From<WorkflowRunCompleted> for WorkflowRunEvent {
	fn from(value: WorkflowRunCompleted) -> Self {
		Self::Completed(value)
	}
}
impl From<WorkflowRunInProgress> for WorkflowRunEvent {
	fn from(value: WorkflowRunInProgress) -> Self {
		Self::InProgress(value)
	}
}
impl From<WorkflowRunRequested> for WorkflowRunEvent {
	fn from(value: WorkflowRunRequested) -> Self {
		Self::Requested(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunInProgress {
	pub action:       WorkflowRunInProgressAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow:     Workflow,
	pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunInProgress> for WorkflowRunInProgress {
	fn from(value: &WorkflowRunInProgress) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunInProgressAction {
	#[serde(rename = "in_progress")]
	InProgress,
}
impl From<&WorkflowRunInProgressAction> for WorkflowRunInProgressAction {
	fn from(value: &WorkflowRunInProgressAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowRunInProgressAction {
	fn to_string(&self) -> String {
		match *self {
			Self::InProgress => "in_progress".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowRunInProgressAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"in_progress" => Ok(Self::InProgress),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowRunInProgressAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowRunInProgressAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowRunInProgressAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItem {
	pub base:   WorkflowRunPullRequestsItemBase,
	pub head:   WorkflowRunPullRequestsItemHead,
	pub id:     f64,
	pub number: f64,
	pub url:    String,
}
impl From<&WorkflowRunPullRequestsItem> for WorkflowRunPullRequestsItem {
	fn from(value: &WorkflowRunPullRequestsItem) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemBase {
	#[serde(rename = "ref")]
	pub ref_: String,
	pub repo: RepoRef,
	pub sha:  String,
}
impl From<&WorkflowRunPullRequestsItemBase> for WorkflowRunPullRequestsItemBase {
	fn from(value: &WorkflowRunPullRequestsItemBase) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunPullRequestsItemHead {
	#[serde(rename = "ref")]
	pub ref_: String,
	pub repo: RepoRef,
	pub sha:  String,
}
impl From<&WorkflowRunPullRequestsItemHead> for WorkflowRunPullRequestsItemHead {
	fn from(value: &WorkflowRunPullRequestsItemHead) -> Self {
		value.clone()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowRunRequested {
	pub action:       WorkflowRunRequestedAction,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub installation: Option<InstallationLite>,
	#[serde(default, skip_serializing_if = "Option::is_none")]
	pub organization: Option<Organization>,
	pub repository:   Repository,
	pub sender:       User,
	pub workflow:     Workflow,
	pub workflow_run: WorkflowRun,
}
impl From<&WorkflowRunRequested> for WorkflowRunRequested {
	fn from(value: &WorkflowRunRequested) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunRequestedAction {
	#[serde(rename = "requested")]
	Requested,
}
impl From<&WorkflowRunRequestedAction> for WorkflowRunRequestedAction {
	fn from(value: &WorkflowRunRequestedAction) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowRunRequestedAction {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowRunRequestedAction {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowRunRequestedAction {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowRunRequestedAction {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowRunRequestedAction {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowRunStatus {
	#[serde(rename = "requested")]
	Requested,
	#[serde(rename = "in_progress")]
	InProgress,
	#[serde(rename = "completed")]
	Completed,
	#[serde(rename = "queued")]
	Queued,
	#[serde(rename = "waiting")]
	Waiting,
}
impl From<&WorkflowRunStatus> for WorkflowRunStatus {
	fn from(value: &WorkflowRunStatus) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowRunStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Requested => "requested".to_string(),
			Self::InProgress => "in_progress".to_string(),
			Self::Completed => "completed".to_string(),
			Self::Queued => "queued".to_string(),
			Self::Waiting => "waiting".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowRunStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"requested" => Ok(Self::Requested),
			"in_progress" => Ok(Self::InProgress),
			"completed" => Ok(Self::Completed),
			"queued" => Ok(Self::Queued),
			"waiting" => Ok(Self::Waiting),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowRunStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WorkflowStep {
	InProgress(WorkflowStepInProgress),
	Completed(WorkflowStepCompleted),
}
impl From<&WorkflowStep> for WorkflowStep {
	fn from(value: &WorkflowStep) -> Self {
		value.clone()
	}
}
impl From<WorkflowStepInProgress> for WorkflowStep {
	fn from(value: WorkflowStepInProgress) -> Self {
		Self::InProgress(value)
	}
}
impl From<WorkflowStepCompleted> for WorkflowStep {
	fn from(value: WorkflowStepCompleted) -> Self {
		Self::Completed(value)
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepCompleted {
	pub completed_at: chrono::DateTime<chrono::offset::Utc>,
	pub conclusion:   WorkflowStepCompletedConclusion,
	pub name:         String,
	pub number:       i64,
	pub started_at:   chrono::DateTime<chrono::offset::Utc>,
	pub status:       WorkflowStepCompletedStatus,
}
impl From<&WorkflowStepCompleted> for WorkflowStepCompleted {
	fn from(value: &WorkflowStepCompleted) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedConclusion {
	#[serde(rename = "failure")]
	Failure,
	#[serde(rename = "skipped")]
	Skipped,
	#[serde(rename = "success")]
	Success,
}
impl From<&WorkflowStepCompletedConclusion> for WorkflowStepCompletedConclusion {
	fn from(value: &WorkflowStepCompletedConclusion) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowStepCompletedConclusion {
	fn to_string(&self) -> String {
		match *self {
			Self::Failure => "failure".to_string(),
			Self::Skipped => "skipped".to_string(),
			Self::Success => "success".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowStepCompletedConclusion {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"failure" => Ok(Self::Failure),
			"skipped" => Ok(Self::Skipped),
			"success" => Ok(Self::Success),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedConclusion {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedConclusion {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedConclusion {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepCompletedStatus {
	#[serde(rename = "completed")]
	Completed,
}
impl From<&WorkflowStepCompletedStatus> for WorkflowStepCompletedStatus {
	fn from(value: &WorkflowStepCompletedStatus) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowStepCompletedStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::Completed => "completed".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowStepCompletedStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"completed" => Ok(Self::Completed),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowStepCompletedStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowStepCompletedStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowStepCompletedStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WorkflowStepInProgress {
	pub completed_at: (),
	pub conclusion:   (),
	pub name:         String,
	pub number:       i64,
	pub started_at:   chrono::DateTime<chrono::offset::Utc>,
	pub status:       WorkflowStepInProgressStatus,
}
impl From<&WorkflowStepInProgress> for WorkflowStepInProgress {
	fn from(value: &WorkflowStepInProgress) -> Self {
		value.clone()
	}
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WorkflowStepInProgressStatus {
	#[serde(rename = "in_progress")]
	InProgress,
}
impl From<&WorkflowStepInProgressStatus> for WorkflowStepInProgressStatus {
	fn from(value: &WorkflowStepInProgressStatus) -> Self {
		value.clone()
	}
}
impl ToString for WorkflowStepInProgressStatus {
	fn to_string(&self) -> String {
		match *self {
			Self::InProgress => "in_progress".to_string(),
		}
	}
}
impl std::str::FromStr for WorkflowStepInProgressStatus {
	type Err = &'static str;

	fn from_str(value: &str) -> Result<Self, &'static str> {
		match value {
			"in_progress" => Ok(Self::InProgress),
			_ => Err("invalid value"),
		}
	}
}
impl std::convert::TryFrom<&str> for WorkflowStepInProgressStatus {
	type Error = &'static str;

	fn try_from(value: &str) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<&String> for WorkflowStepInProgressStatus {
	type Error = &'static str;

	fn try_from(value: &String) -> Result<Self, &'static str> {
		value.parse()
	}
}
impl std::convert::TryFrom<String> for WorkflowStepInProgressStatus {
	type Error = &'static str;

	fn try_from(value: String) -> Result<Self, &'static str> {
		value.parse()
	}
}
pub mod defaults {
	pub(super) fn default_bool<const V: bool>() -> bool {
		V
	}
}
